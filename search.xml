<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 动态编译</title>
    <url>/2020/05/12/Java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测<br>系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：<br><strong>通过JavaCompiler动态编译：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compileFile</span><span class="params">(String sourceFile)</span></span>&#123;</span><br><span class="line">  <span class="comment">//动态编译</span></span><br><span class="line">  JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">  <span class="keyword">int</span> result = compiler.run(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,sourceFile);</span><br><span class="line">  System.out.println(result==<span class="number">0</span>?<span class="string">"编译成功"</span>:<span class="string">"编译失败"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 第一个参数：为java编译器提供参数<br>• 第二个参数：得到 Java 编译器的输出信息<a id="more"></a><br>• 第三个参数：接收编译器的 错误信息<br>• 第四个参数：可变参数（是一个String数组）能传入一个或多个 Java 源文件<br>• 返回值：0表示编译成功，非0表示编译失败</p>
<p><strong>动态运行编译好的类：</strong></p>
<ul>
<li>通过Runtime.getRuntime()运行启动新的进程运行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime run = Runtime.getRuntime();</span><br><span class="line">Process process = run.exec(<span class="string">"java -cp path HelloWorld"</span>);</span><br></pre></td></tr></table></figure></li>
<li>通过反射运行编译好的类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射运行程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runJavaClassByReflect</span><span class="params">(String dir,String classFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:/"</span>+dir)&#125;;</span><br><span class="line">    URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">    Class c = loader.loadClass(classFile);</span><br><span class="line">    <span class="comment">//调用加载类的main方法</span></span><br><span class="line">    Method m = c.getMethod(<span class="string">"main"</span>,String[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">		m.invoke(null, (Object)new String[]&#123;&#125;);//反射调用main方法加(object)强制转型</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  	e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 注解</title>
    <url>/2020/05/10/Java-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>Annotation的作用：</strong><br>1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)<br>2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)<br><strong>Annotation的格式：</strong><br>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:<br>@SuppressWarnings(value=”unchecked”)。(抑制警告)<br><strong>Annotation在哪里使用：</strong><br>可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。<a id="more"></a><br><strong>自定义注解：</strong><br>格式：public @interface 注解名 {定义体}<br>1.方法的名称就是参数的名称;<br>2.返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）;<br>3.可以通过default来声明参数的默认值<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>;<br>4.如果只有一个参数成员，一般参数名为value;<br><strong>元注解：</strong><br>元注解的作用就是负责注解其他注解。 Java定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。<br>1.@Target：用于描述注解的使用范围（即:被描述的注解可以用在什么地方）<br>ElementType.TYPE；ElementType.FIELD…<br>2.@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期<br>SOURCE；CLASS；RUNTIME(可被反射机制读取)<br>3.@Documented<br>4.@Inherited<br><strong>通过反射读取注解的流程：</strong></p>
<ul>
<li>自定义类注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> test01Table &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义属性注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> test01Field &#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在test01中加入注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@test</span>01Table(<span class="string">"tb_member"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"id"</span>, type = <span class="string">"int"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"sname"</span>, type = <span class="string">"varchar"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"age"</span>, type = <span class="string">"int"</span>, length = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取test01中的注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射读取自定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.sgg.annotation.test01"</span>);</span><br><span class="line">            <span class="comment">//获得类的有效注解</span></span><br><span class="line">            Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span>(Annotation a : annotations)&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得类的制定注解</span></span><br><span class="line">            test01Table tt = (test01Table)clazz.getAnnotation(test01Table<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(tt.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得类的属性的对应注解</span></span><br><span class="line">            Field f = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">            test01Field tf = (test01Field)f.getAnnotation(test01Field<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(tf.columnName() +<span class="string">"--"</span>+ tf.type() +<span class="string">"--"</span>+ tf.length());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来可以利用注解信息写出DDL语句，完成相应的数据库操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM核心机制-类加载过程</title>
    <url>/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>类加载的作用：</strong>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口：</p>
<img src="/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/JVM01.png" width="80%" height="80%">

<p><strong>类加载器的层次结构(树状结构):</strong></p>
<ul>
<li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader；<a id="more"></a></li>
<li>扩展类加载器（extensions class loader）：用来加载 Java 的扩展库，Java 虚拟机的实现会提供一个<strong>扩展库</strong>目录。该类加载器在此目录里面查找并加载 Java类，由ExtClassLoader实现；</li>
<li>应用程序类加载器（application class loader）：它根据 Java 应用的类路径来加载 Java 类，一般来说，Java 应用的类都是由它来完成加载的，由AppClassLoader实现；</li>
<li>自定义类加载器： 开发人员可以通过继承 java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。</li>
</ul>
<p>注意：<u>类加载器加载类的时候是线程安全的</u></p>
<img src="/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/JVM02.png" width="80%" height="80%">

<p><strong>双亲委托机制：</strong></p>
<ul>
<li>就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</li>
<li>双亲委托机制是为了保证 Java 核心库的类型安全，这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。</li>
<li>类加载器除了用于加载类，也是安全的最基本的屏障。</li>
<li>双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制：tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 反射</title>
    <url>/2020/05/11/Java-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>虽然Java不是动态语言<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。<br><strong>反射：</strong>指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象<strong>(一个类只有一个 Class 对象)</strong>，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。<br><strong>反射机制的作用：</strong>重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。<a id="more"></a><br><strong>获取Class对象：</strong><br>1.Class.forName();(常用)<br>2.getClass();<br>3..class;<br><strong>代码：</strong></p>
<ul>
<li>javaBean:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">//javabean一定要有无参构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获得User类的反射对象：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String path = <span class="string">"com.sxt.test.bean.User"</span>;</span><br><span class="line">Class clazz = Class.forName(path);<span class="comment">//方法一</span></span><br><span class="line"></span><br><span class="line">User u = <span class="keyword">new</span> User();</span><br><span class="line">Class clazz2 = u.getClass();<span class="comment">//方法二</span></span><br><span class="line"></span><br><span class="line">Class clazz3 = com.sxt.test.bean.User<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//方法三</span></span><br></pre></td></tr></table></figure></li>
<li>获得User类的属性：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field f = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure></li>
<li>获得User类的方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method m01 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果方法有参数，则必须传递参数类型对应的Class对象</span></span><br><span class="line">Method m02 = clazz.getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>获得User类指定的构造器：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>通过反射API动态的操作：构造器，方法，属性：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射API调用构造方法，构造对象</span></span><br><span class="line">User u1 = (User) clazz.getConstructor().newInstance();<span class="comment">//调用了User的无参构造器</span></span><br><span class="line">User u2 =  (User)clazz.getConstructor(int.class,int.class,String.class).newInstance(1001,18,"席博");//调用了User带参构造器</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射API调用普通方法 invoke(对象，参数)方法</span></span><br><span class="line">User u3 = (User) clazz.getConstructor().newInstance();</span><br><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">method.invoke(u3, <span class="string">"aaa"</span>);<span class="comment">//u3.setName("aaa");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射API操作属性</span></span><br><span class="line">User u4 = (User) clazz.getConstructor().newInstance();</span><br><span class="line">Field f = clazz.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//通过反射获得属性</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//这个属性不需要做安全检查，可以直接访问</span></span><br><span class="line">f.set(u4, <span class="string">"bbb"</span>); <span class="comment">//通过反射直接写u4属性</span></span><br><span class="line">f.get(u4);<span class="comment">//通过反射读取u4属性</span></span><br></pre></td></tr></table></figure></li>
<li>通过反射读取泛型的信息：ParameterizedType: 表示一种参数化的类型，比如Collection<String>；</String></li>
<li>通过反射读取注解的信息，模拟处理注解信息的流程，具体参见：<a href="https://chrisxb1996.github.io/2020/05/10/Java-注解/">Java 注解</a></li>
</ul>
<p><strong>反射的性能问题：</strong>使用反射性能会降低(约30倍)，setAccessible：启用和禁用访问安全检查的开关，设为 true 则表示反射的对象在使用时禁止 Java 语言访问检查。禁止安全检查，可以提高反射的运行速度(大约提高四倍)。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">动态语言：程序运行时，可以改变程序结构或变量类型。常见的动态语言：Python、ruby、javascript</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模版方法模式</title>
    <url>/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>模板方法模式也叫方法回调或钩子方法，是编程中经常用得到模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。</p>
<p><strong>核心：</strong>处理步骤父类中定义好，具体实现延迟到子类中定义。<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"取号排队"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span></span>; <span class="comment">//办理具体的业务	//钩子方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"反馈评分"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.takeNumber();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.transact();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.evaluate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//采用匿名内部类</span></span><br><span class="line">        BankTemplateMethod btm = <span class="keyword">new</span> BankTemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"取钱：2000！！！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        btm.process();</span><br><span class="line"></span><br><span class="line">        BankTemplateMethod btm2 = <span class="keyword">new</span> BankTemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我要存钱：2000000！！！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        btm2.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>•  什么时候用到模板方法模式：</strong>实现一个算法时，整体步骤很固定。但是，某些部分易变。易变部分可以抽象成出来，供子类实现。</p>
<p><strong>•  开发中常见的场景：</strong>非常频繁。各个框架、类库中都有他的影子。比如常见的有：<br>1.数据库访问的封装；<br>2.Junit单元测试；<br>3.servlet中关于doGet/doPost方法调用；<br>4.Hibernate中模板程序；<br>5.spring中JDBCTemplate、HibernateTemplate等；</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>模版方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>某个市场人员接到单后的报价策略(CRM系统中常见问题)。报价策略很复杂，可以简单作如下分类：<br>•  普通客户小批量报价<br>•  普通客户大批量报价<br>•  老客户小批量报价<br>•  老客户大批量报价<br>具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。<a id="more"></a></p>
<p>我们先可以采用条件语句处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(String type, <span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(type.equals(<span class="string">"普通客户小批量"</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">"不打折,原价"</span>);</span><br><span class="line">			<span class="keyword">return</span> price;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"普通客户大批量"</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">"打九折"</span>);</span><br><span class="line">			<span class="keyword">return</span> price*<span class="number">0.9</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"老客户小批量"</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">"打八五折"</span>);</span><br><span class="line">			<span class="keyword">return</span> price*<span class="number">0.85</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"老客户大批量"</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">"打八折"</span>);</span><br><span class="line">			<span class="keyword">return</span> price*<span class="number">0.8</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但类型特别多，算法比较复杂时，整个条件控制代码会变得很长，难于维护。</strong></p>
<p>策略模式对应于解决某一个问题的一个<u><strong>算法族</strong></u>，允许用户从该算法族中任选一个算法解决某一问题，同时可以<u><strong>方便的更换算法或者增加新的算法</strong></u>。并且<u><strong>由客户端决定调用哪个算法</strong></u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">double</span> standardPrice)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新客户小批量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCustomerFew</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">double</span> standardPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"不打折原价"</span>);</span><br><span class="line">        <span class="keyword">return</span> standardPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//新客户大批量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCustomerLarge</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">double</span> standardPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打九折！"</span>);</span><br><span class="line">        <span class="keyword">return</span> standardPrice*<span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//老客户小批量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldCustomerFew</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">double</span> standardPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打85折"</span>);</span><br><span class="line">        <span class="keyword">return</span> standardPrice*<span class="number">0.85</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//老客户大批量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldCustomLarge</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">double</span> standardPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打8折"</span>);</span><br><span class="line">        <span class="keyword">return</span> standardPrice*<span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文类</span></span><br><span class="line"><span class="comment">//负责和具体的策略类交互，是的客户端和算法独立</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy; <span class="comment">//当前采用的算法对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过set方法注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPrice</span><span class="params">(<span class="keyword">double</span> s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"价格："</span>+strategy.getPrice(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Strategy s1 = <span class="keyword">new</span> OldCustomerFew();</span><br><span class="line">        Strategy s2 = <span class="keyword">new</span> OldCustomLarge();</span><br><span class="line">        Context ctx = <span class="keyword">new</span> Context(s1);</span><br><span class="line">        Context  ctx2 = <span class="keyword">new</span> Context(s2);</span><br><span class="line">        <span class="keyword">int</span> standardPrice = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        ctx.printPrice(standardPrice);</span><br><span class="line">        ctx2.printPrice(standardPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/策略模式.png" width="100%" height="100%">

<p><strong>•  本质：</strong>分离算法，选择实现。<br><strong>•  开发中常见的场景：</strong>JAVASE中GUI编程中，布局管理；Spring框架中，Resource接口，资源访问策略；javax.servlet.http.HttpServlet#service()</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>核心作用：</strong>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。<br><strong>常见应用场景：</strong>Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…<br><strong>常见的五种单例模式实现方式：</strong><br>  1.饿汉式：线程安全，调用效率高。 但是，不能延时加载；<br>  2.懒汉式：线程安全，调用效率不高，可以延时加载；<br>  3.静态内部类式：线程安全，调用效率高，可以延时加载；<a id="more"></a><br>  4.枚举式：线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化创建对象的漏洞！<br>  5.<del>双重检测锁式</del>：JVM底层内部模型原因，偶尔会出问题。<strong>不建议使用；</strong></p>
<p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时，上来先创建对象（没有延时加载的优势），加载类时，天然线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo01 instance = <span class="keyword">new</span> SingletonDemo01();</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">SingletonDemo01</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//优点：方法没有同步调用效率高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时，不创建对象（延时加载，真正用的时候再创建）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo02 instance;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo02</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//需要加同步，保证单例模式，效率较低</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo02 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> SingletonDemo02();</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类方式：线程安全，调用效率高，实现延时加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo03 instance = <span class="keyword">new</span> SingletonDemo03();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo03</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//优点：方法没有同步调用效率高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  SingletonInnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类方式：线程安全，但没有延时加载；同时能够避免反射和反序列的漏洞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo04 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">//可以自己添加一些操作方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instanceOper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何选用合适的单例模式：</strong><br>单例对象占用资源少，不需要延时加载：枚举式 &gt; 饿汉式;<br>单例对象占用资源大，需要 延时加载：静态内部类式 &gt; 懒汉式;</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>核心：</strong>实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。<br><strong>三种类型的工厂模式：</strong><br><strong>1.简单工厂（使用较多）：</strong>又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；<br><strong>2.工厂方法：</strong>为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，<strong>但实际上，我们一般都用简单工厂模式</strong>；<a id="more"></a><br><strong>3.抽象工厂：</strong>用来生产不同产品族的全部产品：在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式；</p>
<p><strong>不使用工厂模式的情况：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Audi跑！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Byd</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Byd跑！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123; <span class="comment">//调用者</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Car c1 = <span class="keyword">new</span> Audi();</span><br><span class="line">    Car c2 = <span class="keyword">new</span> Byd();</span><br><span class="line">    c1.run();</span><br><span class="line">    c2.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单工厂：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createAudi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createByd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Byd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;<span class="comment">//调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = CarFactory.createAudi();</span><br><span class="line">        Car car2 = CarFactory.createByd();</span><br><span class="line">        car1.run();</span><br><span class="line">        car2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/simplefactory.png" width="32%" height="32%">

<p><strong>工厂方法：</strong><br>增加两个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BydFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Byd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;<span class="comment">//调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = <span class="keyword">new</span> AudiFactory().createCar();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> BydFactory().createCar();</span><br><span class="line">        car1.run();</span><br><span class="line">        car2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/factorymethod.png" width="48%" height="48%">

<p><strong>抽象工厂：</strong><br><img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abstractfactory.png" width="100%" height="100%"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>用hexo搭建个人博客</title>
    <url>/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><strong>准备工作</strong><br>安装git：<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a><br>安装nodejs：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br><strong>安装hexo</strong><br>1.以管理员身份运行：sudo su<br>2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。<a id="more"></a><br>3.在国内建议先安装淘宝镜像源 cnpm再进行安装hexo：<br>输入：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>; 安装完后查    看是否安装成功： cnpm -v：<br><img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/001.png" alt="001"><br>    利用cnpm安装hexo博客 ：cnpm install -g hexo-cli<br>    安装成功可查看hexo信息：hexo -v:<br>    <img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/002.png" width="33%" height="33%"><br>4.可以新建一个 文件夹作为存放目录：mkdir blog，进到目录中：cd blog/ (注意操作都在当前文件夹下进行操作)<br>5.至此，hexo已经为你生成了基础博客框架，启动hexo输入 :hexo s<br><img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/003.png" width="80%" height="80%"><br>6.在浏览器输入地址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 可以看到基本框架已经生成。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>•  每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。</p>
<p>•  应用层的许多协议都是基于客户服务器方式。客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。<a id="more"></a> </p>
<p>•  常用端口：</p>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/常用端口.png" width="100%" height="100%">

<h3 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h3><p>DNS 是一个<strong>分布式数据库</strong>，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名…</p>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS域名.png" width="100%" height="100%">

<h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址(DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址)等信息。</p>
<p>DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。 </p>
<p>•  DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。<br>•  DHCP 客户从 UDP 端口 68发送 <strong>DHCP发现报文(DHCPDISCOVER)</strong>。该报文被放入 UDP 中，广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。<br>•  凡收到 DHCP 发现报文的 DHCP 服务器都发出 <strong>DHCP 提供报文(DHCPOFFER)</strong>，因此 DHCP 客户可能收到多个 DHCP 提供报文。<br>•  DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 <strong>DHCP 请求报文(DHCPREQUEST)</strong>。<br>•  被选择的 DHCP 服务器发送<strong>确认报文DHCPACK</strong>，进入已绑定状态，并可开始使用得到的临时 IP 地址了。</p>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP.png" width="100%" height="100%">

<h3 id="文件传送协议-FTP"><a href="#文件传送协议-FTP" class="headerlink" title="文件传送协议 FTP"></a>文件传送协议 FTP</h3><p>文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议， FTP使用两个TCP连接：TCP控制链接、TCP数据连接：</p>
<ul>
<li><strong>控制连接：</strong>标准端口为21，在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。</li>
<li><strong>数据连接：</strong>标准端口为20，实际用于传输文件。</li>
</ul>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/FTP.png" width="100%" height="100%">

<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<ul>
<li><strong>主动模式：</strong>服务端从20端口主动向客户端发起连接。</li>
<li><strong>被动模式：</strong>服务端在指定范围内的某个端口被动等待客户端发起连接</li>
</ul>
<p><strong>注意：</strong>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙(需要在防火墙上开放20和21端口)。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h3 id="按远程终端协议-TELNET"><a href="#按远程终端协议-TELNET" class="headerlink" title="按远程终端协议 TELNET"></a>按远程终端协议 TELNET</h3><p>TELNET 是一个简单的远程终端协议，也是因特网的正式标准。</p>
<p>•  TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。<br>•  TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h3 id="电子邮件协议-SMTP-POP3-IMAP"><a href="#电子邮件协议-SMTP-POP3-IMAP" class="headerlink" title="电子邮件协议(SMTP, POP3, IMAP)"></a>电子邮件协议(SMTP, POP3, IMAP)</h3><ul>
<li><strong>发送邮件的协议：</strong>SMTP使用TCP 25端口。</li>
<li><strong>读取邮件的协议：</strong>POP3 使用110端口和 IMAP使用的端口是143。</li>
</ul>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/电子邮件.png" width="100%" height="100%">

<p>•  <strong>SMTP：</strong>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP.png" width="100%" height="100%">

<p>•  <strong>POP3：</strong>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p>
<p>•  <strong>IMAP：</strong>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h3 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h3><p>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。</p>
<p>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。URL有如下一般形式：</p>
<p><strong>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</strong> </p>
<p>•  &lt;协议&gt; ftp、http、News…<br>•  &lt;主机&gt; 是存放资源的主机在因特网中的域名;<br>•  &lt;端口&gt;/&lt;路径&gt; 有时可省略；</p>
<p><strong>请求web服务的过程：</strong></p>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/万维网工作过程.png" width="100%" height="100%">

<h4 id="HTTP的报文结构："><a href="#HTTP的报文结构：" class="headerlink" title="HTTP的报文结构："></a>HTTP的报文结构：</h4><p>HTTP 有两类报文：</p>
<p><strong>•  请求报文</strong>——从客户向服务器发送请求报文。<br><strong>•  响应报文</strong>——从服务器到客户的回答。<br><strong>•</strong>  由于 HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</p>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP报文(请求报文).png" width="100%" height="100%">

<p>报文由三个部分组成，即开始行、首部行和实体主体。在请求报文中，开始行就是<strong>请求行</strong>。包含了方法字段。</p>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP方法.png" width="100%" height="100%">

<p>响应报文的开始行是<strong>状态行</strong>。状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。 </p>
<img src="/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP报文(响应报文).png" width="100%" height="100%">

<p><strong>•  1xx</strong> ：Informational（信息性状态码），表示通知信息的，如请求收到了或正在进行处理。</p>
<ul>
<li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<p><strong>•  2xx</strong> ：Success（成功状态码），表示成功，如接受或知道了。</p>
<ul>
<li>200 OK</li>
<li>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<p><strong>•  3xx</strong> ：Redirection（重定向状态码），表示重定向，表示要完成请求还必须采取进一步的行动。</p>
<ul>
<li>301 Moved Permanently ：永久性重定向</li>
<li>302 Found ：临时性重定向</li>
<li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<p><strong>•  4xx</strong> ：Client Error（客户端错误状态码），表示客户的差错，如请求中有错误的语法或不能完成。</p>
<ul>
<li>400 Bad Request ：请求报文中存在语法错误。</li>
<li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Forbidden ：请求被拒绝。</li>
<li>404 Not Found</li>
</ul>
<p><strong>•  5xx</strong>  ：Server Error（服务器错误状态码），表示服务器的差错，如服务器失效无法完成请求。</p>
<ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>1.主机H1向H2发送数据：<br>层次上来看：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/图片 1.png" width="100%" height="100%"><br>仅从数据链路层观察帧的流动：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/图片 2.png" width="100%" height="100%"></p>
<p><strong>注意：</strong>可以看到路由器只到网络层(三层协议)，没有应用层，和传输层；<a id="more"></a> </p>
<p>2.数据链路层传输的是帧：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/数据链路层传送帧.png" width="100%" height="100%"></p>
<h4 id="数据链路层的三个基本点："><a href="#数据链路层的三个基本点：" class="headerlink" title="数据链路层的三个基本点："></a>数据链路层的三个基本点：</h4><p>1.封装成帧<br>2.透明传输<br>3.差错控制</p>
<p><strong>封装成帧：</strong>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/封装成帧.png" width="100%" height="100%"></p>
<p><strong>透明传输：</strong>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/透明传输.png" width="100%" height="100%"></p>
<p><strong>差错控制：</strong>在数据链路层传送的帧中，广泛使用了循环冗余检验 (CRC) 的检错技术：<strong>CRC是一种无比特差错，而不是无传输差错的检测机制</strong>。将得到的FCS(帧检验序列 )添加在原序列后面，在接收端检验：若得出的余数 <em>R</em> = 0，则判定这个帧没有差错，就接受(accept)；若余数 <em>R</em> != 0，则判定这个帧有差错，就丢弃，在高层进行重传指令。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/CRC.png" width="100%" height="100%"></p>
<h3 id="数据链路层的信道类型"><a href="#数据链路层的信道类型" class="headerlink" title="数据链路层的信道类型"></a>数据链路层的信道类型</h3><h4 id="点对点信道："><a href="#点对点信道：" class="headerlink" title="点对点信道："></a>点对点信道：</h4><p>使用一对一的点对点通信方式，不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议，支持身份验证，支持多个网络层协议。<br>PPP协议帧格式：<br>1.A、C：在点到点信道没有实际意义，固定为：FF、03；<br>2.协议字段(2字节)：用于标识信息部分是什么内容；<br>3.FCS(2字节)：表示CRC得到的帧检验序列；<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP协议.png" width="100%" height="100%"></p>
<h4 id="广播信道："><a href="#广播信道：" class="headerlink" title="广播信道："></a>广播信道：</h4><p>这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送<strong>(随机接入)</strong>：CSMA/CD(载波监听多点接入/碰撞检测) 协议：<br><strong>多点接入：</strong>表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听：</strong>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br><strong>碰撞检测</strong>：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于传播时延的存在，还是有可能会发生碰撞。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/随机接入碰撞.png" width="100%" height="100%"></p>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，<strong>称 2τ 为 争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。以太网中经过计算，最短有效帧长为512bit，也就是64个字节，规定凡是长度小于64字节的帧都是无效帧。<br>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。<br><strong>注意：</strong>该协议只能(只能进行半双工通信)。</p>
<h3 id="以太局域网"><a href="#以太局域网" class="headerlink" title="以太局域网"></a>以太局域网</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p><strong>以太网是一种星型拓扑结构局域网。</strong>早期使用集线器(hub)进行连接，<strong>集线器是一种物理层设备</strong>， 作用于比特而不是帧。目前以太网使用交换机替代了集线器，<strong>交换机是一种链路层设备</strong>，它不会发生碰撞，能根据 MAC 地址进行存储转发。<br>以太网提供的服务是不可靠的交付，即尽最大努力的交付。当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p>
<h4 id="信道利用率："><a href="#信道利用率：" class="headerlink" title="信道利用率："></a>信道利用率：</h4><p>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲时为止，是发送一帧所需的平均时间。 信道利用率可以表示为：T0/发送一帧所需的平均时间。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网信道利用率.png" width="100%" height="100%"> </p>
<h4 id="MAC层-数据链路层的子层-："><a href="#MAC层-数据链路层的子层-：" class="headerlink" title="MAC层(数据链路层的子层)："></a>MAC层(数据链路层的子层)：</h4><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。<br>以太网MAC帧格式：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网帧格式.png" width="100%" height="100%"> </p>
<h3 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h3><h4 id="网桥-淘汰-："><a href="#网桥-淘汰-：" class="headerlink" title="网桥(淘汰)："></a>网桥(淘汰)：</h4><p>在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/网桥扩展以太网.png" width="100%" height="100%"> </p>
<h4 id="交换机："><a href="#交换机：" class="headerlink" title="交换机："></a>交换机：</h4><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。<br>1.端口独享带宽；<br>2.比集线器安全，可以设置固定MAC地址；<br>3.接口到计算机全双工；<br>4.全双工模式不再使用CSMA/CD协议；<br>5.接口可以工作在不同的速率；<br>6.广播帧会转发到全部端口；<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/交换机.png" width="100%" height="100%"> </p>
<h4 id="虚拟局域网-VLAN"><a href="#虚拟局域网-VLAN" class="headerlink" title="虚拟局域网(VLAN):"></a>虚拟局域网(VLAN):</h4><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。例如：在研发部某台主机广播的消息只能住研发部收到，销售部和人力资源部则收不到消息。<br>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/VLAN.png" width="100%" height="100%"> </p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信:"></a>进程之间的通信:</h4><ul>
<li>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</li>
<li><strong>传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</strong></li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。<a id="more"></a> </li>
</ul>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/传输层协议概述.png" width="100%" height="100%">

<h4 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP:"></a>TCP和UDP:</h4><p>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。</p>
<ul>
<li>用户数据报协议 UDP (User Datagram Protocol)：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP (Transmission Control Protocol)：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h4 id="传输层的端口"><a href="#传输层的端口" class="headerlink" title="传输层的端口:"></a>传输层的端口:</h4><p>运行在计算机中的进程是用<strong>进程标识符</strong>来标志的，为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。解决这个问题的方法就是在运输层使用协议端口号(protocol port number)，或通常简称为<strong>端口</strong>(port)。</p>
<ul>
<li>端口用一个 16 位端口号进行标志。</li>
<li>端口号只具有<strong>本地意义</strong>，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。</li>
<li>三类端口 ：<br>1.熟知端口，数值一般为 0-1023；<br>2.登记端口号，数值为1024-49151，为没有熟知端口号的应用程序使用的；<br>3.客户端口号，数值为49152-65535，留给客户进程选择暂时使用；</li>
<li>常用应用层协议与传输层端口：<br>http = TCP + 80；<br>https = TCP + 443；<br>ftp = TCP + 21；<br>SMTP = TCP + 25；<br>POP3 = TCP + 101；<br>RDP = TCP + 3389；<br>SQL = TCP + 1433；<br>DNS = UDP + 53  or  TCP + 53(极少情况)</li>
<li><strong>计算机服务(对外的服务)运行后在TCP或UDP的某个端口侦听客户端请求。</strong></li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p>
<ul>
<li>UDP 是<u><strong>无连接的</strong></u>，即发送数据之前不需要建立连接<u>(主要针对短包，实时性要求不高的数据)</u>。</li>
<li>UDP 使用尽最大努力交付，即<u><strong>不保证可靠交付</strong></u>，同时也<u><strong>不使用拥塞控制</strong></u>。</li>
<li>UDP 是<u><strong>面向报文</strong>的</u>。UDP 没有拥塞控制，很适合多媒体通信的要求。</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。 </li>
<li>UDP 的首部开销小，只有 8 个字节。</li>
</ul>
<p><strong>面向报文：</strong>送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。应用程序必须选择合适大小的报文。</p>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP面向报文.png" width="100%" height="100%">

<p><strong>UDP首部格式：</strong>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP首部.png" width="100%" height="100%">

<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP-概述："><a href="#TCP-概述：" class="headerlink" title="TCP 概述："></a>TCP 概述：</h4><p>主要特点:<br>1.TCP是<strong>面向连接</strong>的运输层协议；<br>2.每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是<strong>点对点</strong>的(一对一)；<br>3.TCP 提供<strong>可靠交付</strong>的服务；<br>4.TCP 提供<strong>全双工通信</strong>；<br>5.<strong>面向字节流</strong>；</p>
<p><strong>面向字节流的传输过程：</strong></p>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP面向字节流的传输过程.png" width="100%" height="100%">

<p><strong>注意：</strong><br>1.TCP 连接是一条虚连接而不是一条真正的物理连接。<br>2.TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong><u>套接字(socket)</u></strong>，端口号拼接到 IP 地址即构成了套接字。<br>套接字 socket = (IP地址: 端口号)；<br>3.每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：<br>TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}；</p>
<h4 id="TCP-报文首部格式："><a href="#TCP-报文首部格式：" class="headerlink" title="TCP 报文首部格式："></a>TCP 报文首部格式：</h4><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP首部格式.png" width="100%" height="100%">

<ul>
<li><strong>源端口和目的端口字段——各占 2 字节</strong>，端口传输层与应用层的服务接口。传输层的复用和分用功能都要通过端口才能实现。 </li>
<li><strong>序号字段——占 4 字节</strong>，TCP 连接中传送的字节流中的每一个数据段都编上一个序号。序号字段的值则指的是<strong>本报文段</strong>所发送的数据的<strong>第一个字节的序号</strong>。</li>
<li><strong>确认号字段——占 4 字节</strong>，是期望收到对方的<strong>下一个报文段</strong>的数据的第<strong>一个字节的序号</strong>。</li>
<li><strong>数据偏移(即首部长度)——占 4 位</strong>，它表示首部长度，最长60个字节，故可变长度最长40个字节。</li>
<li><strong>保留字段——占 6 位</strong>，保留为今后使用，但目前应置为 0。 </li>
<li><strong>紧急 URG</strong> —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。</li>
<li><strong>确认 ACK</strong> —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 </li>
<li><strong>推送 PSH</strong> —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </li>
<li><strong>复位 RST</strong>  —— 当 RST = 1 时，表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。</li>
<li><strong>同步 SYN</strong> —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。</li>
<li><strong>终止 FIN</strong> —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
<li><strong>窗口字段 —— 占 2 字节</strong>，用来让对方设置发送窗口的依据，单位为字节。 </li>
<li><strong>检验和 —— 占 2 字节</strong>，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li>
<li><strong>紧急指针字段 —— 占 16 位</strong>，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 </li>
<li><strong>选项字段 —— 长度可变</strong>，TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”  </li>
</ul>
<h4 id="TCP-可靠传输："><a href="#TCP-可靠传输：" class="headerlink" title="TCP 可靠传输："></a>TCP 可靠传输：</h4><p><strong>停止等待协议：</strong></p>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP可靠传输.png" width="100%" height="100%">

<p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信，这种可靠传输协议常称为<strong>自动重传请求ARQ(Automatic Repeat reQuest)</strong> 。</p>
<p><strong>TCP 滑动窗口：</strong></p>
<ul>
<li>停止等待协议的优点是简单，但缺点是信道利用率太低。</li>
</ul>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/停止等待协议缺点.png" width="100%" height="100%">

<ul>
<li>针对这一缺点，一般采用<strong>滑动窗口(流水线传输)</strong>和<strong>累积确认(接收窗口)</strong>的方法提高信道利用率。<br><strong>滑动窗口：</strong>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。<br>1.如下图所示，根据 B 给出的窗口值A构造出自己的发送窗口；<br>2.A 发送了 11 个字节的数据；<br>3.A 收到新的确认号后，发送窗口向前滑动；<br>4.若A 的发送窗口内的序号都已用完，但还没有再收到确认，必须停止发送；<br><strong>累积确认：</strong>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：<strong>到这个分组为止的所有分组都已正确收到了</strong>。</li>
</ul>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/流水线传输和滑动窗口.png" width="100%" height="100%">

<h4 id="TCP-流量控制："><a href="#TCP-流量控制：" class="headerlink" title="TCP 流量控制："></a>TCP 流量控制：</h4><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。<strong>流量控制(flow control)</strong>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现流量控制。 </p>
<p><strong>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</strong></p>
<h4 id="TCP-拥塞控制："><a href="#TCP-拥塞控制：" class="headerlink" title="TCP 拥塞控制："></a>TCP 拥塞控制：</h4><p><strong>拥塞控制：</strong>所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </p>
<p><strong>流量控制：</strong>往往指在给定的发送端和接收端之间的点对点通信量的控制。主要是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP拥塞控制.png" width="100%" height="100%">

<p><strong>几种拥塞控制方法：</strong>慢开始、拥塞避免、快重传、快恢复</p>
<p><strong>慢开始和拥塞避免算法：</strong></p>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/慢开始和拥塞避免算法.png" width="100%" height="100%">

<p>1.发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>2.注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>3.如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<p><strong>注意：</strong>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p><strong>快重传和快恢复：</strong></p>
<p><strong>快重传：</strong>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。<br>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/快重传.png" width="100%" height="100%">

<p><strong>快恢复：</strong>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/快恢复.png" width="100%" height="100%">

<p><strong>注意：</strong>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<h4 id="TCP-链接管理："><a href="#TCP-链接管理：" class="headerlink" title="TCP 链接管理："></a>TCP 链接管理：</h4><p>运输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p>
<p><strong>TCP建立连接的三次握手：</strong><br>TCP 连接的建立都是采用客户服务器方式：<br>• 主动发起连接建立的应用进程叫做客户(client)<br>• 被动等待连接建立的应用进程叫做服务器(server)</p>
<p>三次握手：</p>
<ol>
<li>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</li>
<li>B 的 TCP 收到连接请求报文段后，如同意，则发回确认. B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。</li>
<li>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。</li>
<li>A 的 TCP 通知上层应用进程，连接已经建立。</li>
</ol>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/三次握手.png" width="100%" height="100%">

<p><strong>注意：</strong>三次握手的原因：<strong>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</strong>如果不进行三次握手，那么服务器就会打开两个连接。导致连接失败，如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认。</p>
<p><strong>TCP连接释放的四次挥手：</strong></p>
<p>四次挥手：</p>
<ol>
<li>A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</li>
<li>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。</li>
<li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 </li>
<li>A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 </li>
<li>TCP 连接必须经过时间 2MSL(最大报文存活时间)后才真正释放掉。</li>
</ol>
<img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/四次挥手.png" width="100%" height="100%">

<p><strong>注意：</strong>客户端A的TIME-WAIT状态必须等待2MSL的原因：<br>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。<br>第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><strong>OSI七层参考模型:</strong><br>1.应用层：能够产生网络流量能够和用户交互的应用程序；<br>2.表示层：加密，压缩，开发人员；<br>3.会话层：服务和客户建立的会话：netstat -n；<br>4.传输层：可靠传输建立会话，不可靠传输，流量控制；<br>5.网络层：IP地址编址，选择最佳路径；<a id="more"></a><br>6.数据链路层：数据如何封装，添加物理层地址(MAC)；<br>7.物理层：电压，借口标准；</p>
<p><strong>网络排错：</strong>从底层到高层</p>
<p><strong>五层参考模型:</strong><br><strong>传输的过程：</strong><br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/001.png" width="100%" height="100%"></p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/002.png" width="100%" height="100%">

]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</li>
</ul>
<p><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/虚拟互联网络.png" width="100%" height="100%"><a id="more"></a> </p>
<h3 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h3><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/协议栈.png" width="80%" height="80%">

<h3 id="IP地址编址"><a href="#IP地址编址" class="headerlink" title="IP地址编址"></a>IP地址编址</h3><h4 id="点分十进制记法："><a href="#点分十进制记法：" class="headerlink" title="点分十进制记法："></a>点分十进制记法：</h4><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/点分十进制记法.png" width="100%" height="100%">

<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><ul>
<li><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。<br>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
</li>
<li><p>1-126：A类地址，127是本机地址；<br>128-191：B类地址；<br>192-223：C类地址；<br>224-240：D类地址；</p>
</li>
</ul>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/IP地址分类.png" width="100%" height="100%">

<ul>
<li><strong>特殊的几个地址：</strong><br>127.0.0.1   本地环回地址；<br>169.254.0.0   windows链接失败自动分配的地址；<br>10.0.0.0   保留的私网地址；<br>172.16.0.0   —   172.31.0.0   保留的私网地址；<br>192.168.0.0  —   192.168.255.0   保留的私网地址；</li>
</ul>
<h4 id="划分子网："><a href="#划分子网：" class="headerlink" title="划分子网："></a>划分子网：</h4><ul>
<li><p>通过在<strong>主机号字段中拿一部分作为子网号</strong>，把两级 IP 地址划分为三级 IP 地址。划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</p>
</li>
<li><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
</li>
<li><p>要使用子网，必须配置子网掩码。例如：一个 C 类地址的默认子网掩码为 255.255.255.0，如果 B 类地址的子网占两个比特，那么子网掩码为11111111 11111111 11111111 11000000，也就是 255.255.255.192。</p>
</li>
</ul>
<p><strong>注意：</strong>外部网络看不到子网的存在。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/子网划分.png" width="100%" height="100%">

<h4 id="构造超网-无分类CIDR-："><a href="#构造超网-无分类CIDR-：" class="headerlink" title="构造超网(无分类CIDR)："></a>构造超网(无分类CIDR)：</h4><ul>
<li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li>
<li>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。从三级编址（使用子网掩码）又回到了两级编址。</li>
<li>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}      </li>
<li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。路由聚合也称为构成超网(supernetting)。</li>
<li>CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。</li>
<li>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</li>
</ul>
<h4 id="计算机A到B的通信过程："><a href="#计算机A到B的通信过程：" class="headerlink" title="计算机A到B的通信过程："></a>计算机A到B的通信过程：</h4><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/数据通信过程.png" width="100%" height="100%">

<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/ARP.png" width="100%" height="100%">

<ul>
<li><p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 </p>
</li>
<li><p>每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p>
</li>
<li><p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 </p>
</li>
</ul>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/ARP请求过程.png" width="100%" height="100%">

<p><strong>注意：</strong>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p>
<h3 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h3><ul>
<li>一个 IP 数据包由首部和数据两部分组成。</li>
<li>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</li>
<li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li>
</ul>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/IP数据包.png" width="100%" height="100%">

<ul>
<li><strong>版本——占 4 位：</strong>指 IP 协议的版本：4（IPv4）和 6（IPv6）</li>
<li><strong>首部长度——占 4 位：</strong>可表示的最大数值，是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。</li>
<li><strong>区分服务——占 8 位：</strong>用来获得更好的服务，在一般的情况下都不使用这个字段 。</li>
<li><strong>总长度——占 16 位：</strong>指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li>
<li><strong>标识——占 16 位：</strong>它是一个计数器，用来产生数据报的标识。 </li>
<li><strong>标志——占 3 位：</strong>目前只有前两位有意义。</li>
<li><strong>生存时间——占 8 位：</strong>记为 TTL (Time To Live)，数据报在网络中可通过的路由器个数的最大值。</li>
<li><strong>协议——占 8 位：</strong>该字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程。</li>
<li><strong>首部检验和——占 16 位：</strong>因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量(简单计算)。</li>
<li><strong>源地址和目的地址——占 32 位：</strong>都各占 4 字节。</li>
<li><strong>片偏移——占 312位：</strong>较长的分组在分片后某片在原分组中的相对位置。片偏移以 <strong>8 个字节为偏移单位</strong>。</li>
</ul>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/IP数据报分片.png" width="100%" height="100%">

<p><strong>注意：</strong>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。 </p>
<h3 id="IP转发分组"><a href="#IP转发分组" class="headerlink" title="IP转发分组"></a>IP转发分组</h3><ul>
<li>路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。</li>
<li>网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。(有去有回)</li>
<li>这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。</li>
</ul>
<p><strong>注意：IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</strong> </p>
<h3 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h3><ul>
<li>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 不是高层协议，而是 IP 层的协议。</li>
<li>ICMP 报文的种类有两种，即 ICMP <strong>差错报告报文</strong>和 ICMP <strong>询问报文</strong>。</li>
<li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即<strong>类型</strong>、<strong>代码</strong>和<strong>检验和</strong>。接着的 4 个字节的内容与 ICMP 的类型有关。 </li>
</ul>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP报文格式.png" width="100%" height="100%">

<ul>
<li>几种常见的ICMP报文类型：</li>
</ul>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP报文类型.png" width="100%" height="100%">

<ul>
<li><strong>Ping：</strong>用来测试两个主机之间的连通性；是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP；</li>
<li><strong>Traceroute：</strong> 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径，发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文；</li>
</ul>
<h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>从路由算法的自适应性考虑可分为：静态路由选择策略和动态路由选择策略：</p>
<ul>
<li>静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 </li>
<li>动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。 </li>
</ul>
<p><strong>路由选择协议都是自适应的</strong>，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类：</p>
<ul>
<li><strong>自治系统内部的路由选择</strong>：RIP 和 OSPF；</li>
<li><strong>自治系统间的路由选择</strong>：BGP</li>
</ul>
<h4 id="内部网关协议-RIP："><a href="#内部网关协议-RIP：" class="headerlink" title="内部网关协议 RIP："></a>内部网关协议 RIP：</h4><ul>
<li><p>RIP是一种分布式的基于<strong>距离</strong>向量的路由选择协议，RIP 协议中的<strong>距离</strong>即为<strong>跳数</strong>，RIP允许一条路径最多只能包含 15 个路由器。跳数的最大值为16 时相当于不可达。可见RIP只适用于小型互联网。</p>
</li>
<li><p>RIP协议的三个要点：<br>1.仅和相邻路由器交换信息；<br>2.交换的信息是当前本路由器所知道的全部信息，即自己的路由表；<br>3.按固定的时间间隔(30秒)交换路由信息；</p>
</li>
<li><p>优缺点：<br><strong>优点：</strong>RIP 协议实现简单，开销小。<br><strong>缺点：</strong>但是 RIP 能使用的最大距离为 15，限制了网络的规模；并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器；同时仅基于跳数选择最佳路由也不够合理；</p>
</li>
</ul>
<h4 id="内部网关协议-OSPF-Open-Shortest-Path-First"><a href="#内部网关协议-OSPF-Open-Shortest-Path-First" class="headerlink" title="内部网关协议 OSPF(Open Shortest Path First)"></a>内部网关协议 OSPF(Open Shortest Path First)</h4><ul>
<li><p>基本特点：<br>1.“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的;<br>2.“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF;</p>
</li>
<li><p>三个要点 :<br>1.向本自治系统中所有路由器发送信息，使用的方法是洪泛法。<br>2.发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<br>3.只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p>
</li>
<li><p>OSPF 能够用于规模很大的网，的更新过程收敛得快;</p>
</li>
</ul>
<h4 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h4><p> BGP 是不同自治系统的路由器之间交换路由信息的协议。 </p>
<ul>
<li>因特网的规模太大，使得自治系统之间路由选择非常困难；</li>
<li>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由；</li>
</ul>
<p><strong>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</strong></p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/BGP协议.png" width="100%" height="100%">

<h3 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h3><p>专用网段：<br>10.0.0.0 到 10.255.255.255<br>172.16.0.0 到 172.31.255.255<br>192.168.0.0 到 192.168.255.255</p>
<p>这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/VPN.png" width="100%" height="100%">

<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP。</p>
<p>所有使用本地地址的主机在和外界通信时都要在 NAT 路由器上将其本地地址转换成 IP才能和因特网连。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，<strong>使得多个专用网内部的主机共用一个全球 IP 地址</strong>。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<h3 id="Internet组播管理协议-IGMP"><a href="#Internet组播管理协议-IGMP" class="headerlink" title="Internet组播管理协议 IGMP"></a>Internet组播管理协议 IGMP</h3><ul>
<li>当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。</li>
<li>因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络层</tag>
      </tags>
  </entry>
</search>
