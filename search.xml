<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM核心机制-类加载过程</title>
    <url>/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>类加载的作用：</strong>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口：<br><img src="/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/JVM01.png" width="80%" height="80%"></p>
<p><strong>类加载器的层次结构(树状结构):</strong></p>
<ul>
<li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader；<a id="more"></a></li>
<li>扩展类加载器（extensions class loader）：用来加载 Java 的扩展库，Java 虚拟机的实现会提供一个<strong>扩展库</strong>目录。该类加载器在此目录里面查找并加载 Java类，由ExtClassLoader实现；</li>
<li>应用程序类加载器（application class loader）：它根据 Java 应用的类路径来加载 Java 类，一般来说，Java 应用的类都是由它来完成加载的，由AppClassLoader实现；</li>
<li>自定义类加载器： 开发人员可以通过继承 java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。</li>
</ul>
<p>注意：<u>类加载器加载类的时候是线程安全的</u></p>
<img src="/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/JVM02.png" width="80%" height="80%">

<p><strong>双亲委托机制：</strong></p>
<ul>
<li>就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</li>
<li>双亲委托机制是为了保证 Java 核心库的类型安全，这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。</li>
<li>类加载器除了用于加载类，也是安全的最基本的屏障。</li>
<li>双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制：tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 反射</title>
    <url>/2020/05/11/Java-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>虽然Java不是动态语言<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。<br><strong>反射：</strong>指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象<strong>(一个类只有一个 Class 对象)</strong>，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。<br><strong>反射机制的作用：</strong>重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。<a id="more"></a><br><strong>获取Class对象：</strong><br>1.Class.forName();(常用)<br>2.getClass();<br>3..class;<br><strong>代码：</strong></p>
<ul>
<li>javaBean:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">//javabean一定要有无参构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获得User类的反射对象：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String path = <span class="string">"com.sxt.test.bean.User"</span>;</span><br><span class="line">Class clazz = Class.forName(path);<span class="comment">//方法一</span></span><br><span class="line"></span><br><span class="line">User u = <span class="keyword">new</span> User();</span><br><span class="line">Class clazz2 = u.getClass();<span class="comment">//方法二</span></span><br><span class="line"></span><br><span class="line">Class clazz3 = com.sxt.test.bean.User<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//方法三</span></span><br></pre></td></tr></table></figure></li>
<li>获得User类的属性：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field f = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure></li>
<li>获得User类的方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method m01 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果方法有参数，则必须传递参数类型对应的Class对象</span></span><br><span class="line">Method m02 = clazz.getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>获得User类指定的构造器：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>通过反射API动态的操作：构造器，方法，属性：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射API调用构造方法，构造对象</span></span><br><span class="line">User u1 = (User) clazz.getConstructor().newInstance();<span class="comment">//调用了User的无参构造器</span></span><br><span class="line">User u2 =  (User)clazz.getConstructor(int.class,int.class,String.class).newInstance(1001,18,"席博");//调用了User带参构造器</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射API调用普通方法 invoke(对象，参数)方法</span></span><br><span class="line">User u3 = (User) clazz.getConstructor().newInstance();</span><br><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">method.invoke(u3, <span class="string">"aaa"</span>);<span class="comment">//u3.setName("aaa");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射API操作属性</span></span><br><span class="line">User u4 = (User) clazz.getConstructor().newInstance();</span><br><span class="line">Field f = clazz.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//通过反射获得属性</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//这个属性不需要做安全检查，可以直接访问</span></span><br><span class="line">f.set(u4, <span class="string">"bbb"</span>); <span class="comment">//通过反射直接写u4属性</span></span><br><span class="line">f.get(u4);<span class="comment">//通过反射读取u4属性</span></span><br></pre></td></tr></table></figure></li>
<li>通过反射读取泛型的信息：ParameterizedType: 表示一种参数化的类型，比如Collection<string>；</string></li>
<li>通过反射读取注解的信息，模拟处理注解信息的流程，具体参见：<a href="https://chrisxb1996.github.io/2020/05/10/Java-注解/">Java 注解</a></li>
</ul>
<p><strong>反射的性能问题：</strong>使用反射性能会降低(约30倍)，setAccessible：启用和禁用访问安全检查的开关，设为 true 则表示反射的对象在使用时禁止 Java 语言访问检查。禁止安全检查，可以提高反射的运行速度(大约提高四倍)。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">动态语言：程序运行时，可以改变程序结构或变量类型。常见的动态语言：Python、ruby、javascript</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 动态编译</title>
    <url>/2020/05/12/Java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测<br>系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：<br><strong>通过JavaCompiler动态编译：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compileFile</span><span class="params">(String sourceFile)</span></span>&#123;</span><br><span class="line">  <span class="comment">//动态编译</span></span><br><span class="line">  JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">  <span class="keyword">int</span> result = compiler.run(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,sourceFile);</span><br><span class="line">  System.out.println(result==<span class="number">0</span>?<span class="string">"编译成功"</span>:<span class="string">"编译失败"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 第一个参数：为java编译器提供参数<br>• 第二个参数：得到 Java 编译器的输出信息<a id="more"></a><br>• 第三个参数：接收编译器的 错误信息<br>• 第四个参数：可变参数（是一个String数组）能传入一个或多个 Java 源文件<br>• 返回值：0表示编译成功，非0表示编译失败</p>
<p><strong>动态运行编译好的类：</strong></p>
<ul>
<li>通过Runtime.getRuntime()运行启动新的进程运行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime run = Runtime.getRuntime();</span><br><span class="line">Process process = run.exec(<span class="string">"java -cp path HelloWorld"</span>);</span><br></pre></td></tr></table></figure></li>
<li>通过反射运行编译好的类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射运行程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runJavaClassByReflect</span><span class="params">(String dir,String classFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:/"</span>+dir)&#125;;</span><br><span class="line">    URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">    Class c = loader.loadClass(classFile);</span><br><span class="line">    <span class="comment">//调用加载类的main方法</span></span><br><span class="line">    Method m = c.getMethod(<span class="string">"main"</span>,String[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">		m.invoke(null, (Object)new String[]&#123;&#125;);//反射调用main方法加(object)强制转型</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  	e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 注解</title>
    <url>/2020/05/10/Java-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>Annotation的作用：</strong><br>1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)<br>2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)<br><strong>Annotation的格式：</strong><br>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:<br>@SuppressWarnings(value=”unchecked”)。(抑制警告)<br><strong>Annotation在哪里使用：</strong><br>可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。<a id="more"></a><br><strong>自定义注解：</strong><br>格式：public @interface 注解名 {定义体}<br>1.方法的名称就是参数的名称;<br>2.返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）;<br>3.可以通过default来声明参数的默认值<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>;<br>4.如果只有一个参数成员，一般参数名为value;<br><strong>元注解：</strong><br>元注解的作用就是负责注解其他注解。 Java定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。<br>1.@Target：用于描述注解的使用范围（即:被描述的注解可以用在什么地方）<br>ElementType.TYPE；ElementType.FIELD…<br>2.@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期<br>SOURCE；CLASS；RUNTIME(可被反射机制读取)<br>3.@Documented<br>4.@Inherited<br><strong>通过反射读取注解的流程：</strong></p>
<ul>
<li>自定义类注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> test01Table &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义属性注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> test01Field &#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在test01中加入注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@test</span>01Table(<span class="string">"tb_member"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"id"</span>, type = <span class="string">"int"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"sname"</span>, type = <span class="string">"varchar"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"age"</span>, type = <span class="string">"int"</span>, length = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取test01中的注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射读取自定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.sgg.annotation.test01"</span>);</span><br><span class="line">            <span class="comment">//获得类的有效注解</span></span><br><span class="line">            Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span>(Annotation a : annotations)&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得类的制定注解</span></span><br><span class="line">            test01Table tt = (test01Table)clazz.getAnnotation(test01Table<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(tt.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得类的属性的对应注解</span></span><br><span class="line">            Field f = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">            test01Field tf = (test01Field)f.getAnnotation(test01Field<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(tf.columnName() +<span class="string">"--"</span>+ tf.type() +<span class="string">"--"</span>+ tf.length());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来可以利用注解信息写出DDL语句，完成相应的数据库操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>用hexo搭建个人博客</title>
    <url>/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><strong>准备工作</strong><br>安装git：<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a><br>安装nodejs：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br><strong>安装hexo</strong><br>1.以管理员身份运行：sudo su<br>2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。<a id="more"></a><br>3.在国内建议先安装淘宝镜像源 cnpm再进行安装hexo：<br>输入：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>; 安装完后查    看是否安装成功： cnpm -v：<br><img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/001.png" alt="001"><br>    利用cnpm安装hexo博客 ：cnpm install -g hexo-cli<br>    安装成功可查看hexo信息：hexo -v:<br>    <img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/002.png" width="33%" height="33%"><br>4.可以新建一个 文件夹作为存放目录：mkdir blog，进到目录中：cd blog/ (注意操作都在当前文件夹下进行操作)<br>5.至此，hexo已经为你生成了基础博客框架，启动hexo输入 :hexo s<br><img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/003.png" width="80%" height="80%"><br>6.在浏览器输入地址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 可以看到基本框架已经生成。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>核心作用：</strong>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。<br><strong>常见应用场景：</strong>Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…<br><strong>常见的五种单例模式实现方式：</strong><br>  1.饿汉式：线程安全，调用效率高。 但是，不能延时加载；<br>  2.懒汉式：线程安全，调用效率不高，可以延时加载；<br>  3.静态内部类式：线程安全，调用效率高，可以延时加载；<a id="more"></a><br>  4.枚举式：线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化创建对象的漏洞！<br>  5.<del>双重检测锁式</del>：JVM底层内部模型原因，偶尔会出问题。<strong>不建议使用；</strong></p>
<p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时，上来先创建对象（没有延时加载的优势），加载类时，天然线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo01 instance = <span class="keyword">new</span> SingletonDemo01();</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">SingletonDemo01</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//优点：方法没有同步调用效率高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时，不创建对象（延时加载，真正用的时候再创建）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo02 instance;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo02</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//需要加同步，保证单例模式，效率较低</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo02 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> SingletonDemo02();</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类方式：线程安全，调用效率高，实现延时加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo03 instance = <span class="keyword">new</span> SingletonDemo03();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo03</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//优点：方法没有同步调用效率高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  SingletonInnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类方式：线程安全，但没有延时加载；同时能够避免反射和反序列的漏洞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo04 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">//可以自己添加一些操作方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instanceOper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何选用合适的单例模式：</strong><br>单例对象占用资源少，不需要延时加载：枚举式 &gt; 饿汉式;<br>单例对象占用资源大，需要 延时加载：静态内部类式 &gt; 懒汉式;</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>核心：</strong>实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。<br><strong>三种类型的工厂模式：</strong><br><strong>1.简单工厂（使用较多）：</strong>又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；<br><strong>2.工厂方法：</strong>为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，<strong>但实际上，我们一般都用简单工厂模式</strong>；<a id="more"></a><br><strong>3.抽象工厂：</strong>用来生产不同产品族的全部产品：在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式；</p>
<p><strong>不使用工厂模式的情况：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Audi跑！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Byd</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Byd跑！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123; <span class="comment">//调用者</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Car c1 = <span class="keyword">new</span> Audi();</span><br><span class="line">    Car c2 = <span class="keyword">new</span> Byd();</span><br><span class="line">    c1.run();</span><br><span class="line">    c2.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单工厂：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createAudi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createByd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Byd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;<span class="comment">//调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = CarFactory.createAudi();</span><br><span class="line">        Car car2 = CarFactory.createByd();</span><br><span class="line">        car1.run();</span><br><span class="line">        car2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/simplefactory.png" width="32%" height="32%">

<p><strong>工厂方法：</strong><br>增加两个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BydFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Byd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;<span class="comment">//调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = <span class="keyword">new</span> AudiFactory().createCar();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> BydFactory().createCar();</span><br><span class="line">        car1.run();</span><br><span class="line">        car2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/factorymethod.png" width="48%" height="48%">

<p><strong>抽象工厂：</strong><br><img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abstractfactory.png" width="100%" height="100%"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#基本问题">基本问题</a><ul>
<li><a href="#基本概念">基本概念：</a></li>
<li><a href="#数据链路层的三个基本点">数据链路层的三个基本点：</a></li>
</ul>
</li>
<li><a href="#数据链路层的信道类型">数据链路层的信道类型</a><ul>
<li><a href="#点对点信道">点对点信道：</a></li>
<li><a href="#广播信道">广播信道：</a></li>
</ul>
</li>
<li><a href="#以太局域网">以太局域网</a><ul>
<li><a href="#概述">概述：</a></li>
<li><a href="#信道利用率">信道利用率：</a></li>
<li><a href="#mac层数据链路层的子层">MAC层(数据链路层的子层)：</a></li>
</ul>
</li>
<li><a href="#扩展以太网">扩展以太网</a><ul>
<li><a href="#网桥淘汰">网桥(淘汰)：</a></li>
<li><a href="#交换机">交换机：</a></li>
<li><a href="#虚拟局域网vlan">虚拟局域网(VLAN):</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<a id="more"></a> 
<h3><span id="基本问题">基本问题</span></h3><ul>
<li><h4><span id="基本概念">基本概念：</span></h4><p>1.主机H1向H2发送数据：<br>层次上来看：</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/图片 1.png" width="100%" height="100%">
仅从数据链路层观察帧的流动：
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/图片 2.png" width="100%" height="100%">

<p><strong>注意：</strong>可以看到路由器只到网络层(三层协议)，没有应用层，和传输层；</p>
<p>2.数据链路层传输的是帧：</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/数据链路层传送帧.png" width="100%" height="100%">
</li>
<li><h4><span id="数据链路层的三个基本点">数据链路层的三个基本点：</span></h4><p>1.封装成帧<br>2.透明传输<br>3.差错控制</p>
<p><strong>封装成帧：</strong>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/封装成帧.png" width="100%" height="100%">

<p><strong>透明传输：</strong>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/透明传输.png" width="100%" height="100%">

<p><strong>差错控制：</strong>在数据链路层传送的帧中，广泛使用了循环冗余检验 (CRC) 的检错技术：<strong>CRC是一种无比特差错，而不是无传输差错的检测机制</strong>。将得到的FCS(帧检验序列 )添加在原序列后面，在接收端检验：若得出的余数 <em>R</em> = 0，则判定这个帧没有差错，就接受(accept)；若余数 <em>R</em> != 0，则判定这个帧有差错，就丢弃，在高层进行重传指令。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/CRC.png" width="100%" height="100%">

</li>
</ul>
<h3><span id="数据链路层的信道类型">数据链路层的信道类型</span></h3><ul>
<li><h4><span id="点对点信道">点对点信道：</span></h4><p>使用一对一的点对点通信方式，不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议，支持身份验证，支持多个网络层协议。<br>PPP协议帧格式：<br>1.A、C：在点到点信道没有实际意义，固定为：FF、03；<br>2.协议字段(2字节)：用于标识信息部分是什么内容；<br>3.FCS(2字节)：表示CRC得到的帧检验序列；</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP协议.png" width="100%" height="100%">
</li>
<li><h4><span id="广播信道">广播信道：</span></h4><p>这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送<strong>(随机接入)</strong>：CSMA/CD(载波监听多点接入/碰撞检测) 协议：<br><strong>多点接入：</strong>表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听：</strong>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br><strong>碰撞检测</strong>：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于传播时延的存在，还是有可能会发生碰撞。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/随机接入碰撞.png" width="100%" height="100%">

<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，<strong>称 2τ 为 争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。以太网中经过计算，最短有效帧长为512bit，也就是64个字节，规定凡是长度小于64字节的帧都是无效帧。<br>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。<br><strong>注意：</strong>该协议只能(只能进行半双工通信)。</p>
</li>
</ul>
<h3><span id="以太局域网">以太局域网</span></h3><ul>
<li><h4><span id="概述">概述：</span></h4><p><strong>以太网是一种星型拓扑结构局域网。</strong>早期使用集线器(hub)进行连接，<strong>集线器是一种物理层设备</strong>， 作用于比特而不是帧。目前以太网使用交换机替代了集线器，<strong>交换机是一种链路层设备</strong>，它不会发生碰撞，能根据 MAC 地址进行存储转发。<br>以太网提供的服务是不可靠的交付，即尽最大努力的交付。当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p>
</li>
<li><h4><span id="信道利用率">信道利用率：</span></h4><p>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲时为止，是发送一帧所需的平均时间。 信道利用率可以表示为：T0/发送一帧所需的平均时间。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网信道利用率.png" width="100%" height="100%"> 
</li>
<li><h4><span id="mac层数据链路层的子层">MAC层(数据链路层的子层)：</span></h4><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。<br>以太网MAC帧格式：</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网帧格式.png" width="100%" height="100%"> 

</li>
</ul>
<h3><span id="扩展以太网">扩展以太网</span></h3><ul>
<li><h4><span id="网桥淘汰">网桥(淘汰)：</span></h4><p>在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/网桥扩展以太网.png" width="100%" height="100%"> 
</li>
<li><h4><span id="交换机">交换机：</span></h4><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。<br>1.端口独享带宽；<br>2.比集线器安全，可以设置固定MAC地址；<br>3.接口到计算机全双工；<br>4.全双工模式不再使用CSMA/CD协议；<br>5.接口可以工作在不同的速率；<br>6.广播帧会转发到全部端口；</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/交换机.png" width="100%" height="100%"> 
</li>
<li><h4><span id="虚拟局域网vlan">虚拟局域网(VLAN):</span></h4><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。例如：在研发部某台主机广播的消息只能住研发部收到，销售部和人力资源部则收不到消息。<br>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/VLAN.png" width="100%" height="100%"></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3><span id="osi七层参考模型">OSI七层参考模型:</span></h3><p>1.应用层：能够产生网络流量能够和用户交互的应用程序；<br>2.表示层：加密，压缩，开发人员；<br>3.会话层：服务和客户建立的会话：netstat -n；<br>4.传输层：可靠传输建立会话，不可靠传输，流量控制；<br>5.网络层：IP地址编址，选择最佳路径；<a id="more"></a><br>6.数据链路层：数据如何封装，添加物理层地址(MAC)；<br>7.物理层：电压，借口标准；</p>
<p><strong>网络排错：</strong>从底层到高层</p>
<h3><span id="五层参考模型">五层参考模型:</span></h3><p>传输的过程：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/001.png" width="100%" height="100%"></p>
<img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/002.png" width="100%" height="100%">

]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
