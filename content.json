{"meta":{"title":"xbsNotes","subtitle":"","description":"🍃","author":"xNotes","url":"https://chrisxb1996.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-12T08:35:33.000Z","updated":"2020-05-12T08:38:56.959Z","comments":false,"path":"about/index.html","permalink":"https://chrisxb1996.github.io/about/index.html","excerpt":"","text":"“ ”"},{"title":"","date":"2020-05-10T14:10:33.000Z","updated":"2020-05-11T04:38:23.316Z","comments":false,"path":"categories/index.html","permalink":"https://chrisxb1996.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-11T03:34:53.000Z","updated":"2020-06-16T12:29:21.101Z","comments":false,"path":"Coding/index.html","permalink":"https://chrisxb1996.github.io/Coding/index.html","excerpt":"","text":"Java基础Java 注解(Annotation)Java 反射(reflection)Java 动态编译JVM核心机制-类加载过程 设计模式设计模式-单例模式设计模式-工厂模式设计模式-策略模式设计模式-模版方法模式设计模式-观察者模式 LeetCode刷题剑指offer计算机网络计算机网络概述数据链路层网络层传输层应用层"},{"title":"","date":"2020-05-10T14:25:26.000Z","updated":"2020-05-11T04:42:00.966Z","comments":false,"path":"tags/index.html","permalink":"https://chrisxb1996.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-11T03:26:51.000Z","updated":"2020-05-12T08:27:56.305Z","comments":false,"path":"scientific/index.html","permalink":"https://chrisxb1996.github.io/scientific/index.html","excerpt":"","text":"天线阵列:论文笔记：Statistical Analysis of Array Gain for Cooperative MISO Transmitters without CSI"}],"posts":[{"title":"java-基础","slug":"Java/Java-基础","date":"2020-06-16T14:54:27.000Z","updated":"2020-06-17T12:08:45.575Z","comments":true,"path":"2020/06/16/Java/Java-基础/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/16/Java/Java-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java数据类型以及自动拆箱/装箱Java语言支持的数据类型包括两种： 基本数据类型： byte：1字节(8位) short(2)：2字节(16位) char(2)：2字节(16位) int(4)：4字节(32位) float(4)：4字节(32位) long(8)：8字节(64位) double(8)：8字节(64位) Boolean(1)：true、false，可以使用 1 位(bit) 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 java采用Unicode编码，不论汉字、字母、数字，每个字符都占用2字节。 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。反之就是自动拆箱。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程。 12Integer x = 2; // 装箱 调用了 Integer.valueOf(2)int y = x; // 拆箱 调用了 X.intValue() Java容器容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection 注：List是有序可重复元素集合，Set是无序不可重复元素集合； Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。 List ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 迭代器模式 Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。注意：iterator()方法是java.lang.Iterable接口的方法，被Collection继承。 (2) 使用hasNext()检查序列中是否还有元素。 (3) 使用next()获得序列中的下一个元素。 (4) 使用remove()将迭代器新返回的元素删除。 Iterator只能正向遍历集合，适用于获取移除元素。ListIterator继承自Iterator，专门针对List，可以从两个方向来遍历List，同时支持元素的修改(插入和删除)。从 JDK 1.5 之后可以使用 for each方法来遍历实现了 Iterable 接口的聚合对象。 源码分析ArrayList ArrayList 是基于数组实现的，所以支持快速随机访问。 数组的默认大小为 10。 1private static final int DEFAULT_CAPACITY = 10; 扩容： oldCapacity + (oldCapacity &gt;&gt; 1)，为旧容量的 1.5 倍，扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，操作代价很高。 删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。 Vector 同步：它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。 与ArrayList比较： （1）Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； （2）Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。 替代方案：可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); CopyOnWriteArrayList 读写分离：写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组。 优缺点： 优点：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能。 缺点： 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 适用场景：适合读多写少的应用场景，不适合内存敏感以及对实时性要求很高的场景。 LinkedList ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别： 数组支持随机访问，但插入删除的代价很高，需要移动大量元素； 链表不支持随机访问，但插入删除只需要改变指针。 HashMap 内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。 拉链法 1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"K1\", \"V1\");map.put(\"K2\", \"V2\");map.put(\"K3\", \"V3\"); （1）新建一个 HashMap，默认大小为 16 （2）插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 113，使用除留余数法得到所在的桶下标 113%16=1。 （3）插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 120，使用除留余数法得到所在的桶下标 120%16=8。 （4）插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 120，使用除留余数法得到所在的桶下标 120%16=8，插在 &lt;K2,V2&gt; 前面。（注意：头插法） 扩容 当需要扩容时，令 capacity 为原来的两倍。扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。 链表转红黑树 从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。 与HashTable比较 （1）Hashtable 使用 synchronized 来进行同步。 （2）HashMap 可以插入键为 null 的 Entry。(HashMap 使用第 0 个桶存放键为 null 的键值对) （3）HashMap 的迭代器是 fail-fast 迭代器。 （4）HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 ConcurrentHashMap ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。 size操作：ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。 JDK1.8后改动： JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。 JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。 参考资料Cyc2018 ：https://cyc2018.github.io/CS-Notes/#/README","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"}]},{"title":"剑指offer-中等篇","slug":"剑指offer/剑指offer-中等篇","date":"2020-06-10T13:03:53.000Z","updated":"2020-06-17T15:08:37.776Z","comments":true,"path":"2020/06/10/剑指offer/剑指offer-中等篇/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/10/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer-%E4%B8%AD%E7%AD%89%E7%AF%87/","excerpt":"剪绳子题目描述：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0] x k[1] x … x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 思路： 5&lt;2x3，6&lt;3x3，比6更大的数字我们就更不用考虑了，肯定要继续分。 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2x2x2 &lt; 3x3，那么题目就简单了。 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。","text":"剪绳子题目描述：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0] x k[1] x … x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 思路： 5&lt;2x3，6&lt;3x3，比6更大的数字我们就更不用考虑了，肯定要继续分。 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2x2x2 &lt; 3x3，那么题目就简单了。 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。 123456789101112131415public int cutRope(int target) &#123; if(target == 2) return 1; if(target == 3) return 2; int x = target % 3; int y = target / 3; if(x == 0)&#123; return (int)Math.pow(3,y); &#125;else if(x == 1)&#123;//7%3=2···1 2*2*3 return 2*2*(int)Math.pow(3,y-1); &#125;else&#123;//8%3=2···2 3*3*2 return 2*(int)Math.pow(3,y); &#125;&#125; 把二叉树打印成多行题目描述：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路：用队列实现二叉树的层次遍历(标准写法) 123456789101112131415161718ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; if(pRoot == null) return new ArrayList(); ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt; &gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); while(!queue.isEmpty())&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int count = queue.size(); for(int i = 0; i&lt;count; i++)&#123; TreeNode node = queue.poll(); list.add(node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); &#125; res.add(list); &#125; return res;&#125; 二叉树的下一个结点题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路：判断当前节点的右子节点是否为空 123456789101112131415161718public TreeLinkNode GetNext(TreeLinkNode pNode)&#123; if(pNode.right != null)&#123;//当前节点右子节点不为空 TreeLinkNode node = pNode.right; while(node.left != null)&#123;//找到右子节点的最底层左子节点 node = node.left; &#125; return node; &#125;else&#123;//当前节点右子节点为空 while(pNode.next != null)&#123; TreeLinkNode parent = pNode.next;//指向当前节点的父节点 if(parent.left == pNode)&#123;//判断当前节点是否为父节点的左子节点 return parent; &#125; pNode = pNode.next; &#125; &#125; return null;&#125; 链表中环的入口结点题目描述：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路： 12345678910111213141516public ListNode EntryNodeOfLoop(ListNode pHead)&#123; if(pHead == null || pHead.next == null) return null; ListNode fast = pHead; ListNode slow = pHead; do&#123; fast = fast.next.next; slow = slow.next; &#125;while(slow != fast); fast = pHead; while(fast != slow)&#123; fast = fast.next; slow = slow.next; &#125; return fast;&#125; 字符流中第一个不重复的字符题目描述：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 如果当前字符流没有存在出现一次的字符，返回 # 字符。 思路：用数组统计字符出现的次数，并将字符按顺序加入队列，如果队列中字符出现的次数大于1，则出队；如果最后队列不为空，则出队的字符就是第一个出现的字符。 123456789101112131415161718public class Solution &#123; //Insert one char from stringstream int[] counts = new int[256]; private Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;(); public void Insert(char ch)&#123; counts[ch]++; queue.add(ch); while(!queue.isEmpty() &amp;&amp; counts[queue.peek()] &gt; 1)&#123; queue.poll(); &#125; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce()&#123; return queue.isEmpty() ? '#' : queue.peek(); &#125;&#125; 数组中重复的数字题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路： 12345678910111213141516171819public boolean duplicate(int numbers[],int length,int [] duplication)&#123; if(numbers == null || numbers.length == 1) return false; for(int i = 0;i&lt;numbers.length;i++)&#123; while (numbers[i] != i) &#123; if (numbers[i] == numbers[numbers[i]]) &#123; duplication[0] = numbers[i]; return true; &#125; swap(numbers, i, numbers[i]); &#125; &#125; return false;&#125;public static void swap(int numbers[],int i,int j)&#123; int temp = numbers[i]; numbers[i] = numbers[j]; numbers[j] = temp;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"剑指offer-简单篇","slug":"剑指offer/剑指offer-简单篇","date":"2020-06-07T09:02:50.000Z","updated":"2020-06-12T11:18:20.366Z","comments":true,"path":"2020/06/07/剑指offer/剑指offer-简单篇/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/07/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer-%E7%AE%80%E5%8D%95%E7%AF%87/","excerpt":"构建乘积数组题目描述：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）","text":"构建乘积数组题目描述：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];） 思路：1.//从左向右累乘A[0]A[1]…A[i-1]；2.//从右向左累乘A[i+1]…A[n-1] 123456789101112131415161718public int[] multiply(int[] A) &#123; //从左向右累乘A[0]A[1]...A[i-1] int n = A.length; int[] B = new int[n]; int temp = 1; for(int i = 0;i&lt;n;i++)&#123; B[i] = temp; temp = temp*A[i]; &#125; //从右向左累乘A[i+1]...A[n-1] temp = 1; for(int i = n-1;i&gt;=0;i--)&#123; B[i] = B[i]*temp; temp = temp*A[i]; &#125; return B;&#125; 不用加减乘除做加法题目描述：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路：1.不考虑进位：异或操作：^ ；例如：101^111 = 010;​ 2.计算进位值：与操作：&amp;，再左移一位；例如：101&amp;111&lt;&lt;1 = 101&lt;&lt;1 = 1010；​ 3.重复上述两步，直到进位值全为0，返回结果； 123456789public int Add(int num1,int num2) &#123; while(num2 != 0) &#123; int temp = num1 ^ num2; int carry = (num1 &amp; num2) &lt;&lt; 1; num1 = temp; num2 = carry; &#125; return num1;&#125; 二叉树的深度题目描述：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路：递归：结束条件：根节点位空 1234567public int TreeDepth(TreeNode root) &#123; if(root == null) return 0; int left = TreeDepth(root.left); int right = TreeDepth(root.right); return Math.max(left,right)+1;&#125; 二叉树的镜像题目描述：操作给定的二叉树，将其变换为源二叉树的镜像。 思路：递归：结束条件：根节点位空 12345678public void Mirror(TreeNode root) &#123; if(root == null) return; if(root.left != null) Mirror(root.left); if(root.right != null) Mirror(root.right); TreeNode temp = root.left; root.left = root.right; root.right = temp; &#125; 变态跳台阶题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路：推导： 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去…，那么: 1f(n-1) &#x3D; f(n-2) + f(n-3) + ... + f(0) 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去… ，那么: 1f(n) &#x3D; f(n-1) + f(n-2) + ... + f(0) 两式相减得到： 1f(n) &#x3D; 2*f(n-1) &#x3D; 2*2*f(n-2) &#x3D;...&#x3D; 2^(n-1)*f(1) &#x3D; 2^(n-1) 1234567public int JumpFloorII(int target) &#123; if(target == 0)&#123; return -1; &#125;else&#123; return (int)Math.pow(2,target-1); &#125;&#125; 用两个栈实现队列题目描述：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路：注意：stack2中有元素时，不能入栈，直接pop出元素即可； 必须stack2为空时，才能入栈； 12345678910111213141516171819public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; int node = stack1.pop(); stack2.push(node); &#125; &#125; return stack2.pop(); &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"SpringBoot","slug":"SpringBoot","date":"2020-06-02T07:43:35.000Z","updated":"2020-06-02T08:11:21.766Z","comments":true,"path":"2020/06/02/SpringBoot/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/02/SpringBoot/","excerpt":"","text":"日志SLF4J + logback 如何让系统中所有的日志都统一到slf4j； 1、将系统中其他日志框架先排除出去； 2、用中间包来替换原有的日志框架； 3、我们导入slf4j其他的实现；","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://chrisxb1996.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chrisxb1996.github.io/tags/SpringBoot/"}]},{"title":"Leetcode 167.两数之和 II - 输入有序数组","slug":"Leetcode/Leetcode-167-两数之和-II-输入有序数组","date":"2020-05-27T14:52:47.000Z","updated":"2020-05-27T15:01:31.720Z","comments":true,"path":"2020/05/27/Leetcode/Leetcode-167-两数之和-II-输入有序数组/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/27/Leetcode/Leetcode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"167：给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 123456789101112131415161718192021class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; if(numbers.length &lt; 2) return null; int[] res = new int[2]; int i = 0; int j = numbers.length-1; while(i &lt; j)&#123; if(numbers[i] + numbers[j] == target)&#123; res[0] = i+1; res[1] = j+1; i++; j--; &#125;else if(numbers[i] + numbers[j] &lt; target)&#123; i++; &#125;else&#123; j--; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chrisxb1996.github.io/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chrisxb1996.github.io/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"设计模式-观察者模式","slug":"设计模式/设计模式-观察者模式","date":"2020-05-21T07:37:11.000Z","updated":"2020-05-21T16:00:22.230Z","comments":true,"path":"2020/05/21/设计模式/设计模式-观察者模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"适用于广播场景机制 ：• 聊天室程序的创建。服务器创建好后，A,B,C三个客户端连上来公开聊天。A向服务器发送数据，服务器端聊天数据改变。我们希望将这些聊天数据分别发给其他在线的客户。也就是说，每个客户端需要更新服务器端得数据。• 网站上，很多人订阅了”java主题”的新闻。当有这个主题新闻时，就会将这些新闻发给所有订阅的人。• 玩CS游戏时，服务器需要将每个人的方位变化发给所有的客户。","text":"适用于广播场景机制 ：• 聊天室程序的创建。服务器创建好后，A,B,C三个客户端连上来公开聊天。A向服务器发送数据，服务器端聊天数据改变。我们希望将这些聊天数据分别发给其他在线的客户。也就是说，每个客户端需要更新服务器端得数据。• 网站上，很多人订阅了”java主题”的新闻。当有这个主题新闻时，就会将这些新闻发给所有订阅的人。• 玩CS游戏时，服务器需要将每个人的方位变化发给所有的客户。 我们可以把多个订阅者、客户称之为观察者； 需要同步给多个订阅者的数据封装到对象中，称之为目标。 核心：观察者模式主要用于1：N的通知。当一个对象(目标对象Subject，消息发布)的状态变化时，他需要及时告知一系列对象(观察者对象Observer，消息订阅)，令他们做出响，通知观察者的方式主要是推和拉：• 推：每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接收。• 拉：观察者只要直到有情况即可。至于什么时候获取内容，获取什么内容，都可以自主决定。 代码实现： 1234567891011121314151617181920public interface Observer &#123; void update(Subject subject);&#125;public class ObserverA implements Observer&#123; private int myState; @Override public void update(Subject subject) &#123; myState = ((ConcreteSubject)subject).getState(); &#125; public void setMyState(int myState) &#123; this.myState = myState; &#125; public int getMyState() &#123; return myState; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class Subject &#123; protected List&lt;Observer&gt; list = new ArrayList&lt;&gt;(); public void registerObserver(Observer observer)&#123; list.add(observer); &#125; public void deletObserver(Observer observer)&#123; list.remove(observer); &#125; //通知 所有观察者更新状态 public void notifyAllObservers()&#123; for (Observer o : list) &#123; o.update(this); &#125; &#125;&#125;/***具体目标类*/public class ConcreteSubject extends Subject&#123; private int state; public void setState(int state) &#123; this.state = state; //目标值发生变换，通知所有的观察者 this.notifyAllObservers(); &#125; public int getState() &#123; return state; &#125;&#125; 123456789101112131415161718192021public class test &#123; public static void main(String[] args) &#123; ConcreteSubject concreteSubject = new ConcreteSubject(); //创建多个观察者 ObserverA o1 = new ObserverA(); ObserverA o2 = new ObserverA(); ObserverA o3 = new ObserverA(); //添加到subject的观察者队伍中 concreteSubject.registerObserver(o1); concreteSubject.registerObserver(o2); concreteSubject.registerObserver(o3); //一次更新，所有观察者都改变状态！！！ concreteSubject.setState(300); System.out.println(o1.getMyState()); System.out.println(o2.getMyState()); System.out.println(o3.getMyState()); &#125;&#125; • 开发中常见的场景： 聊天室程序的，服务器转发给所有客户端 网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发 邮件订阅 Servlet中，监听器的实现 Android中，广播机制 JDK的AWT中事件处理模型,基于观察者模式的委派事件模型(Delegation Event Model) 事件源—————-目标对象 事件监听器————观察者 京东商城中，群发某商品打折信息","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://chrisxb1996.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-模版方法模式","slug":"设计模式/设计模式-模版方法模式","date":"2020-05-20T14:22:50.000Z","updated":"2020-05-20T14:46:48.091Z","comments":true,"path":"2020/05/20/设计模式/设计模式-模版方法模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"模板方法模式也叫方法回调或钩子方法，是编程中经常用得到模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。 核心：处理步骤父类中定义好，具体实现延迟到子类中定义。","text":"模板方法模式也叫方法回调或钩子方法，是编程中经常用得到模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。 核心：处理步骤父类中定义好，具体实现延迟到子类中定义。 1234567891011121314151617181920public abstract class BankTemplateMethod &#123; //具体方法 public void takeNumber()&#123; System.out.println(\"取号排队\"); &#125; public abstract void transact(); //办理具体的业务 //钩子方法 public void evaluate()&#123; System.out.println(\"反馈评分\"); &#125; public final void process()&#123; this.takeNumber(); this.transact(); this.evaluate(); &#125;&#125; 1234567891011121314151617181920public class test &#123; public static void main(String[] args) &#123; //采用匿名内部类 BankTemplateMethod btm = new BankTemplateMethod()&#123; @Override public void transact() &#123; System.out.println(\"取钱：2000！！！\"); &#125; &#125;; btm.process(); BankTemplateMethod btm2 = new BankTemplateMethod()&#123; @Override public void transact() &#123; System.out.println(\"我要存钱：2000000！！！\"); &#125; &#125;; btm2.process(); &#125;&#125; • 什么时候用到模板方法模式：实现一个算法时，整体步骤很固定。但是，某些部分易变。易变部分可以抽象成出来，供子类实现。 • 开发中常见的场景：非常频繁。各个框架、类库中都有他的影子。比如常见的有：1.数据库访问的封装；2.Junit单元测试；3.servlet中关于doGet/doPost方法调用；4.Hibernate中模板程序；5.spring中JDBCTemplate、HibernateTemplate等；","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"模版方法模式","slug":"模版方法模式","permalink":"https://chrisxb1996.github.io/tags/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-策略模式","slug":"设计模式/设计模式-策略模式","date":"2020-05-20T06:56:40.000Z","updated":"2020-05-20T07:46:44.167Z","comments":true,"path":"2020/05/20/设计模式/设计模式-策略模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"某个市场人员接到单后的报价策略(CRM系统中常见问题)。报价策略很复杂，可以简单作如下分类：• 普通客户小批量报价• 普通客户大批量报价• 老客户小批量报价• 老客户大批量报价具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。","text":"某个市场人员接到单后的报价策略(CRM系统中常见问题)。报价策略很复杂，可以简单作如下分类：• 普通客户小批量报价• 普通客户大批量报价• 老客户小批量报价• 老客户大批量报价具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。 我们先可以采用条件语句处理： 12345678910111213141516public double getPrice(String type, double price)&#123; if(type.equals(\"普通客户小批量\"))&#123; System.out.println(\"不打折,原价\"); return price; &#125;else if(type.equals(\"普通客户大批量\"))&#123; System.out.println(\"打九折\"); return price*0.9; &#125;else if(type.equals(\"老客户小批量\"))&#123; System.out.println(\"打八五折\"); return price*0.85; &#125;else if(type.equals(\"老客户大批量\"))&#123; System.out.println(\"打八折\"); return price*0.8; &#125; return price; &#125; 但类型特别多，算法比较复杂时，整个条件控制代码会变得很长，难于维护。 策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//策略接口public interface Strategy &#123; double getPrice(double standardPrice);&#125;//新客户小批量public class NewCustomerFew implements Strategy&#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(\"不打折原价\"); return standardPrice; &#125;&#125;//新客户大批量public class NewCustomerLarge implements Strategy&#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(\"打九折！\"); return standardPrice*0.9; &#125;&#125;//老客户小批量public class OldCustomerFew implements Strategy&#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(\"打85折\"); return standardPrice*0.85; &#125;&#125;//老客户大批量public class OldCustomLarge implements Strategy&#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(\"打8折\"); return standardPrice*0.8; &#125;&#125;//上下文类//负责和具体的策略类交互，是的客户端和算法独立public class Context &#123; private Strategy strategy; //当前采用的算法对象 //通过构造器注入 public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; //通过set方法注入 public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public void printPrice(double s)&#123; System.out.println(\"价格：\"+strategy.getPrice(s)); &#125;&#125;//测试public class test &#123; public static void main(String[] args) &#123; Strategy s1 = new OldCustomerFew(); Strategy s2 = new OldCustomLarge(); Context ctx = new Context(s1); Context ctx2 = new Context(s2); int standardPrice = 1000; ctx.printPrice(standardPrice); ctx2.printPrice(standardPrice); &#125;&#125; • 本质：分离算法，选择实现。• 开发中常见的场景：JAVASE中GUI编程中，布局管理；Spring框架中，Resource接口，资源访问策略；javax.servlet.http.HttpServlet#service()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"https://chrisxb1996.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"应用层","slug":"计算机网络/应用层","date":"2020-05-18T09:33:32.000Z","updated":"2020-05-20T09:10:26.085Z","comments":true,"path":"2020/05/18/计算机网络/应用层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"概述• 每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。 • 应用层的许多协议都是基于客户服务器方式。客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。","text":"概述• 每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。 • 应用层的许多协议都是基于客户服务器方式。客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。 • 常用端口： 域名系统 DNSDNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名… 动态主机配置协议DHCPDHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址(DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址)等信息。 DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。 • DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。• DHCP 客户从 UDP 端口 68发送 DHCP发现报文(DHCPDISCOVER)。该报文被放入 UDP 中，广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。• 凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文(DHCPOFFER)，因此 DHCP 客户可能收到多个 DHCP 提供报文。• DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文(DHCPREQUEST)。• 被选择的 DHCP 服务器发送确认报文DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了。 文件传送协议 FTP文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议， FTP使用两个TCP连接：TCP控制链接、TCP数据连接： 控制连接：标准端口为21，在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。 数据连接：标准端口为20，实际用于传输文件。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务端从20端口主动向客户端发起连接。 被动模式：服务端在指定范围内的某个端口被动等待客户端发起连接 注意：主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙(需要在防火墙上开放20和21端口)。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 按远程终端协议 TELNETTELNET 是一个简单的远程终端协议，也是因特网的正式标准。 • TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。• TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议(SMTP, POP3, IMAP) 发送邮件的协议：SMTP使用TCP 25端口。 读取邮件的协议：POP3 使用110端口和 IMAP使用的端口是143。 • SMTP：SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 • POP3：POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。 • IMAP：IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 超文本传送协议 HTTP在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。 HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 URL使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。URL有如下一般形式： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; • &lt;协议&gt; ftp、http、News…• &lt;主机&gt; 是存放资源的主机在因特网中的域名;• &lt;端口&gt;/&lt;路径&gt; 有时可省略； 请求web服务的过程： HTTP的报文结构：HTTP 有两类报文： • 请求报文——从客户向服务器发送请求报文。• 响应报文——从服务器到客户的回答。• 由于 HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。 报文由三个部分组成，即开始行、首部行和实体主体。在请求报文中，开始行就是请求行。包含了方法字段。 响应报文的开始行是状态行。状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。 • 1xx ：Informational（信息性状态码），表示通知信息的，如请求收到了或正在进行处理。 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 • 2xx ：Success（成功状态码），表示成功，如接受或知道了。 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 • 3xx ：Redirection（重定向状态码），表示重定向，表示要完成请求还必须采取进一步的行动。 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 • 4xx ：Client Error（客户端错误状态码），表示客户的差错，如请求中有错误的语法或不能完成。 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found • 5xx ：Server Error（服务器错误状态码），表示服务器的差错，如服务器失效无法完成请求。 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 Cookie","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"应用层","slug":"应用层","permalink":"https://chrisxb1996.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"传输层","slug":"计算机网络/传输层","date":"2020-05-17T08:06:11.000Z","updated":"2020-05-18T09:30:30.678Z","comments":true,"path":"2020/05/17/计算机网络/传输层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"概述进程之间的通信: 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。","text":"概述进程之间的通信: 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 TCP和UDP:运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。 用户数据报协议 UDP (User Datagram Protocol)：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP (Transmission Control Protocol)：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 传输层的端口:运行在计算机中的进程是用进程标识符来标志的，为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。解决这个问题的方法就是在运输层使用协议端口号(protocol port number)，或通常简称为端口(port)。 端口用一个 16 位端口号进行标志。 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。 三类端口 ：1.熟知端口，数值一般为 0-1023；2.登记端口号，数值为1024-49151，为没有熟知端口号的应用程序使用的；3.客户端口号，数值为49152-65535，留给客户进程选择暂时使用； 常用应用层协议与传输层端口：http = TCP + 80；https = TCP + 443；ftp = TCP + 21；SMTP = TCP + 25；POP3 = TCP + 101；RDP = TCP + 3389；SQL = TCP + 1433；DNS = UDP + 53 or TCP + 53(极少情况) 计算机服务(对外的服务)运行后在TCP或UDP的某个端口侦听客户端请求。 UDPUDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。 UDP 是无连接的，即发送数据之前不需要建立连接(主要针对短包，实时性要求不高的数据)。 UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。 UDP 支持一对一、一对多、多对一和多对多的交互通信。 UDP 的首部开销小，只有 8 个字节。 面向报文：送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。应用程序必须选择合适大小的报文。 UDP首部格式：首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCPTCP 概述：主要特点:1.TCP是面向连接的运输层协议；2.每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的(一对一)；3.TCP 提供可靠交付的服务；4.TCP 提供全双工通信；5.面向字节流； 面向字节流的传输过程： 注意：1.TCP 连接是一条虚连接而不是一条真正的物理连接。2.TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字(socket)，端口号拼接到 IP 地址即构成了套接字。套接字 socket = (IP地址: 端口号)；3.每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}； TCP 报文首部格式： 源端口和目的端口字段——各占 2 字节，端口传输层与应用层的服务接口。传输层的复用和分用功能都要通过端口才能实现。 序号字段——占 4 字节，TCP 连接中传送的字节流中的每一个数据段都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 数据偏移(即首部长度)——占 4 位，它表示首部长度，最长60个字节，故可变长度最长40个字节。 保留字段——占 6 位，保留为今后使用，但目前应置为 0。 紧急 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。 确认 ACK —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 推送 PSH —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 复位 RST —— 当 RST = 1 时，表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。 同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。 终止 FIN —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。 检验和 —— 占 2 字节，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 选项字段 —— 长度可变，TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” TCP 可靠传输：停止等待协议： 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信，这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest) 。 TCP 滑动窗口： 停止等待协议的优点是简单，但缺点是信道利用率太低。 针对这一缺点，一般采用滑动窗口(流水线传输)和累积确认(接收窗口)的方法提高信道利用率。滑动窗口：发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。1.如下图所示，根据 B 给出的窗口值A构造出自己的发送窗口；2.A 发送了 11 个字节的数据；3.A 收到新的确认号后，发送窗口向前滑动；4.若A 的发送窗口内的序号都已用完，但还没有再收到确认，必须停止发送；累积确认：接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。 TCP 流量控制：一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制：拥塞控制：所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 流量控制：往往指在给定的发送端和接收端之间的点对点通信量的控制。主要是抑制发送端发送数据的速率，以便使接收端来得及接收。 几种拥塞控制方法：慢开始、拥塞避免、快重传、快恢复 慢开始和拥塞避免算法： 1.发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 2.注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 3.如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 注意：发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 快重传和快恢复： 快重传：在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 快恢复：在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 注意：慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 TCP 链接管理：运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。 TCP建立连接的三次握手：TCP 连接的建立都是采用客户服务器方式：• 主动发起连接建立的应用进程叫做客户(client)• 被动等待连接建立的应用进程叫做服务器(server) 三次握手： A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。 B 的 TCP 收到连接请求报文段后，如同意，则发回确认. B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。 A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。 A 的 TCP 通知上层应用进程，连接已经建立。 注意：三次握手的原因：第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果不进行三次握手，那么服务器就会打开两个连接。导致连接失败，如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认。 TCP连接释放的四次挥手： 四次挥手： A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。 B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 TCP 连接必须经过时间 2MSL(最大报文存活时间)后才真正释放掉。 注意：客户端A的TIME-WAIT状态必须等待2MSL的原因：第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"传输层","slug":"传输层","permalink":"https://chrisxb1996.github.io/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"}]},{"title":"网络层","slug":"计算机网络/网络层","date":"2020-05-15T13:55:05.000Z","updated":"2020-05-18T04:47:39.741Z","comments":true,"path":"2020/05/15/计算机网络/网络层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"概述 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。","text":"概述 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 TCP/IP协议栈 IP地址编址点分十进制记法： 分类： 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 1-126：A类地址，127是本机地址；128-191：B类地址；192-223：C类地址；224-240：D类地址； 特殊的几个地址：127.0.0.1 本地环回地址；169.254.0.0 windows链接失败自动分配的地址；10.0.0.0 保留的私网地址；172.16.0.0 — 172.31.0.0 保留的私网地址；192.168.0.0 — 192.168.255.0 保留的私网地址； 划分子网： 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。例如：一个 C 类地址的默认子网掩码为 255.255.255.0，如果 B 类地址的子网占两个比特，那么子网掩码为11111111 11111111 11111111 11000000，也就是 255.255.255.192。 注意：外部网络看不到子网的存在。 构造超网(无分类CIDR)： CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。 CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。从三级编址（使用子网掩码）又回到了两级编址。 IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;} 一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。路由聚合也称为构成超网(supernetting)。 CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 计算机A到B的通信过程： ARP协议 不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 注意：ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 IP数据包 一个 IP 数据包由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本——占 4 位：指 IP 协议的版本：4（IPv4）和 6（IPv6） 首部长度——占 4 位：可表示的最大数值，是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。 区分服务——占 8 位：用来获得更好的服务，在一般的情况下都不使用这个字段 。 总长度——占 16 位：指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。 标识——占 16 位：它是一个计数器，用来产生数据报的标识。 标志——占 3 位：目前只有前两位有意义。 生存时间——占 8 位：记为 TTL (Time To Live)，数据报在网络中可通过的路由器个数的最大值。 协议——占 8 位：该字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程。 首部检验和——占 16 位：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量(简单计算)。 源地址和目的地址——占 32 位：都各占 4 字节。 片偏移——占 312位：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。 注意：IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。 IP转发分组 路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。 网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。(有去有回) 这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。 注意：IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。 网际控制报文协议 ICMP ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 不是高层协议，而是 IP 层的协议。 ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 几种常见的ICMP报文类型： Ping：用来测试两个主机之间的连通性；是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP； Traceroute： 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径，发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文； 路由选择协议基本概念：从路由算法的自适应性考虑可分为：静态路由选择策略和动态路由选择策略： 静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。 路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF； 自治系统间的路由选择：BGP 内部网关协议 RIP： RIP是一种分布式的基于距离向量的路由选择协议，RIP 协议中的距离即为跳数，RIP允许一条路径最多只能包含 15 个路由器。跳数的最大值为16 时相当于不可达。可见RIP只适用于小型互联网。 RIP协议的三个要点：1.仅和相邻路由器交换信息；2.交换的信息是当前本路由器所知道的全部信息，即自己的路由表；3.按固定的时间间隔(30秒)交换路由信息； 优缺点：优点：RIP 协议实现简单，开销小。缺点：但是 RIP 能使用的最大距离为 15，限制了网络的规模；并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器；同时仅基于跳数选择最佳路由也不够合理； 内部网关协议 OSPF(Open Shortest Path First) 基本特点：1.“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的;2.“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF; 三个要点 :1.向本自治系统中所有路由器发送信息，使用的方法是洪泛法。2.发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。3.只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 OSPF 能够用于规模很大的网，的更新过程收敛得快; 外部网关协议 BGP BGP 是不同自治系统的路由器之间交换路由信息的协议。 因特网的规模太大，使得自治系统之间路由选择非常困难； 边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由； 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 虚拟专用网VPN专用网段：10.0.0.0 到 10.255.255.255172.16.0.0 到 172.31.255.255192.168.0.0 到 192.168.255.255 这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换NAT需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP。 所有使用本地地址的主机在和外界通信时都要在 NAT 路由器上将其本地地址转换成 IP才能和因特网连。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 Internet组播管理协议 IGMP 当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。 因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络层","slug":"网络层","permalink":"https://chrisxb1996.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"}]},{"title":"数据链路层","slug":"计算机网络/数据链路层","date":"2020-05-15T07:05:33.000Z","updated":"2020-05-18T04:47:50.792Z","comments":true,"path":"2020/05/15/计算机网络/数据链路层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"基本问题基本概念：1.主机H1向H2发送数据：层次上来看：仅从数据链路层观察帧的流动： 注意：可以看到路由器只到网络层(三层协议)，没有应用层，和传输层；","text":"基本问题基本概念：1.主机H1向H2发送数据：层次上来看：仅从数据链路层观察帧的流动： 注意：可以看到路由器只到网络层(三层协议)，没有应用层，和传输层； 2.数据链路层传输的是帧： 数据链路层的三个基本点：1.封装成帧2.透明传输3.差错控制 封装成帧：封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。 透明传输：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 差错控制：在数据链路层传送的帧中，广泛使用了循环冗余检验 (CRC) 的检错技术：CRC是一种无比特差错，而不是无传输差错的检测机制。将得到的FCS(帧检验序列 )添加在原序列后面，在接收端检验：若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)；若余数 R != 0，则判定这个帧有差错，就丢弃，在高层进行重传指令。 数据链路层的信道类型点对点信道：使用一对一的点对点通信方式，不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议，支持身份验证，支持多个网络层协议。PPP协议帧格式：1.A、C：在点到点信道没有实际意义，固定为：FF、03；2.协议字段(2字节)：用于标识信息部分是什么内容；3.FCS(2字节)：表示CRC得到的帧检验序列； 广播信道：这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送(随机接入)：CSMA/CD(载波监听多点接入/碰撞检测) 协议：多点接入：表示许多计算机以多点接入的方式连接在一根总线上。载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。以太网中经过计算，最短有效帧长为512bit，也就是64个字节，规定凡是长度小于64字节的帧都是无效帧。当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。注意：该协议只能(只能进行半双工通信)。 以太局域网概述：以太网是一种星型拓扑结构局域网。早期使用集线器(hub)进行连接，集线器是一种物理层设备， 作用于比特而不是帧。目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。以太网提供的服务是不可靠的交付，即尽最大努力的交付。当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 信道利用率：一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲时为止，是发送一帧所需的平均时间。 信道利用率可以表示为：T0/发送一帧所需的平均时间。 MAC层(数据链路层的子层)：在局域网中，硬件地址又称为物理地址，或 MAC 地址。MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。以太网MAC帧格式： 扩展以太网网桥(淘汰)：在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。 交换机：交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。1.端口独享带宽；2.比集线器安全，可以设置固定MAC地址；3.接口到计算机全双工；4.全双工模式不再使用CSMA/CD协议；5.接口可以工作在不同的速率；6.广播帧会转发到全部端口； 虚拟局域网(VLAN):虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。例如：在研发部某台主机广播的消息只能住研发部收到，销售部和人力资源部则收不到消息。使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据链路层","slug":"数据链路层","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"}]},{"title":"计算机网络概述","slug":"计算机网络/计算机网络概述","date":"2020-05-15T06:26:57.000Z","updated":"2020-05-16T09:21:03.551Z","comments":true,"path":"2020/05/15/计算机网络/计算机网络概述/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","excerpt":"OSI七层参考模型:1.应用层：能够产生网络流量能够和用户交互的应用程序；2.表示层：加密，压缩，开发人员；3.会话层：服务和客户建立的会话：netstat -n；4.传输层：可靠传输建立会话，不可靠传输，流量控制；5.网络层：IP地址编址，选择最佳路径；","text":"OSI七层参考模型:1.应用层：能够产生网络流量能够和用户交互的应用程序；2.表示层：加密，压缩，开发人员；3.会话层：服务和客户建立的会话：netstat -n；4.传输层：可靠传输建立会话，不可靠传输，流量控制；5.网络层：IP地址编址，选择最佳路径；6.数据链路层：数据如何封装，添加物理层地址(MAC)；7.物理层：电压，借口标准； 网络排错：从底层到高层 五层参考模型:传输的过程：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"设计模式-工厂模式","slug":"设计模式/设计模式-工厂模式","date":"2020-05-14T07:56:13.000Z","updated":"2020-05-15T06:47:57.322Z","comments":true,"path":"2020/05/14/设计模式/设计模式-工厂模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"核心：实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。三种类型的工厂模式：1.简单工厂（使用较多）：又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；2.工厂方法：为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，但实际上，我们一般都用简单工厂模式；","text":"核心：实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。三种类型的工厂模式：1.简单工厂（使用较多）：又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；2.工厂方法：为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，但实际上，我们一般都用简单工厂模式；3.抽象工厂：用来生产不同产品族的全部产品：在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式； 不使用工厂模式的情况： 123456public class Audi implements Car&#123; @Override public void run() &#123; System.out.println(\"Audi跑！！！\"); &#125;&#125; 123456public class Byd implements Car&#123; @Override public void run() &#123; System.out.println(\"Byd跑！！！\"); &#125;&#125; 12345678public class test01 &#123; //调用者 public static void main(String[] args) &#123; Car c1 = new Audi(); Car c2 = new Byd(); c1.run(); c2.run(); &#125;&#125; 简单工厂： 12345678public class CarFactory &#123; public static Car createAudi()&#123; return new Audi(); &#125; public static Car createByd()&#123; return new Byd(); &#125;&#125; 12345678public class test01 &#123;//调用者 public static void main(String[] args) &#123; Car car1 = CarFactory.createAudi(); Car car2 = CarFactory.createByd(); car1.run(); car2.run(); &#125;&#125; 工厂方法：增加两个实现类： 1234567891011121314151617public interface CarFactory &#123; Car createCar();&#125;public class AudiFactory implements CarFactory&#123; @Override public Car createCar() &#123; return new Audi(); &#125;&#125;public class BydFactory implements CarFactory&#123; @Override public Car createCar() &#123; return new Byd(); &#125;&#125; 12345678public class test01 &#123;//调用者 public static void main(String[] args) &#123; Car car1 = new AudiFactory().createCar(); Car car2 = new BydFactory().createCar(); car1.run(); car2.run(); &#125;&#125; 抽象工厂：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-单例模式","slug":"设计模式/设计模式-单例模式","date":"2020-05-13T09:12:28.000Z","updated":"2020-05-14T13:07:29.495Z","comments":true,"path":"2020/05/13/设计模式/设计模式-单例模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。常见应用场景：Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…常见的五种单例模式实现方式： 1.饿汉式：线程安全，调用效率高。 但是，不能延时加载； 2.懒汉式：线程安全，调用效率不高，可以延时加载； 3.静态内部类式：线程安全，调用效率高，可以延时加载；","text":"核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。常见应用场景：Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…常见的五种单例模式实现方式： 1.饿汉式：线程安全，调用效率高。 但是，不能延时加载； 2.懒汉式：线程安全，调用效率不高，可以延时加载； 3.静态内部类式：线程安全，调用效率高，可以延时加载； 4.枚举式：线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化创建对象的漏洞！ 5.双重检测锁式：JVM底层内部模型原因，偶尔会出问题。不建议使用； 饿汉式： 1234567891011//饿汉式：public class SingletonDemo01 &#123; //类初始化时，上来先创建对象（没有延时加载的优势），加载类时，天然线程安全 private static SingletonDemo01 instance = new SingletonDemo01(); //构造器私有 private SingletonDemo01()&#123;&#125; //优点：方法没有同步调用效率高 public static SingletonDemo01 getInstance()&#123; return instance; &#125;&#125; 懒汉式： 123456789101112//懒汉式：public class SingletonDemo02 &#123; //类初始化时，不创建对象（延时加载，真正用的时候再创建） private static SingletonDemo02 instance; //构造器私有 private SingletonDemo02()&#123;&#125; //需要加同步，保证单例模式，效率较低 public static synchronized SingletonDemo02 getInstance()&#123; if(instance == null) instance = new SingletonDemo02(); return instance; &#125;&#125; 静态内部类式: 123456789101112//静态内部类方式：线程安全，调用效率高，实现延时加载public class SingletonDemo03 &#123; private static class SingletonInnerClass&#123; private static final SingletonDemo03 instance = new SingletonDemo03(); &#125; //构造器私有 private SingletonDemo03()&#123;&#125; //优点：方法没有同步调用效率高 public static SingletonDemo03 getInstance()&#123; return SingletonInnerClass.instance; &#125;&#125; 枚举式: 1234567//枚举类方式：线程安全，但没有延时加载；同时能够避免反射和反序列的漏洞public enum SingletonDemo04 &#123; INSTANCE; //可以自己添加一些操作方法 public static void instanceOper()&#123; &#125;&#125; 如何选用合适的单例模式：单例对象占用资源少，不需要延时加载：枚举式 &gt; 饿汉式;单例对象占用资源大，需要 延时加载：静态内部类式 &gt; 懒汉式;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"JVM核心机制-类加载过程","slug":"Java/JVM核心机制-类加载过程","date":"2020-05-13T06:38:30.000Z","updated":"2020-05-18T04:49:14.599Z","comments":true,"path":"2020/05/13/Java/JVM核心机制-类加载过程/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/13/Java/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口： 类加载器的层次结构(树状结构): 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader；","text":"类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口： 类加载器的层次结构(树状结构): 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader； 扩展类加载器（extensions class loader）：用来加载 Java 的扩展库，Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类，由ExtClassLoader实现； 应用程序类加载器（application class loader）：它根据 Java 应用的类路径来加载 Java 类，一般来说，Java 应用的类都是由它来完成加载的，由AppClassLoader实现； 自定义类加载器： 开发人员可以通过继承 java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。 注意：类加载器加载类的时候是线程安全的 双亲委托机制： 就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 双亲委托机制是为了保证 Java 核心库的类型安全，这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。 类加载器除了用于加载类，也是安全的最基本的屏障。 双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制：tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://chrisxb1996.github.io/tags/JVM/"}]},{"title":"Java 动态编译","slug":"Java/Java-动态编译","date":"2020-05-12T07:20:23.000Z","updated":"2020-05-14T03:19:01.203Z","comments":true,"path":"2020/05/12/Java/Java-动态编译/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/12/Java/Java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/","excerpt":"Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：通过JavaCompiler动态编译： 1234567public static int compileFile(String sourceFile)&#123; //动态编译 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null,sourceFile); System.out.println(result==0?\"编译成功\":\"编译失败\"); return result;&#125; • 第一个参数：为java编译器提供参数• 第二个参数：得到 Java 编译器的输出信息","text":"Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：通过JavaCompiler动态编译： 1234567public static int compileFile(String sourceFile)&#123; //动态编译 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null,sourceFile); System.out.println(result==0?\"编译成功\":\"编译失败\"); return result;&#125; • 第一个参数：为java编译器提供参数• 第二个参数：得到 Java 编译器的输出信息• 第三个参数：接收编译器的 错误信息• 第四个参数：可变参数（是一个String数组）能传入一个或多个 Java 源文件• 返回值：0表示编译成功，非0表示编译失败 动态运行编译好的类： 通过Runtime.getRuntime()运行启动新的进程运行12Runtime run = Runtime.getRuntime();Process process = run.exec(\"java -cp path HelloWorld\"); 通过反射运行编译好的类12345678910111213//通过反射运行程序public static void runJavaClassByReflect(String dir,String classFile) throws Exception&#123; try &#123; URL[] urls = new URL[] &#123;new URL(\"file:/\"+dir)&#125;; URLClassLoader loader = new URLClassLoader(urls); Class c = loader.loadClass(classFile); //调用加载类的main方法 Method m = c.getMethod(\"main\",String[].class) m.invoke(null, (Object)new String[]&#123;&#125;);//反射调用main方法加(object)强制转型 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"}]},{"title":"Java 反射","slug":"Java/Java-反射","date":"2020-05-11T13:35:34.000Z","updated":"2020-05-13T06:36:53.159Z","comments":true,"path":"2020/05/11/Java/Java-反射/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/11/Java/Java-%E5%8F%8D%E5%B0%84/","excerpt":"虽然Java不是动态语言1，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。反射：指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。反射机制的作用：重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。","text":"虽然Java不是动态语言1，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。反射：指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。反射机制的作用：重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。获取Class对象：1.Class.forName();(常用)2.getClass();3..class;代码： javaBean:1234567891011121314151617181920212223242526272829303132public class User &#123; private int id; private int age; private String name; //javabean一定要有无参构造器 public User() &#123; &#125; public User(int id, int age, String name) &#123; super(); this.id = id; this.age = age; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 获得User类的反射对象：1234567String path = \"com.sxt.test.bean.User\";Class clazz = Class.forName(path);//方法一User u = new User();Class clazz2 = u.getClass();//方法二Class clazz3 = com.sxt.test.bean.User.class;//方法三 获得User类的属性：1Field f = clazz.getDeclaredField(\"name\"); 获得User类的方法：123Method m01 = clazz.getDeclaredMethod(\"getName\", null);//如果方法有参数，则必须传递参数类型对应的Class对象Method m02 = clazz.getDeclaredMethod(\"setName\", String.class); 获得User类指定的构造器：1Constructor constructor = clazz.getDeclaredConstructor(int.class,int.class,String.class); 通过反射API动态的操作：构造器，方法，属性：123456789101112131415//通过反射API调用构造方法，构造对象User u1 = (User) clazz.getConstructor().newInstance();//调用了User的无参构造器User u2 = (User)clazz.getConstructor(int.class,int.class,String.class).newInstance(1001,18,\"席博\");//调用了User带参构造器//通过反射API调用普通方法 invoke(对象，参数)方法User u3 = (User) clazz.getConstructor().newInstance();Method method = clazz.getDeclaredMethod(\"setName\", String.class);method.invoke(u3, \"aaa\");//u3.setName(\"aaa\");//通过反射API操作属性User u4 = (User) clazz.getConstructor().newInstance();Field f = clazz.getDeclaredField(\"name\");//通过反射获得属性f.setAccessible(true); //这个属性不需要做安全检查，可以直接访问f.set(u4, \"bbb\"); //通过反射直接写u4属性f.get(u4);//通过反射读取u4属性 通过反射读取泛型的信息：ParameterizedType: 表示一种参数化的类型，比如Collection； 通过反射读取注解的信息，模拟处理注解信息的流程，具体参见：Java 注解 反射的性能问题：使用反射性能会降低(约30倍)，setAccessible：启用和禁用访问安全检查的开关，设为 true 则表示反射的对象在使用时禁止 Java 语言访问检查。禁止安全检查，可以提高反射的运行速度(大约提高四倍)。 1.动态语言：程序运行时，可以改变程序结构或变量类型。常见的动态语言：Python、ruby、javascript ↩","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"reflection","slug":"reflection","permalink":"https://chrisxb1996.github.io/tags/reflection/"},{"name":"反射","slug":"反射","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java 注解","slug":"Java/Java-注解","date":"2020-05-10T03:56:57.000Z","updated":"2020-05-14T03:16:59.928Z","comments":true,"path":"2020/05/10/Java/Java-注解/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/10/Java/Java-%E6%B3%A8%E8%A7%A3/","excerpt":"Annotation的作用：1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)Annotation的格式：注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value=”unchecked”)。(抑制警告)Annotation在哪里使用：可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。","text":"Annotation的作用：1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)Annotation的格式：注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value=”unchecked”)。(抑制警告)Annotation在哪里使用：可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。自定义注解：格式：public @interface 注解名 {定义体}1.方法的名称就是参数的名称;2.返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）;3.可以通过default来声明参数的默认值1;4.如果只有一个参数成员，一般参数名为value;元注解：元注解的作用就是负责注解其他注解。 Java定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。1.@Target：用于描述注解的使用范围（即:被描述的注解可以用在什么地方）ElementType.TYPE；ElementType.FIELD…2.@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期SOURCE；CLASS；RUNTIME(可被反射机制读取)3.@Documented4.@Inherited通过反射读取注解的流程： 自定义类注解： 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface test01Table &#123; String value();&#125; 自定义属性注解： 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface test01Field &#123; String columnName(); String type(); int length();&#125; 在test01中加入注解： 123456789@test01Table(\"tb_member\")public class test01 &#123; @test01Field(columnName = \"id\", type = \"int\", length = 10) private int id; @test01Field(columnName = \"sname\", type = \"varchar\", length = 10) private String name; @test01Field(columnName = \"age\", type = \"int\", length = 3) private int age;&#125; 读取test01中的注解： 12345678910111213141516171819202122232425262728/** * 通过反射读取自定义注解 */public class ReadAnnotation &#123; public static void main(String[] args) &#123; try &#123; Class clazz = Class.forName(\"com.sgg.annotation.test01\"); //获得类的有效注解 Annotation[] annotations = clazz.getAnnotations(); for(Annotation a : annotations)&#123; System.out.println(a); &#125; //获得类的制定注解 test01Table tt = (test01Table)clazz.getAnnotation(test01Table.class); System.out.println(tt.value()); //获得类的属性的对应注解 Field f = clazz.getDeclaredField(\"id\"); test01Field tf = (test01Field)f.getAnnotation(test01Field.class); System.out.println(tf.columnName() +\"--\"+ tf.type() +\"--\"+ tf.length()); //接下来可以利用注解信息写出DDL语句，完成相应的数据库操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义 ↩","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"annotation","slug":"annotation","permalink":"https://chrisxb1996.github.io/tags/annotation/"}]},{"title":"用hexo搭建个人博客","slug":"用hexo搭建个人博客","date":"2020-05-09T08:50:49.000Z","updated":"2020-06-10T12:35:19.710Z","comments":true,"path":"2020/05/09/用hexo搭建个人博客/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"准备工作安装git：https://git-scm.com安装nodejs：https://nodejs.org/en/安装hexo1.以管理员身份运行：sudo su2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。","text":"准备工作安装git：https://git-scm.com安装nodejs：https://nodejs.org/en/安装hexo1.以管理员身份运行：sudo su2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。3.在国内建议先安装淘宝镜像源 cnpm再进行安装hexo：输入：npm install -g cnpm –registry=https://registry.npm.taobao.org; 安装完后查 看是否安装成功： cnpm -v： 利用cnpm安装hexo博客 ：cnpm install -g hexo-cli 安装成功可查看hexo信息：hexo -v: 4.可以新建一个 文件夹作为存放目录：mkdir blog，进到目录中：cd blog/ (注意操作都在当前文件夹下进行操作)5.至此，hexo已经为你生成了基础博客框架，启动hexo输入 :hexo s6.在浏览器输入地址http://localhost:4000 可以看到基本框架已经生成。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/categories/hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chrisxb1996.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chrisxb1996.github.io/tags/nodejs/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://chrisxb1996.github.io/categories/Leetcode/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/categories/hexo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"Spring","slug":"Spring","permalink":"https://chrisxb1996.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chrisxb1996.github.io/tags/SpringBoot/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://chrisxb1996.github.io/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://chrisxb1996.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"模版方法模式","slug":"模版方法模式","permalink":"https://chrisxb1996.github.io/tags/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"https://chrisxb1996.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"应用层","slug":"应用层","permalink":"https://chrisxb1996.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"传输层","slug":"传输层","permalink":"https://chrisxb1996.github.io/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"网络层","slug":"网络层","permalink":"https://chrisxb1996.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"数据链路层","slug":"数据链路层","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"JVM","slug":"JVM","permalink":"https://chrisxb1996.github.io/tags/JVM/"},{"name":"reflection","slug":"reflection","permalink":"https://chrisxb1996.github.io/tags/reflection/"},{"name":"反射","slug":"反射","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"annotation","slug":"annotation","permalink":"https://chrisxb1996.github.io/tags/annotation/"},{"name":"git","slug":"git","permalink":"https://chrisxb1996.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chrisxb1996.github.io/tags/nodejs/"}]}