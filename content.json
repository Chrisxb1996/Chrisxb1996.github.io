{"meta":{"title":"xNotes","subtitle":"","description":"🍃","author":"xNotes","url":"https://chrisxb1996.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-11T03:34:53.000Z","updated":"2020-05-14T15:09:07.872Z","comments":false,"path":"Coding/index.html","permalink":"https://chrisxb1996.github.io/Coding/index.html","excerpt":"","text":"Java基础Java 注解(Annotation)Java 反射(reflection)Java 动态编译JVM核心机制-类加载过程 设计模式设计模式-单例模式设计模式-工厂模式 LeetCode刷题计算机网络"},{"title":"","date":"2020-05-11T03:26:51.000Z","updated":"2020-05-12T08:27:56.305Z","comments":false,"path":"scientific/index.html","permalink":"https://chrisxb1996.github.io/scientific/index.html","excerpt":"","text":"天线阵列:论文笔记：Statistical Analysis of Array Gain for Cooperative MISO Transmitters without CSI"},{"title":"","date":"2020-05-10T14:25:26.000Z","updated":"2020-05-11T04:42:00.966Z","comments":false,"path":"tags/index.html","permalink":"https://chrisxb1996.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-12T08:35:33.000Z","updated":"2020-05-12T08:38:56.959Z","comments":false,"path":"about/index.html","permalink":"https://chrisxb1996.github.io/about/index.html","excerpt":"","text":"“ ”"},{"title":"","date":"2020-05-10T14:10:33.000Z","updated":"2020-05-11T04:38:23.316Z","comments":false,"path":"categories/index.html","permalink":"https://chrisxb1996.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2020-05-14T07:56:13.000Z","updated":"2020-05-14T13:07:31.393Z","comments":true,"path":"2020/05/14/设计模式-工厂模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"核心：实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。三种类型的工厂模式：1.简单工厂（使用较多）：又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；2.工厂方法：为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，但实际上，我们一般都用简单工厂模式；","text":"核心：实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。三种类型的工厂模式：1.简单工厂（使用较多）：又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；2.工厂方法：为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，但实际上，我们一般都用简单工厂模式；3.抽象工厂：用来生产不同产品族的全部产品：在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式； 不使用工厂模式的情况： 123456public class Audi implements Car&#123; @Override public void run() &#123; System.out.println(\"Audi跑！！！\"); &#125;&#125; 123456public class Byd implements Car&#123; @Override public void run() &#123; System.out.println(\"Byd跑！！！\"); &#125;&#125; 12345678public class test01 &#123; //调用者 public static void main(String[] args) &#123; Car c1 = new Audi(); Car c2 = new Byd(); c1.run(); c2.run(); &#125;&#125; 简单工厂： 12345678public class CarFactory &#123; public static Car createAudi()&#123; return new Audi(); &#125; public static Car createByd()&#123; return new Byd(); &#125;&#125; 12345678public class test01 &#123;//调用者 public static void main(String[] args) &#123; Car car1 = CarFactory.createAudi(); Car car2 = CarFactory.createByd(); car1.run(); car2.run(); &#125;&#125; 工厂方法：增加两个实现类： 1234567891011121314151617public interface CarFactory &#123; Car createCar();&#125;public class AudiFactory implements CarFactory&#123; @Override public Car createCar() &#123; return new Audi(); &#125;&#125;public class BydFactory implements CarFactory&#123; @Override public Car createCar() &#123; return new Byd(); &#125;&#125; 12345678public class test01 &#123;//调用者 public static void main(String[] args) &#123; Car car1 = new AudiFactory().createCar(); Car car2 = new BydFactory().createCar(); car1.run(); car2.run(); &#125;&#125; 抽象工厂：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2020-05-13T09:12:28.000Z","updated":"2020-05-14T13:07:29.495Z","comments":true,"path":"2020/05/13/设计模式-单例模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。常见应用场景：Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…常见的五种单例模式实现方式： 1.饿汉式：线程安全，调用效率高。 但是，不能延时加载； 2.懒汉式：线程安全，调用效率不高，可以延时加载； 3.静态内部类式：线程安全，调用效率高，可以延时加载；","text":"核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。常见应用场景：Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…常见的五种单例模式实现方式： 1.饿汉式：线程安全，调用效率高。 但是，不能延时加载； 2.懒汉式：线程安全，调用效率不高，可以延时加载； 3.静态内部类式：线程安全，调用效率高，可以延时加载； 4.枚举式：线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化创建对象的漏洞！ 5.双重检测锁式：JVM底层内部模型原因，偶尔会出问题。不建议使用； 饿汉式： 1234567891011//饿汉式：public class SingletonDemo01 &#123; //类初始化时，上来先创建对象（没有延时加载的优势），加载类时，天然线程安全 private static SingletonDemo01 instance = new SingletonDemo01(); //构造器私有 private SingletonDemo01()&#123;&#125; //优点：方法没有同步调用效率高 public static SingletonDemo01 getInstance()&#123; return instance; &#125;&#125; 懒汉式： 123456789101112//懒汉式：public class SingletonDemo02 &#123; //类初始化时，不创建对象（延时加载，真正用的时候再创建） private static SingletonDemo02 instance; //构造器私有 private SingletonDemo02()&#123;&#125; //需要加同步，保证单例模式，效率较低 public static synchronized SingletonDemo02 getInstance()&#123; if(instance == null) instance = new SingletonDemo02(); return instance; &#125;&#125; 静态内部类式: 123456789101112//静态内部类方式：线程安全，调用效率高，实现延时加载public class SingletonDemo03 &#123; private static class SingletonInnerClass&#123; private static final SingletonDemo03 instance = new SingletonDemo03(); &#125; //构造器私有 private SingletonDemo03()&#123;&#125; //优点：方法没有同步调用效率高 public static SingletonDemo03 getInstance()&#123; return SingletonInnerClass.instance; &#125;&#125; 枚举式: 1234567//枚举类方式：线程安全，但没有延时加载；同时能够避免反射和反序列的漏洞public enum SingletonDemo04 &#123; INSTANCE; //可以自己添加一些操作方法 public static void instanceOper()&#123; &#125;&#125; 如何选用合适的单例模式：单例对象占用资源少，不需要延时加载：枚举式 &gt; 饿汉式;单例对象占用资源大，需要 延时加载：静态内部类式 &gt; 懒汉式;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"JVM核心机制-类加载过程","slug":"JVM核心机制-类加载过程","date":"2020-05-13T06:38:30.000Z","updated":"2020-05-13T09:13:29.369Z","comments":true,"path":"2020/05/13/JVM核心机制-类加载过程/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口： 类加载器的层次结构(树状结构): 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader；","text":"类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口： 类加载器的层次结构(树状结构): 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader； 扩展类加载器（extensions class loader）：用来加载 Java 的扩展库，Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类，由ExtClassLoader实现； 应用程序类加载器（application class loader）：它根据 Java 应用的类路径来加载 Java 类，一般来说，Java 应用的类都是由它来完成加载的，由AppClassLoader实现； 自定义类加载器： 开发人员可以通过继承 java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。 注意：类加载器加载类的时候是线程安全的 双亲委托机制： 就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 双亲委托机制是为了保证 Java 核心库的类型安全，这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。 类加载器除了用于加载类，也是安全的最基本的屏障。 双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制：tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://chrisxb1996.github.io/tags/JVM/"}]},{"title":"Java 动态编译","slug":"Java-动态编译","date":"2020-05-12T07:20:23.000Z","updated":"2020-05-14T03:19:01.203Z","comments":true,"path":"2020/05/12/Java-动态编译/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/12/Java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/","excerpt":"Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：通过JavaCompiler动态编译： 1234567public static int compileFile(String sourceFile)&#123; //动态编译 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null,sourceFile); System.out.println(result==0?\"编译成功\":\"编译失败\"); return result;&#125; • 第一个参数：为java编译器提供参数• 第二个参数：得到 Java 编译器的输出信息","text":"Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：通过JavaCompiler动态编译： 1234567public static int compileFile(String sourceFile)&#123; //动态编译 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null,sourceFile); System.out.println(result==0?\"编译成功\":\"编译失败\"); return result;&#125; • 第一个参数：为java编译器提供参数• 第二个参数：得到 Java 编译器的输出信息• 第三个参数：接收编译器的 错误信息• 第四个参数：可变参数（是一个String数组）能传入一个或多个 Java 源文件• 返回值：0表示编译成功，非0表示编译失败 动态运行编译好的类： 通过Runtime.getRuntime()运行启动新的进程运行12Runtime run = Runtime.getRuntime();Process process = run.exec(\"java -cp path HelloWorld\"); 通过反射运行编译好的类12345678910111213//通过反射运行程序public static void runJavaClassByReflect(String dir,String classFile) throws Exception&#123; try &#123; URL[] urls = new URL[] &#123;new URL(\"file:/\"+dir)&#125;; URLClassLoader loader = new URLClassLoader(urls); Class c = loader.loadClass(classFile); //调用加载类的main方法 Method m = c.getMethod(\"main\",String[].class) m.invoke(null, (Object)new String[]&#123;&#125;);//反射调用main方法加(object)强制转型 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"}]},{"title":"Java 反射","slug":"Java-反射","date":"2020-05-11T13:35:34.000Z","updated":"2020-05-13T06:36:53.159Z","comments":true,"path":"2020/05/11/Java-反射/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/11/Java-%E5%8F%8D%E5%B0%84/","excerpt":"虽然Java不是动态语言1，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。反射：指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。反射机制的作用：重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。","text":"虽然Java不是动态语言1，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。反射：指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。反射机制的作用：重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。获取Class对象：1.Class.forName();(常用)2.getClass();3..class;代码： javaBean:1234567891011121314151617181920212223242526272829303132public class User &#123; private int id; private int age; private String name; //javabean一定要有无参构造器 public User() &#123; &#125; public User(int id, int age, String name) &#123; super(); this.id = id; this.age = age; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 获得User类的反射对象：1234567String path = \"com.sxt.test.bean.User\";Class clazz = Class.forName(path);//方法一User u = new User();Class clazz2 = u.getClass();//方法二Class clazz3 = com.sxt.test.bean.User.class;//方法三 获得User类的属性：1Field f = clazz.getDeclaredField(\"name\"); 获得User类的方法：123Method m01 = clazz.getDeclaredMethod(\"getName\", null);//如果方法有参数，则必须传递参数类型对应的Class对象Method m02 = clazz.getDeclaredMethod(\"setName\", String.class); 获得User类指定的构造器：1Constructor constructor = clazz.getDeclaredConstructor(int.class,int.class,String.class); 通过反射API动态的操作：构造器，方法，属性：123456789101112131415//通过反射API调用构造方法，构造对象User u1 = (User) clazz.getConstructor().newInstance();//调用了User的无参构造器User u2 = (User)clazz.getConstructor(int.class,int.class,String.class).newInstance(1001,18,\"席博\");//调用了User带参构造器//通过反射API调用普通方法 invoke(对象，参数)方法User u3 = (User) clazz.getConstructor().newInstance();Method method = clazz.getDeclaredMethod(\"setName\", String.class);method.invoke(u3, \"aaa\");//u3.setName(\"aaa\");//通过反射API操作属性User u4 = (User) clazz.getConstructor().newInstance();Field f = clazz.getDeclaredField(\"name\");//通过反射获得属性f.setAccessible(true); //这个属性不需要做安全检查，可以直接访问f.set(u4, \"bbb\"); //通过反射直接写u4属性f.get(u4);//通过反射读取u4属性 通过反射读取泛型的信息：ParameterizedType: 表示一种参数化的类型，比如Collection； 通过反射读取注解的信息，模拟处理注解信息的流程，具体参见：Java 注解 反射的性能问题：使用反射性能会降低(约30倍)，setAccessible：启用和禁用访问安全检查的开关，设为 true 则表示反射的对象在使用时禁止 Java 语言访问检查。禁止安全检查，可以提高反射的运行速度(大约提高四倍)。 1.动态语言：程序运行时，可以改变程序结构或变量类型。常见的动态语言：Python、ruby、javascript ↩","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"reflection","slug":"reflection","permalink":"https://chrisxb1996.github.io/tags/reflection/"},{"name":"反射","slug":"反射","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java 注解","slug":"Java-注解","date":"2020-05-10T03:56:57.000Z","updated":"2020-05-14T03:16:59.928Z","comments":true,"path":"2020/05/10/Java-注解/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/10/Java-%E6%B3%A8%E8%A7%A3/","excerpt":"Annotation的作用：1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)Annotation的格式：注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value=”unchecked”)。(抑制警告)Annotation在哪里使用：可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。","text":"Annotation的作用：1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)Annotation的格式：注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value=”unchecked”)。(抑制警告)Annotation在哪里使用：可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。自定义注解：格式：public @interface 注解名 {定义体}1.方法的名称就是参数的名称;2.返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）;3.可以通过default来声明参数的默认值1;4.如果只有一个参数成员，一般参数名为value;元注解：元注解的作用就是负责注解其他注解。 Java定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。1.@Target：用于描述注解的使用范围（即:被描述的注解可以用在什么地方）ElementType.TYPE；ElementType.FIELD…2.@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期SOURCE；CLASS；RUNTIME(可被反射机制读取)3.@Documented4.@Inherited通过反射读取注解的流程： 自定义类注解： 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface test01Table &#123; String value();&#125; 自定义属性注解： 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface test01Field &#123; String columnName(); String type(); int length();&#125; 在test01中加入注解： 123456789@test01Table(\"tb_member\")public class test01 &#123; @test01Field(columnName = \"id\", type = \"int\", length = 10) private int id; @test01Field(columnName = \"sname\", type = \"varchar\", length = 10) private String name; @test01Field(columnName = \"age\", type = \"int\", length = 3) private int age;&#125; 读取test01中的注解： 12345678910111213141516171819202122232425262728/** * 通过反射读取自定义注解 */public class ReadAnnotation &#123; public static void main(String[] args) &#123; try &#123; Class clazz = Class.forName(\"com.sgg.annotation.test01\"); //获得类的有效注解 Annotation[] annotations = clazz.getAnnotations(); for(Annotation a : annotations)&#123; System.out.println(a); &#125; //获得类的制定注解 test01Table tt = (test01Table)clazz.getAnnotation(test01Table.class); System.out.println(tt.value()); //获得类的属性的对应注解 Field f = clazz.getDeclaredField(\"id\"); test01Field tf = (test01Field)f.getAnnotation(test01Field.class); System.out.println(tf.columnName() +\"--\"+ tf.type() +\"--\"+ tf.length()); //接下来可以利用注解信息写出DDL语句，完成相应的数据库操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义 ↩","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"annotation","slug":"annotation","permalink":"https://chrisxb1996.github.io/tags/annotation/"}]},{"title":"用hexo搭建个人博客","slug":"用hexo搭建个人博客","date":"2020-05-09T08:50:49.000Z","updated":"2020-05-13T04:46:33.638Z","comments":true,"path":"2020/05/09/用hexo搭建个人博客/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"准备工作安装git：https://git-scm.com安装nodejs：https://nodejs.org/en/安装hexo1.以管理员身份运行：sudo su2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。","text":"准备工作安装git：https://git-scm.com安装nodejs：https://nodejs.org/en/安装hexo1.以管理员身份运行：sudo su2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。3.在国内建议先安装淘宝镜像源 cnpm再进行安装hexo：输入：npm install -g cnpm –registry=https://registry.npm.taobao.org; 安装完后查 看是否安装成功： cnpm -v： 利用cnpm安装hexo博客 ：cnpm install -g hexo-cli 安装成功可查看hexo信息：hexo -v: 4.可以新建一个 文件夹作为存放目录：mkdir blog，进到目录中：cd blog/ (注意操作都在当前文件夹下进行操作)5.至此，hexo已经为你生成了基础博客框架，启动hexo输入 :hexo s6.在浏览器输入地址http://localhost:4000 可以看到基本框架已经生成。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/categories/hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chrisxb1996.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chrisxb1996.github.io/tags/nodejs/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/categories/hexo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"JVM","slug":"JVM","permalink":"https://chrisxb1996.github.io/tags/JVM/"},{"name":"reflection","slug":"reflection","permalink":"https://chrisxb1996.github.io/tags/reflection/"},{"name":"反射","slug":"反射","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"annotation","slug":"annotation","permalink":"https://chrisxb1996.github.io/tags/annotation/"},{"name":"git","slug":"git","permalink":"https://chrisxb1996.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chrisxb1996.github.io/tags/nodejs/"}]}