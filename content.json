{"meta":{"title":"xbsNotes","subtitle":"","description":"🍃","author":"xNotes","url":"https://chrisxb1996.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-11T03:34:53.000Z","updated":"2020-06-19T05:32:02.942Z","comments":false,"path":"Coding/index.html","permalink":"https://chrisxb1996.github.io/Coding/index.html","excerpt":"","text":"Java基础Java 注解(Annotation)Java 反射(reflection)Java 动态编译JVM核心机制-类加载过程Java-基础 设计模式设计模式-单例模式设计模式-工厂模式设计模式-策略模式设计模式-模版方法模式设计模式-观察者模式 LeetCode刷题 剑指offer剑指offer-简单篇剑指offer-中等篇 计算机网络计算机网络概述数据链路层网络层传输层应用层"},{"title":"","date":"2020-05-11T03:26:51.000Z","updated":"2020-05-12T08:27:56.305Z","comments":false,"path":"scientific/index.html","permalink":"https://chrisxb1996.github.io/scientific/index.html","excerpt":"","text":"天线阵列:论文笔记：Statistical Analysis of Array Gain for Cooperative MISO Transmitters without CSI"},{"title":"","date":"2020-05-10T14:10:33.000Z","updated":"2020-05-11T04:38:23.316Z","comments":false,"path":"categories/index.html","permalink":"https://chrisxb1996.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-12T08:35:33.000Z","updated":"2020-05-12T08:38:56.959Z","comments":false,"path":"about/index.html","permalink":"https://chrisxb1996.github.io/about/index.html","excerpt":"","text":"“ ”"},{"title":"","date":"2020-05-10T14:25:26.000Z","updated":"2020-05-11T04:42:00.966Z","comments":false,"path":"tags/index.html","permalink":"https://chrisxb1996.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql数据库","slug":"mysql数据库","date":"2020-06-26T03:43:06.000Z","updated":"2020-06-28T09:15:02.446Z","comments":true,"path":"2020/06/26/mysql数据库/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/26/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"登录和退出MySQL服务器1234#登陆mysql -uroot -p12345612;#退出exit;","text":"登录和退出MySQL服务器1234#登陆mysql -uroot -p12345612;#退出exit; 增删改查基本语法12345678910111213141516171819202122232425262728293031323334353637383940-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 插入数据INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);-- 修改数据UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;-- 删除数据DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;-- 删除表DROP TABLE myorder; mysql 建表约束主键约束：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20));mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+-- 联合主键-- 联合主键中的每个字段都不能为空，并且*加起来*不能和已设置的联合主键重复即可。CREATE TABLE user2 ( id INT, name VARCHAR(20), password VARCHAR(20), PRIMARY KEY(id, name));mysql&gt; desc user2;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | NO | PRI | NULL | || password | varchar(20) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+-- 自增约束：auto_increment-- 自增约束的主键由系统自动递增分配。create table user3( id int primary key auto_increment, name varchar(20));mysql&gt; desc user3;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+insert into user3 (name) values (&#39;zhangsan&#39;);mysql&gt; select * from user3;+----+----------+| id | name |+----+----------+| 1 | zhangsan |+----+----------+-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY; 唯一约束：123456789101112131415161718192021-- 建表时创建唯一字段CREATE TABLE user5 ( id INT, name VARCHAR(20), UNIQUE(name));#表示(id,name)合在一起不同即可CREATE TABLE user6 ( id INT, name VARCHAR(20), UNIQUE(id,name));-- 添加唯一约束-- 如果建表时没有设置唯一约束，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一约束ALTER TABLE user DROP INDEX name; 非空约束：123456789101112131415161718-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user7 ( id INT, name VARCHAR(20) NOT NULL);mysql&gt; desc user7;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20); 默认约束：12345678910111213141516-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user9 ( id INT, name VARCHAR(20), age INT DEFAULT 10);mysql&gt; desc user9;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | || age | int(11) | YES | | 10 | |+-------+-------------+------+-----+---------+-------+ 外键约束：123456789101112131415161718192021222324252627282930313233343536373839-- 外键约束-- 涉及两个表：主表，副表-- 班级表 create table class( id int primary key, name varchar(20));mysql&gt; desc class;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+-- 学生表 create table student( id int primary key, name varchar(20), -- 这里的 class_id 要和 classes 中的 id 字段相关联 class_id int, -- 表示 class_id 的值必须来自于 classes 中的 id 字段值 foreign key(class_id) references class(id));mysql&gt; desc student;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | || class_id | int(11) | YES | MUL | NULL | |+----------+-------------+------+-----+---------+-------+-- 注意：-- 1.主表（class）中没有的数据值，在副表（student）中不能使用；-- 2.主表中的记录被副表引用，不不可以删除的； 数据表设计-三大范式1NF只要字段值还可以继续拆分，就不满足第一范式。 范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。 1address&gt;&gt;- country | province | city | details | 2NF在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下： 12345678-- 订单表CREATE TABLE myorder ( product_id INT, customer_id INT, product_name VARCHAR(20), customer_name VARCHAR(20), PRIMARY KEY (product_id, customer_id)); 实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。 这就不满足第二范式：其他列都必须完全依赖于主键列！–&gt;拆分！ 123456789101112131415CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(20));CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20)); 拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！ 3NF在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。 123456CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT, customer_phone VARCHAR(15)); 表中的 customer_phone 有可能依赖于除了 customer_id 之外的 order_id 列，也就不满足了第三范式的设计：除了主键列之外，其他列之间不能有传递依赖关系。 1234567891011CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20), phone VARCHAR(15)); 修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！ mysql查询练习准备数据创建表：学生表(student)、教师表(teacher)、成绩表(score)、课程表(course) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-- 创建学生表-- 学号-- 姓名-- 性别-- 生日-- 班级CREATE TABLE student ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, -- 生日 class VARCHAR(20) -- 所在班级);-- 创建教师表-- 编号 -- 姓名-- 性别-- 生日-- 职称-- 部门 CREATE TABLE teacher ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, profession VARCHAR(20) NOT NULL, -- 职称 department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表-- 课程编号-- 教师名称-- 教师编号CREATE TABLE course ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, t_no VARCHAR(20) NOT NULL, -- 教师编号 -- 外键：表示该 tno 来自于 teacher 表中的 no 字段值 FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表-- 学生编号-- 课程编号-- 成绩CREATE TABLE score ( s_no VARCHAR(20) NOT NULL, -- 学生编号 c_no VARCHAR(20) NOT NULL, -- 课程号 degree DECIMAL, -- 成绩 -- 外键：表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值 FOREIGN KEY(s_no) REFERENCES student(no), FOREIGN KEY(c_no) REFERENCES course(no), -- 设置 s_no, c_no 为联合主键 PRIMARY KEY(s_no, c_no)); 添加数据： 123456789101112131415161718192021222324252627282930313233343536373839-- 添加学生表数据INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);-- 添加教师表数据INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);-- 添加课程表数据INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);-- 添加添加成绩表数据INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher; 十道练习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191-- 1.查询student表中所有记录select * from student;mysql&gt; select * from student;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 |+-----+-----------+-----+------------+-------+-- 2.查询 student 表中的 name、sex 和 class 字段的所有行select name, sex, class from student;mysql&gt; select name, sex, class from student;+-----------+-----+-------+| name | sex | class |+-----------+-----+-------+| 曾华 | 男 | 95033 || 匡明 | 男 | 95031 || 王丽 | 女 | 95033 || 李军 | 男 | 95033 || 王芳 | 女 | 95031 || 陆军 | 男 | 95031 || 王尼玛 | 男 | 95033 || 张全蛋 | 男 | 95031 || 赵铁柱 | 男 | 95031 |+-----------+-----+-------+-- 3.查询 teacher 表中不重复的 department 列-- distinct: 去重查询select distinct department from teacher;mysql&gt; select distinct department from teacher;+-----------------+| department |+-----------------+| 计算机系 || 电子工程系 |+-----------------+-- 4.查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;select * from score where degree between 60 and 80;select * from score where degree &gt; 60 and degree &lt; 80;mysql&gt; select * from score where degree between 60 and 80;mysql&gt; select * from score where degree &gt; 60 and degree &lt; 80;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 |+------+-------+--------+-- 5.查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值select * from score where degree in (85,86,88);mysql&gt; select * from score where degree in (85,86,88);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 |+------+-------+--------+-- 6.查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行-- or: 表示或者关系select * from student where class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;mysql&gt; select * from student where class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 102 | 匡明 | 男 | 1975-10-02 | 95031 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 |+-----+-----------+-----+------------+-------+-- 7.以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高select * from student order by class desc;select * from student order by class; (asc)mysql&gt; select * from student order by class desc;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 |+-----+-----------+-----+------------+-------+mysql&gt; select * from student order by class;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 102 | 匡明 | 男 | 1975-10-02 | 95031 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 101 | 曾华 | 男 | 1977-09-01 | 95033 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 |+-----+-----------+-----+------------+-------+-- 8.以 c_no 升序、degree 降序查询 score 表的所有行-- 先以c_no升、再以score降序select * from score order by c_no , degree desc;mysql&gt; select * from score order by c_no , degree desc;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 105 | 3-105 | 88 || 109 | 3-105 | 76 || 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 || 103 | 6-166 | 85 || 109 | 6-166 | 81 || 105 | 6-166 | 79 |+------+-------+--------+-- 9.查询 &quot;95031&quot; 班的学生人数-- COUNT: 统计select count(*) from student where class &#x3D; &#39;95031&#39;;mysql&gt; select count(*) from student where class &#x3D; &#39;95031&#39;;+----------+| count(*) |+----------+| 5 |+----------+-- 10.查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分select s_no, c_no from score where degree &#x3D; (select max(degree) from score);mysql&gt; select s_no, c_no from score where degree &#x3D; (select max(degree) from score);+------+-------+| s_no | c_no |+------+-------+| 103 | 3-105 |+------+-------+-- 排序方式-- limit num1,num2-- num1:表示从第 num1 条记录开始取；-- num2:表示取 num2 条记录；select s_no, c_no from score order by degree desc limit 0,1;mysql&gt; select s_no, c_no from score order by degree desc limit 0,1;+------+-------+| s_no | c_no |+------+-------+| 103 | 3-105 |+------+-------+ 分组计算平均成绩1234567891011121314151617181920212223-- 查询每门课的平均成绩-- AVG: 平均值select avg(degree) from score where c_no &#x3D; &#39;3-105&#39;;mysql&gt; select avg(degree) from score where c_no &#x3D; &#39;3-105&#39;;+-------------+| avg(degree) |+-------------+| 85.3333 |+-------------+-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no;mysql&gt; SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 85.3333 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+ 分组条件与模糊查询123456789101112131415161718192021222324-- 查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数-- 查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) &gt;&#x3D; 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。AND c_no LIKE &#39;3%&#39;-- 最终语句select c_no, avg(degree), count(c_no) from score GROUP BY c_noHAVING COUNT(c_no) &gt;&#x3D; 2 and c_no LIKE &#39;3%&#39;;mysql&gt; select c_no, avg(degree), count(c_no) from score GROUP BY c_no -&gt; HAVING COUNT(c_no) &gt;&#x3D; 2 and -&gt; c_no LIKE &#39;3%&#39;;+-------+-------------+-------------+| c_no | avg(degree) | count(c_no) |+-------+-------------+-------------+| 3-105 | 85.3333 | 3 || 3-245 | 76.3333 | 3 |+-------+-------------+-------------+ 多表查询查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354-- SELECT no, name FROM student;mysql&gt; SELECT no, name FROM student;+-----+-----------+| no | name |+-----+-----------+| 101 | 曾华 || 102 | 匡明 || 103 | 王丽 || 104 | 李军 || 105 | 王芳 || 106 | 陆军 || 107 | 王尼玛 || 108 | 张全蛋 || 109 | 赵铁柱 |+-----+-----------+-- SELECT s_no, c_no, degree FROM score;mysql&gt; SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+-- 查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree select name, c_no, degree from student, scorewhere student.no &#x3D; score.s_no;mysql&gt; select name, c_no, degree from student, score -&gt; where student.no &#x3D; score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列： 123456789101112131415161718192021222324252627282930313233343536373839-- 查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列select s_no, name, degree from course, score where course.no &#x3D; score.c_no;mysql&gt; select s_no, name, degree from course, score -&gt; where course.no &#x3D; score.c_no;+------+-----------------+--------+| s_no | name | degree |+------+-----------------+--------+| 103 | 计算机导论 | 92 || 103 | 操作系统 | 86 || 103 | 数字电路 | 85 || 105 | 计算机导论 | 88 || 105 | 操作系统 | 75 || 105 | 数字电路 | 79 || 109 | 计算机导论 | 76 || 109 | 操作系统 | 68 || 109 | 数字电路 | 81 |+------+-----------------+--------+-- as 表示取一个该字段的别名。select s_no, name as c_name, degree from course, score where course.no &#x3D; score.c_no;mysql&gt; select s_no, name as c_name, degree from course, score -&gt; where course.no &#x3D; score.c_no;+------+-----------------+--------+| s_no | c_name | degree |+------+-----------------+--------+| 103 | 计算机导论 | 92 || 103 | 操作系统 | 86 || 103 | 数字电路 | 85 || 105 | 计算机导论 | 88 || 105 | 操作系统 | 75 || 105 | 数字电路 | 79 || 109 | 计算机导论 | 76 || 109 | 操作系统 | 68 || 109 | 数字电路 | 81 |+------+-----------------+--------+ 三表关联查询查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree ： 1234567891011121314151617181920212223242526272829-- 查询所有学生的 &#96;name&#96; 、课程名 ( &#96;course&#96; 表中的 &#96;name&#96; ) 和 &#96;degree&#96; -- name --&gt; student表-- c_name --&gt; course表-- degree --&gt; score表-- 只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。select student.name, course.name as c_name, degree from student, course, score where student.no &#x3D; score.s_no and course.no &#x3D; score.c_no;mysql&gt; select student.name, course.name as c_name, degree -&gt; from student, course, score -&gt; where student.no &#x3D; score.s_no and -&gt; course.no &#x3D; score.c_no;+-----------+-----------------+--------+| name | c_name | degree |+-----------+-----------------+--------+| 王丽 | 计算机导论 | 92 || 王丽 | 操作系统 | 86 || 王丽 | 数字电路 | 85 || 王芳 | 计算机导论 | 88 || 王芳 | 操作系统 | 75 || 王芳 | 数字电路 | 79 || 赵铁柱 | 计算机导论 | 76 || 赵铁柱 | 操作系统 | 68 || 赵铁柱 | 数字电路 | 81 |+-----------+-----------------+--------+ 子查询加分组求平均分查询 95031 班学生每门课程的平均成绩： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869-- 查询 95031 班学生每门课程的平均成绩-- 1.查询 95031 班的学生学号作为条件select no from student where class &#x3D; &#39;95031&#39;mysql&gt; select no from student where class &#x3D; &#39;95031&#39;;+-----+| no |+-----+| 102 || 105 || 106 || 108 || 109 |+-----+-- 2.IN (..): 将筛选出的学生号当做 s_no 的条件查询select s_no, c_no, degree from score where s_no in (select no from student where class &#x3D; &#39;95031&#39;);mysql&gt; select s_no, c_no, degree from score -&gt; where s_no in (select no from student where class &#x3D; &#39;95031&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+-- 按课程号分组求平均：group by c_noselect c_no, avg(degree) from score where s_no in (select no from student where class &#x3D; &#39;95031&#39;) group by c_no;mysql&gt; select c_no, avg(degree) -&gt; from score -&gt; where s_no in (select no from student where class &#x3D; &#39;95031&#39;) -&gt; group by c_no;+-------+-------------+| c_no | avg(degree) |+-------+-------------+| 3-105 | 82.0000 || 3-245 | 71.5000 || 6-166 | 80.0000 |+-------+-------------+-- 将课程编号换成课程名select name as c_name, avg(degree) from score, coursewhere s_no in (select no from student where class &#x3D; &#39;95031&#39;) and course.no &#x3D; score.c_nogroup by c_no;mysql&gt; select name as c_name, avg(degree) -&gt; from score, course -&gt; where s_no in (select no from student where class &#x3D; &#39;95031&#39;) -&gt; and course.no &#x3D; score.c_no -&gt; group by c_no;+-----------------+-------------+| c_name | avg(degree) |+-----------------+-------------+| 计算机导论 | 82.0000 || 操作系统 | 71.5000 || 数字电路 | 80.0000 |+-----------------+-------------+ 子查询查询在 3-105 课程中，所有成绩高于 109 号同学的记录： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-- 查询在 3-105 课程中，所有成绩高于 109 号同学的记录-- 1.首先筛选出课堂号为 3-105select s_no, c_no from score where c_no &#x3D; &#39;3-105&#39;;mysql&gt; select s_no, c_no from score where c_no &#x3D; &#39;3-105&#39;;+------+-------+| s_no | c_no |+------+-------+| 103 | 3-105 || 105 | 3-105 || 109 | 3-105 |+------+-------+-- 2.找到 109 同学的 3-105 成绩select degree from score where s_no &#x3D; &#39;109&#39; and c_no &#x3D;&#39;3-105&#39;;mysql&gt; select degree from score where s_no &#x3D; &#39;109&#39; and c_no &#x3D;&#39;3-105&#39;;+--------+| degree |+--------+| 76 |+--------+-- 3.最终语句select * from score where c_no &#x3D; &#39;3-105&#39; and degree &gt; (select degree from score where s_no &#x3D; &#39;109&#39; and c_no &#x3D;&#39;3-105&#39;);mysql&gt; select * from score -&gt; where c_no &#x3D; &#39;3-105&#39; -&gt; and degree &gt; (select degree from score where s_no &#x3D; &#39;109&#39; and c_no &#x3D;&#39;3-105&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 105 | 3-105 | 88 |+------+-------+--------+-- 查询所有成绩高于 109 号同学的 3-105 课程成绩的所有记录。select * from score where degree &gt; (select degree from score where s_no &#x3D; &#39;109&#39; and c_no &#x3D;&#39;3-105&#39;);mysql&gt; select * from score -&gt; where degree &gt; (select degree from score where s_no &#x3D; &#39;109&#39; and c_no &#x3D;&#39;3-105&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 6-166 | 79 || 109 | 6-166 | 81 |+------+-------+--------+ YEAR 函数与带 IN 关键字查询查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列 12345678910111213141516171819202122232425262728293031323334353637383940-- 查询所有和 &#96;101&#96; 、&#96;108&#96; 号学生同年出生的 &#96;no&#96; 、&#96;name&#96; 、&#96;birthday&#96; 列select * from student where no in (&#39;101&#39;, &#39;108&#39;);mysql&gt; select * from student where no in (&#39;101&#39;, &#39;108&#39;);+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 |+-----+-----------+-----+------------+-------+-- 查询年份 yearselect year(birthday) from student where no in (&#39;101&#39;, &#39;108&#39;);mysql&gt; select year(birthday) from student where no in (&#39;101&#39;, &#39;108&#39;);+----------------+| year(birthday) |+----------------+| 1977 || 1975 |+----------------+-- 最终语句select no, name, birthday from student where year(birthday) in ( select year(birthday) from student where no in (&#39;101&#39;, &#39;108&#39;) );mysql&gt; select no, name, birthday from student -&gt; where year(birthday) -&gt; in ( select year(birthday) from student where no in (&#39;101&#39;, &#39;108&#39;) );+-----+-----------+------------+| no | name | birthday |+-----+-----------+------------+| 101 | 曾华 | 1977-09-01 || 102 | 匡明 | 1975-10-02 || 105 | 王芳 | 1975-02-10 || 108 | 张全蛋 | 1975-02-10 |+-----+-----------+------------+ 多层嵌套子查询查询 &#39;张旭&#39; 教师任课的学生成绩表 123456789101112131415161718192021222324252627282930313233343536373839-- 查询 &#39;张旭&#39; 教师任课的学生成绩表-- 查找对应教师的编号select no from teacher where name &#x3D; &#39;张旭&#39;;mysql&gt; select no from teacher where name &#x3D; &#39;张旭&#39;;+-----+| no |+-----+| 856 |+-----+-- 2.通过教师编号查找对应的课程select * from course where t_no &#x3D; (select no from teacher where name &#x3D; &#39;张旭&#39;);mysql&gt; select * from course where t_no &#x3D; (select no from teacher where name &#x3D; &#39;张旭&#39;);+-------+--------------+------+| no | name | t_no |+-------+--------------+------+| 6-166 | 数字电路 | 856 |+-------+--------------+------+-- 3.通过课程编号查找学生成绩表select * from score where c_no &#x3D; (select no from course where t_no &#x3D; (select no from teacher where name &#x3D; &#39;张旭&#39;));mysql&gt; select * from score -&gt; where c_no &#x3D; -&gt; (select no from course where t_no &#x3D; (select no from teacher where name &#x3D; &#39;张旭&#39;));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 6-166 | 85 || 105 | 6-166 | 79 || 109 | 6-166 | 81 |+------+-------+--------+ 多表查询查询某选修课程多于5个同学的教师姓名 123456789101112131415161718192021222324252627282930313233343536373839-- 查询某选修课程多于5个同学的教师姓名-- 1.找到选修课程大于5个同学的课程select c_no from score group by c_no having count(c_no)&gt;5;mysql&gt; select c_no from score group by c_no having count(c_no)&gt;5;+-------+| c_no |+-------+| 3-105 |+-------+-- 2.找到该课程对应的教师编号select t_no from course where no in (select c_no from score group by c_no having count(c_no)&gt;5);mysql&gt; select t_no from course -&gt; where no in (select c_no from score group by c_no having count(c_no)&gt;5);+------+| t_no |+------+| 825 |+------+-- 3.根据教师编号找到对应的教师姓名select name from teacher where no in (select t_no from course where no in (select c_no from score group by c_no having count(c_no)&gt;5)); mysql&gt; select name from teacher -&gt; where no in (select t_no from course -&gt; where no in (select c_no from score group by c_no having count(c_no)&gt;5));+--------+| name |+--------+| 王萍 |+--------+ 子查询-2查询计算机系所有老师的上的课的成绩表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-- 查询计算机系所有老师的上的课的成绩表-- 1.查询所有计算机系的老师select * from teacher where department &#x3D; &#39;计算机系&#39;;mysql&gt; select * from teacher where department &#x3D; &#39;计算机系&#39;;+-----+--------+-----+------------+------------+--------------+| no | name | sex | birthday | profession | department |+-----+--------+-----+------------+------------+--------------+| 804 | 李诚 | 男 | 1958-12-02 | 副教授 | 计算机系 || 825 | 王萍 | 女 | 1972-05-05 | 助教 | 计算机系 |+-----+--------+-----+------------+------------+--------------+-- 2.根据教师编号，查询计算机系老师上的课select * from course where t_no in (select no from teacher where department &#x3D; &#39;计算机系&#39;);mysql&gt; select * from course -&gt; where t_no in (select no from teacher where department &#x3D; &#39;计算机系&#39;);+-------+-----------------+------+| no | name | t_no |+-------+-----------------+------+| 3-245 | 操作系统 | 804 || 3-105 | 计算机导论 | 825 |+-------+-----------------+------+-- 3.根据课程编号，查询对应课程的成绩表select * from scorewhere c_no in (select no from course where t_no in (select no from teacher where department &#x3D; &#39;计算机系&#39;));mysql&gt; select * from score -&gt; where c_no in (select no from course -&gt; where t_no in (select no from teacher where department &#x3D; &#39;计算机系&#39;));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 || 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ UNION 和 NOT IN 的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-- 查询 计算机系 与 电子工程系 中的不同职称的教师-- -- NOT: 代表逻辑非-- -- UNION：求并集-- 查询 计算机系 教师的职称select profession from teacher where department &#x3D; &#39;计算机系&#39;;-- 查询 电子工程系 教师的职称select profession from teacher where department &#x3D; &#39;电子工程系&#39;;-- 查询 计算机系 中，职称在电子工程系没有的教师select * from teacher where department &#x3D; &#39;计算机系&#39; and profession not in (select profession from teacher where department &#x3D; &#39;电子工程系&#39;);+-----+--------+-----+------------+------------+--------------+| no | name | sex | birthday | profession | department |+-----+--------+-----+------------+------------+--------------+| 804 | 李诚 | 男 | 1958-12-02 | 副教授 | 计算机系 |+-----+--------+-----+------------+------------+--------------+-- 查询 电子工程系 中，职称在计算机系没有的教师select * from teacher where department &#x3D; &#39;电子工程系&#39; and profession not in (select profession from teacher where department &#x3D; &#39;计算机系&#39;);+-----+--------+-----+------------+------------+-----------------+| no | name | sex | birthday | profession | department |+-----+--------+-----+------------+------------+-----------------+| 856 | 张旭 | 男 | 1969-03-12 | 讲师 | 电子工程系 |+-----+--------+-----+------------+------------+-----------------+-- 最终语句：用 UNION 将两个语句合起来select * from teacher where department &#x3D; &#39;计算机系&#39; and profession not in (select profession from teacher where department &#x3D; &#39;电子工程系&#39;)unionselect * from teacher where department &#x3D; &#39;电子工程系&#39; and profession not in (select profession from teacher where department &#x3D; &#39;计算机系&#39;);+-----+--------+-----+------------+------------+-----------------+| no | name | sex | birthday | profession | department |+-----+--------+-----+------------+------------+-----------------+| 804 | 李诚 | 男 | 1958-12-02 | 副教授 | 计算机系 || 856 | 张旭 | 男 | 1969-03-12 | 讲师 | 电子工程系 |+-----+--------+-----+------------+------------+-----------------+ ANY 表示至少一个 - DESC ( 降序 )查询课程 3-105 且成绩 至少 高于 3-245 的 score 表(大于 3-245 的最小值) 123456789101112131415161718-- 查询课程 &#96;3-105&#96; 且成绩 至少 高于 &#96;3-245&#96; 的 &#96;score&#96; 表select * from score where c_no &#x3D; &#39;3-105&#39; and degree &gt; any(select degree from score where c_no &#x3D; &#39;3-245&#39;)order by degree desc;mysql&gt; select * from score -&gt; where c_no &#x3D; &#39;3-105&#39; and degree &gt; any(select degree from score where c_no &#x3D; &#39;3-245&#39;) -&gt; order by degree desc;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 102 | 3-105 | 91 || 101 | 3-105 | 90 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ 表示所有的 ALL查询课程 3-105 且成绩高于 3-245 的 score 表 123456789101112131415161718-- 查询课程 3-105 且成绩高于 3-245 的 score 表-- allselect * from score where c_no &#x3D; &#39;3-105&#39; and degree &gt; all(select degree from score where c_no &#x3D; &#39;3-245&#39;)order by degree desc;mysql&gt; select * from score -&gt; where c_no &#x3D; &#39;3-105&#39; and degree &gt; all(select degree from score where c_no &#x3D; &#39;3-245&#39;) -&gt; order by degree desc;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 102 | 3-105 | 91 || 101 | 3-105 | 90 || 104 | 3-105 | 89 || 105 | 3-105 | 88 |+------+-------+--------+ 复制表的数据作为条件查询查询某课程成绩比该课程平均成绩低的 score 表 123456789101112131415161718192021222324252627282930-- 查询某课程成绩比该课程平均成绩低的 &#96;score&#96; 表-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;mysql&gt; SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 87.6667 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了select * from score awhere degree &lt; (SELECT AVG(degree) FROM score b where a.c_no &#x3D; b.c_no);mysql&gt; select * from score a -&gt; where degree &lt; (SELECT AVG(degree) FROM score b where a.c_no &#x3D; b.c_no);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 子查询 - 4查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 1234567891011121314-- 查询所有任课 ( 在 &#96;course&#96; 表里有课程 ) 教师的 &#96;name&#96; 和 &#96;department&#96; select name, department from teacher where no in (select t_no from course);mysql&gt; select name, department from teacher -&gt; where no in (select t_no from course);+--------+-----------------+| name | department |+--------+-----------------+| 李诚 | 计算机系 || 王萍 | 计算机系 || 刘冰 | 电子工程系 || 张旭 | 电子工程系 |+--------+-----------------+ 条件加组筛选查询 student 表中至少有 2 名男生的 class 1234567891011121314151617181920212223242526272829303132-- 查询 &#96;student&#96; 表中至少有 2 名男生的 &#96;class&#96; select * from student;mysql&gt; select * from student;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 200 | 王喜全 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+select class from student WHERE sex &#x3D; &#39;男&#39;group by class having count(sex) &gt; 1;mysql&gt; select class from student -&gt; WHERE sex &#x3D; &#39;男&#39; -&gt; group by class having count(sex) &gt; 1;+-------+| class |+-------+| 95031 || 95033 |+-------+ NOTLIKE 模糊查询取反查询 student 表中不姓 “王” 的同学记录 123456789101112131415-- NOT: 取反-- LIKE: 模糊查询select * from student where name not like &#39;王%&#39;;mysql&gt; select * from student where name not like &#39;王%&#39;;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 |+-----+-----------+-----+------------+-------+ YEAR 与 NOW 函数查询 student 表中每个学生的姓名和年龄 1234567891011121314151617181920212223242526272829-- 查询 &#96;student&#96; 表中每个学生的姓名和年龄-- select year(now())查询当前年份select year(now()); -- 查询当前年份mysql&gt; select year(now());+-------------+| year(now()) |+-------------+| 2020 |+-------------+-- 查询姓名，年龄select name, year(now())-year(birthday) as &#39;年龄&#39; from student;mysql&gt; select name, year(now())-year(birthday) as &#39;年龄&#39; from student;+-----------+--------+| name | 年龄 |+-----------+--------+| 曾华 | 43 || 匡明 | 45 || 王丽 | 44 || 李军 | 44 || 王芳 | 45 || 陆军 | 46 || 王尼玛 | 44 || 张全蛋 | 45 || 赵铁柱 | 46 || 王喜全 | 46 |+-----------+--------+ MAX 与 MIN 函数查询 student 表中最大和最小的 birthday 值 123456789-- 查询 &#96;student&#96; 表中最大和最小的 &#96;birthday&#96; 值select max(birthday), min(birthday) from student; -- 根据年份数值的大小mysql&gt; select max(birthday), min(birthday) from student;+---------------+---------------+| max(birthday) | min(birthday) |+---------------+---------------+| 1977-09-01 | 1974-06-03 |+---------------+---------------+ 多段排序以 class 和 birthday 从大到小的顺序查询 student 表 123456789101112131415161718-- 以 &#96;class&#96; 和 &#96;birthday&#96; 从大到小的顺序查询 &#96;student&#96; 表select * from student order by class desc, birthday;mysql&gt; select * from student order by class desc, birthday;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 200 | 王喜全 | 男 | 1974-06-03 | 95038 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 101 | 曾华 | 男 | 1977-09-01 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 102 | 匡明 | 男 | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+ 子查询 - 5查询 “男” 教师及其所上的课程 1234567891011121314151617181920212223242526272829303132333435363738394041-- 查询 &quot;男&quot; 教师及其所上的课程select * from teacher where sex &#x3D; &#39;男&#39;;mysql&gt; select * from teacher where sex &#x3D; &#39;男&#39;;+-----+--------+-----+------------+------------+-----------------+| no | name | sex | birthday | profession | department |+-----+--------+-----+------------+------------+-----------------+| 804 | 李诚 | 男 | 1958-12-02 | 副教授 | 计算机系 || 856 | 张旭 | 男 | 1969-03-12 | 讲师 | 电子工程系 |+-----+--------+-----+------------+------------+-----------------+-- 查询课程select * from course where t_no in (select no from teacher where sex &#x3D; &#39;男&#39;);mysql&gt; select * from course -&gt; where t_no in (select no from teacher where sex &#x3D; &#39;男&#39;);+-------+--------------+------+| no | name | t_no |+-------+--------------+------+| 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 |+-------+--------------+------+-- 显示教师姓名select teacher.name, course.name from teacher,course where t_no in (select no from teacher where sex &#x3D; &#39;男&#39;) and teacher.no &#x3D; course.t_no;mysql&gt; select teacher.name, course.name -&gt; from teacher,course -&gt; where t_no in (select no from teacher where sex &#x3D; &#39;男&#39;) -&gt; and teacher.no &#x3D; course.t_no;+--------+--------------+| name | name |+--------+--------------+| 李诚 | 操作系统 || 张旭 | 数字电路 |+--------+--------------+ MAX 函数与子查询查询最高分同学的 score 1234567891011121314151617181920212223242526272829303132333435363738-- 查询最高分同学的 &#96;score&#96; -- 查询最高成绩select max(degree) from score;mysql&gt; select max(degree) from score;+-------------+| max(degree) |+-------------+| 92 |+-------------+-- 查询学生select * from score where degree &#x3D; (select max(degree) from score);mysql&gt; select * from score -&gt; where degree &#x3D; (select max(degree) from score);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 |+------+-------+--------+-- 多表查询select student.name, score.s_no, degree from student,score where degree &#x3D; (select max(degree) from score)and student.no &#x3D; score.s_no;mysql&gt; select student.name, score.s_no, degree -&gt; from student,score -&gt; where degree &#x3D; (select max(degree) from score) -&gt; and student.no &#x3D; score.s_no;+--------+------+--------+| name | s_no | degree |+--------+------+--------+| 王丽 | 103 | 92 |+--------+------+--------+ 子查询 - 6查询和 “李军” 同性别的所有同学 name 12345678910111213141516171819202122232425262728293031-- 查询和 &quot;李军&quot; 同性别的所有同学 &#96;name&#96; -- 查询李军性别select sex from student where name &#x3D; &#39;李军&#39;;mysql&gt; select sex from student where name &#x3D; &#39;李军&#39;;+-----+| sex |+-----+| 男 |+-----+-- 查询同性别select name from student where sex &#x3D; (select sex from student where name &#x3D; &#39;李军&#39;);mysql&gt; select name from student -&gt; where sex &#x3D; (select sex from student where name &#x3D; &#39;李军&#39;);+-----------+| name |+-----------+| 曾华 || 匡明 || 李军 || 陆军 || 王尼玛 || 张全蛋 || 赵铁柱 || 王喜全 |+-----------+ 子查询 - 7查询和 “李军” 同性别且同班的同学 name 123456789101112131415-- 查询和 &quot;李军&quot; 同性别且同班的同学 &#96;name&#96;select name, class from student where sex &#x3D; (select sex from student where name &#x3D; &#39;李军&#39;)and class &#x3D; (select class from student where name &#x3D; &#39;李军&#39;);mysql&gt; select name, class from student -&gt; where sex &#x3D; (select sex from student where name &#x3D; &#39;李军&#39;) -&gt; and class &#x3D; (select class from student where name &#x3D; &#39;李军&#39;);+-----------+-------+| name | class |+-----------+-------+| 曾华 | 95033 || 李军 | 95033 || 王尼玛 | 95033 |+-----------+-------+ 子查询 - 8查询所有选修 “计算机导论” 课程的 “男” 同学成绩表 需要的 “计算机导论” 和性别为 “男” 的编号可以在 course 和 student 表中找到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 查询所有选修 &quot;计算机导论&quot; 课程的 &quot;男&quot; 同学成绩表-- 查询计算机导论select * from course where name &#x3D; &#39;计算机导论&#39;;mysql&gt; select * from course where name &#x3D; &#39;计算机导论&#39;;+-------+-----------------+------+| no | name | t_no |+-------+-----------------+------+| 3-105 | 计算机导论 | 825 |+-------+-----------------+------+-- 查询性别为男select * from student where sex &#x3D; &#39;男&#39;;mysql&gt; select * from student where sex &#x3D; &#39;男&#39;;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 200 | 王喜全 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 查询成绩表select * from score where c_no &#x3D; (select no from course where name &#x3D; &#39;计算机导论&#39;)and s_no in (select no from student where sex &#x3D; &#39;男&#39;);mysql&gt; select * from score -&gt; where c_no &#x3D; (select no from course where name &#x3D; &#39;计算机导论&#39;) -&gt; and s_no in (select no from student where sex &#x3D; &#39;男&#39;);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 104 | 3-105 | 89 || 109 | 3-105 | 76 |+------+-------+--------+ 按等级查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-- 建立一个 &#96;grade&#96; 表代表学生的成绩等级，并插入数据create table grade( low int(5), top int(5), grade char(1) );insert into grade values(90, 100, &#39;A&#39;);INSERT INTO grade VALUES (80, 89, &#39;B&#39;);INSERT INTO grade VALUES (70, 79, &#39;C&#39;);INSERT INTO grade VALUES (60, 69, &#39;D&#39;);INSERT INTO grade VALUES (0, 59, &#39;E&#39;);mysql&gt; select * from grade;+------+------+-------+| low | top | grade |+------+------+-------+| 90 | 100 | A || 80 | 89 | B || 70 | 79 | C || 60 | 69 | D || 0 | 59 | E |+------+------+-------+-- 查询所有学生的degree s_no 、c_no 和 grade 列select score.degree, score.s_no, score.c_no, grade from score, grade where degree between low and top;ysql&gt; select score.degree, score.s_no, score.c_no, grade -&gt; from score, grade -&gt; where degree between low and top;+--------+------+-------+-------+| degree | s_no | c_no | grade |+--------+------+-------+-------+| 90 | 101 | 3-105 | A || 91 | 102 | 3-105 | A || 92 | 103 | 3-105 | A || 86 | 103 | 3-245 | B || 85 | 103 | 6-166 | B || 89 | 104 | 3-105 | B || 88 | 105 | 3-105 | B || 75 | 105 | 3-245 | C || 79 | 105 | 6-166 | C || 76 | 109 | 3-105 | C || 68 | 109 | 3-245 | D || 81 | 109 | 6-166 | B |+--------+------+-------+-------+ mysql连接查询 准备数据：123456789101112131415161718192021222324252627282930313233343536CREATE DATABASE testJoin;CREATE TABLE person ( id INT, name VARCHAR(20), cardId INT);CREATE TABLE card ( id INT, name VARCHAR(20));INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);SELECT * FROM card;+------+-----------+| id | name |+------+-----------+| 1 | 饭卡 || 2 | 建行卡 || 3 | 农行卡 || 4 | 工商卡 || 5 | 邮政卡 |+------+-----------+INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);SELECT * FROM person;+------+--------+--------+| id | name | cardId |+------+--------+--------+| 1 | 张三 | 1 || 2 | 李四 | 3 || 3 | 王五 | 6 |+------+--------+--------+ 分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有 内连接inner join 或者 join 要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起 123456789101112select * from person inner join card on person.cardId &#x3D; card.id;mysql&gt; select * from person inner join card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id; 注意：card 的整张表被连接到了右边 外链接左外连接：left join 或者 left outer join 完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 123456789101112select * from person left join card on person.cardId &#x3D; card.id;mysql&gt; select * from person left join card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL |+------+--------+--------+------+-----------+-- left outer join，结果也是一样的 右外连接：right join 或者 right outer join 完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 1234567891011121314select * from person right join card on person.cardId &#x3D; card.id;mysql&gt; select * from person right join card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+-- right outer join，结果也是一样的 完全连接：full join 或者 full outer join 12345678910111213141516171819202122-- mysql 不支持全连接语法-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;-- 使用unionselect * from person left join card on person.cardId &#x3D; card.idunionselect * from person right join card on person.cardId &#x3D; card.id;mysql&gt; select * from person left join card on person.cardId &#x3D; card.id -&gt; union -&gt; select * from person right join card on person.cardId &#x3D; card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 事务在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。 123456-- 比如我们的银行转账：-- a -&gt; -100UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;-- b -&gt; +100UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;; 在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。 因此，在执行多条有关联 SQL 语句时，事务会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。 如何控制事务 - COMMIT / ROLLBACK在 MySQL 中，事务的自动提交状态默认是开启的 123456789-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;mysql&gt; SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 1 |+--------------+ 自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。 什么是回滚？举个例子： 1234567891011121314151617CREATE DATABASE bank;CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20), money INT);-- 插入数据INSERT INTO user VALUES (1, &#39;a&#39;, 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。 在 MySQL 中使用 ROLLBACK 执行回滚： 123456789101112-- 回滚到最后一次提交rollback;mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚： 设置AUTOCOMMIT = 0； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162-- 关闭自动提交-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SET AUTOCOMMIT &#x3D; 0;mysql&gt; SET AUTOCOMMIT &#x3D; 0;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@autocommit;+--------------+| @@autocommit |+--------------+| 0 |+--------------+-- 测试回滚INSERT INTO user VALUES (2, &#39;b&#39;, 1000);mysql&gt; INSERT INTO user VALUES (2, &#39;b&#39;, 1000);Query OK, 1 row affected (0.00 sec)mysql&gt; SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据commit;mysql&gt; INSERT INTO user VALUES (2, &#39;b&#39;, 1000);Query OK, 1 row affected (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+-- 发现回滚无效 总结： 自动提交 查看自动提交状态：SELECT @@AUTOCOMMIT ； 设置自动提交状态：SET AUTOCOMMIT = 0 。 手动提交 @@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。 事务回滚 @@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。 12345678910111213141516171819202122232425-- 测试银行转账update user set money &#x3D; money - 100 where id &#x3D; 1;update user set money &#x3D; money + 100 where id &#x3D; 2;mysql&gt; select * from user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 回滚：假设转账发生了意外，需要回滚rollback;mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 手动开启事务 - BEGIN / START TRANSACTION1234567891011-- 设置为自动提交set autocommit &#x3D; 1;select @@autocommit;mysql&gt; select @@autocommit;+--------------+| @@autocommit |+--------------+| 1 |+--------------+ 事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚： 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务: 12345678910111213141516171819202122232425262728-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务begin;update user set money &#x3D; money - 100 where id &#x3D; 1;update user set money &#x3D; money + 100 where id &#x3D; 2;mysql&gt; select * from user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 回滚rollback;mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+-- 用commit提交事务 事务的 ACID 特征与使用事务的四大特征： A(Atomicity)：原子性：事务是最小的单位，不可以再分割； C(Consistency)：一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败； I(Isolation)： 隔离性：事务1 和 事务2 之间是具有隔离性的； D(Durability)：持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) ； 事务的隔离性可分为四种 ( 性能从低到高 ) ： READ - UNCOMMITTED ( 读取未提交 ) 如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。 READ - COMMITTED ( 读取已提交 ) 只能读取到其他事务已经提交的数据。 REPEATABLE - READ ( 可被重复读 ) 如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。 SERIALIZABLE ( 串行化 ) 所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。 123456789101112131415161718192021222324252627-- 查看当前数据库的默认隔离级别：-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;-- MySQL 5.xmysql&gt; SELECT @@GLOBAL.TX_ISOLATION;+-----------------------+| @@GLOBAL.TX_ISOLATION |+-----------------------+| REPEATABLE-READ | -- MySQL的默认隔离级别，可以重复读。+-----------------------+-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)set global transaction isolation level READ COMMITTED;mysql&gt; set global transaction isolation level READ COMMITTED;Query OK, 0 rows affected (0.01 sec)mysql&gt; SELECT @@GLOBAL.TX_ISOLATION;+-----------------------+| @@GLOBAL.TX_ISOLATION |+-----------------------+| READ-COMMITTED |+-----------------------+ 脏读：READ UNCOMMITTED ( 读取未提交 ) 一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的； 如果此时 rollback ，之前操作的数据就会失效 不可重复读：读取已提交：READ - COMMITTED ( 读取已提交 ) 虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。这被称为不可重复读现象 ( READ COMMITTED ) 幻读：REPEATABLE - READ ( 可被重复读 ) 当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。 无论小张是否执行过 COMMIT ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录 1234567891011121314151617181920-- 小张 - 成都START TRANSACTION;INSERT INTO user VALUES (6, &#39;d&#39;, 1000);-- 小王 - 北京START TRANSACTION;-- 小张 - 成都COMMIT;SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+ 这是因为小王在此之前开启了一个新的事务 ( START TRANSACTION ) ，那么在他的这条新事务的线上，跟其他事务是没有联系的，也就是说，此时如果其他事务正在操作数据，它是不知道的。 然而事实是，在真实的数据表中，小张已经插入了一条数据 串行化：SERIALIZABLE ( 串行化 ) 1234567891011121314151617181920212223242526272829303132333435363738-- 设置隔离级别set global transaction isolation level SERIALIZABLE;mysql&gt; set global transaction isolation level SERIALIZABLE;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @@GLOBAL.TX_ISOLATION;+-----------------------+| @@GLOBAL.TX_ISOLATION |+-----------------------+| SERIALIZABLE |+-----------------------+-- 小张插入数据INSERT INTO user VALUES (7, &#39;hhh&#39;, 1000);mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 || 7 | hhh | 1000 |+----+------+-------+-- 小王查询mysql&gt; select * from user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 || 7 | hhh | 1000 |+----+------+-------+ 此时会发生什么呢？由于现在的隔离级别是 SERIALIZABLE ( 串行化 ) ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作 ( 这意味着队列中同时只能执行一个事务的写入操作 ) 。 根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 COMMIT 结束它所处的事务，或者出现等待超时。 所以性能较差","categories":[{"name":"mysql","slug":"mysql","permalink":"https://chrisxb1996.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://chrisxb1996.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"常用数据结构和算法","slug":"常用数据结构和算法","date":"2020-06-25T14:06:27.000Z","updated":"2020-06-28T14:50:45.647Z","comments":true,"path":"2020/06/25/常用数据结构和算法/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/25/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序算法冒泡排序 需要 array.length-1 轮的比较，可以通过优化标识来减少比较的次数，时间复杂度O(n^2) 12345678910111213141516171819public void bubbleSort(int[] array)&#123; int temp = 0; boolean flag = false;//优化标识 for(int j = 0; j&lt;array.length - 1; j++)&#123; for(int i = 0; i&lt;array.length - (j+1); i++)&#123; if(array[i] &gt; array[i+1])&#123; flag = true; temp = array[i]; array[i] = array[i+1]; array[i+1] = temp; &#125; &#125; if(flag)&#123;//发生过交换 flag = false; &#125;else&#123; break; &#125; &#125;&#125; 快速排序思路： 1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数。 1234567891011121314151617181920212223242526272829public void quickSort(int[] array, int i, int j)&#123; if(i &gt; j) &#123; return; &#125;else&#123; int index = getPosition(array, i, j); quickSort(array, i, index-1); quickSort(array, index+1, j); &#125; &#125;//1.找到基准对应的索引//2.对数据分成两部分，大于基准在右侧；小于基准在左侧public int getPosition(int[] array, int i, int j)&#123; int temp = array[j]; while(i &lt; j)&#123; while(array[i] &lt;= temp &amp;&amp; i &lt; j)&#123; i++; &#125; array[j] = array[i]; while(array[j] &gt; temp &amp;&amp; i &lt; j)&#123; j--; &#125; array[i] = array[j]; &#125; // 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置 array[i] = temp; return i;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"剑指offer-较难篇","slug":"剑指offer/剑指offer-较难篇","date":"2020-06-25T04:56:22.000Z","updated":"2020-06-25T14:14:57.515Z","comments":true,"path":"2020/06/25/剑指offer/剑指offer-较难篇/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/25/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer-%E8%BE%83%E9%9A%BE%E7%AF%87/","excerpt":"滑动窗口的最大值题目描述：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路：","text":"滑动窗口的最大值题目描述：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路： 12345678910111213141516171819202122232425public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)&#123; if (num == null || num.length == 0 || size &lt;= 0 || num.length &lt; size) &#123; return new ArrayList&lt;Integer&gt;(); &#125; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i = 0; i &lt; num.length; i++)&#123; while(!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt; num[i])&#123; queue.pollLast(); &#125; queue.addLast(i); //判断队首元素是否过期 if (queue.peekFirst() == i - size) &#123; queue.pollFirst(); &#125; //向result列表中加入元素 if (i &gt;= size - 1) &#123; res.add(num[queue.peekFirst()]); &#125; &#125; return res;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构和算法","slug":"剑指offer/数据结构和算法","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"java-基础","slug":"Java/Java-基础","date":"2020-06-16T14:54:27.000Z","updated":"2020-06-25T09:07:37.556Z","comments":true,"path":"2020/06/16/Java/Java-基础/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/16/Java/Java-%E5%9F%BA%E7%A1%80/","excerpt":"Java面向对象 面向对象：是一种程序设计的思想， 其基本思想是使用对象、类、封装、继承、多态等基本概念来进行程序设计。 三大特性： 封装：封装性就是尽可能的隐藏对象内部细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 可以通过对类的成员设置一定的访问权限，实现类中成员的信息隐藏。","text":"Java面向对象 面向对象：是一种程序设计的思想， 其基本思想是使用对象、类、封装、继承、多态等基本概念来进行程序设计。 三大特性： 封装：封装性就是尽可能的隐藏对象内部细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 可以通过对类的成员设置一定的访问权限，实现类中成员的信息隐藏。 优点：1.实现了高内聚，低耦合；2.提高系统的可扩展性、可维护性 继承： 子类的对象拥有父类的全部属性与方法，称作子类对父类的继承。 Java中父类可以拥有多个子类，但是子类只能继承一个父类，称为单继承。继承实现了代码的复用。 Java中所有的类都是通过直接或间接地继承java.lang.Object类得到的。 子类不能继承父类中访问权限为private的成员变量和方法。 子类可以重写父类的方法，即命名与父类同名的成员变量。 多态：对象的多态性是指在父类中定义的属性或方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为。 Java中多态体现在两个方面： 编译时多态：编译时多态主要指方法的重载 运行时多态：指的是方法的重写：产生运行时多态有三个条件：(1)继承；(2)方法重写；(3)父类引用指向子类对象； Java 和 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机(JVM)从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 JDK/JRE/JVM JVM：是java 虚拟机，当我们运行一个程序时，JVM 负责将Java源文件编译成能被Java虚拟机执行的字节码文件。除此之外，JVM 提供了内存管理/ 垃圾回收和安全机制等。 JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。 JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。 Java数据类型以及自动拆箱/装箱Java语言支持的数据类型包括两种： 基本数据类型： byte：1字节(8位) short(2)：2字节(16位) char(2)：2字节(16位) int(4)：4字节(32位) float(4)：4字节(32位) long(8)：8字节(64位) double(8)：8字节(64位) Boolean(1)：true、false，可以使用 1 位(bit) 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 java采用Unicode编码，不论汉字、字母、数字，每个字符都占用2字节。 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。反之就是自动拆箱。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程。 12Integer x = 2; // 装箱 调用了 Integer.valueOf(2)int y = x; // 拆箱 调用了 X.intValue() Java容器容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection 注：List是有序可重复元素集合，Set是无序不可重复元素集合； Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。 List ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 迭代器模式 Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。注意：iterator()方法是java.lang.Iterable接口的方法，被Collection继承。 (2) 使用hasNext()检查序列中是否还有元素。 (3) 使用next()获得序列中的下一个元素。 (4) 使用remove()将迭代器新返回的元素删除。 Iterator只能正向遍历集合，适用于获取移除元素。ListIterator继承自Iterator，专门针对List，可以从两个方向来遍历List，同时支持元素的修改(插入和删除)。从 JDK 1.5 之后可以使用 for each方法来遍历实现了 Iterable 接口的聚合对象。 源码分析ArrayList ArrayList 是基于数组实现的，所以支持快速随机访问。 数组的默认大小为 10。 1private static final int DEFAULT_CAPACITY = 10; 扩容： oldCapacity + (oldCapacity &gt;&gt; 1)，为旧容量的 1.5 倍，扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，操作代价很高。 删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。 Vector 同步：它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。 与ArrayList比较： （1）Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； （2）Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。 替代方案：可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); CopyOnWriteArrayList 读写分离：写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组。 优缺点： 优点：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能。 缺点： 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 适用场景：适合读多写少的应用场景，不适合内存敏感以及对实时性要求很高的场景。 LinkedList ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别： 数组支持随机访问，但插入删除的代价很高，需要移动大量元素； 链表不支持随机访问，但插入删除只需要改变指针。 HashMap 内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。 拉链法 1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"K1\", \"V1\");map.put(\"K2\", \"V2\");map.put(\"K3\", \"V3\"); （1）新建一个 HashMap，默认大小为 16 （2）插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 113，使用除留余数法得到所在的桶下标 113%16=1。 （3）插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 120，使用除留余数法得到所在的桶下标 120%16=8。 （4）插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 120，使用除留余数法得到所在的桶下标 120%16=8，插在 &lt;K2,V2&gt; 前面。（注意：头插法） 扩容 当需要扩容时，令 capacity 为原来的两倍。扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。 链表转红黑树 从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。 与HashTable比较 （1）Hashtable 使用 synchronized 来进行同步。 （2）HashMap 可以插入键为 null 的 Entry。(HashMap 使用第 0 个桶存放键为 null 的键值对) （3）HashMap 的迭代器是 fail-fast 迭代器。 （4）HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 ConcurrentHashMap ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。 size操作：ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。 JDK1.8后改动： JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。 JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。 Java泛型Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。 Java并发为什么要使用多线程多线程并不一定能提升性能（甚至还会降低性能）；多线程也不只是为了提升性能。多线程主要有以下的应用场景： 避免阻塞（异步调用） 单个线程中的程序，是顺序执行的。如果前面的操作发生了阻塞，那么就会影响到后面的操作。这时候可以采用多线程，我感觉就等于是异步调用。这样的例子有很多：eg.ajax调用，就是浏览器会启一个新的线程，不阻塞当前页面的正常操作。 避免CPU空转 以web请求为例，处理完一条请求，再处理下一条请求的话，CPU会存在大量的闲置时间。因为处理一条请求，经常涉及到RPC、数据库访问、磁盘IO等操作，这些操作的速度比CPU慢很多，而在等待这些响应的时候，CPU却不能去处理新的请求，因此都采用对每个请求创建新线程来响应的方式实现，这样在等待IO操作的等待时间里，就可以去继续处理其他请求，对并发的响应性就好了很多。 提升性能 在满足条件的前提下，多线程确实能提升性能。多核CPU才行 进程和线程进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 进程是资源分配的最小单位，它使用独立的数据空间；线程是程序执行的最小单位，它共享进程的数据结构。 使用线程的三种方法 实现Runnable接口 1.创建：实现Runnable接口 + 重写run() 2.启动：创建实现类对象 + Thread对象 + start 12345678910111213141516171819public class StartRun implements Runnable &#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(\"一边听歌\"); &#125; &#125; public static void main(String[] args) &#123; new Thread(new StartRun()).start(); for(int i=0;i&lt;10;i++) &#123; System.out.println(\"一边敲代码\"); &#125; &#125;&#125; 继承Thread类 1.创建：继承Thread + 重写run() 2.启动：创建子类对象 + start 1234567891011121314151617181920212223public class StartThread extends Thread &#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(\"一边听歌\"); &#125; &#125; public static void main(String[] args) &#123; //启动线程 //1.创建子类对象 StartThread st = new StartThread(); //2.调用start st.start(); //交给cpu，形成两条路径，但start方法不保证立即运行，由cpu去调用 for(int i=0;i&lt;10;i++) &#123; System.out.println(\"一边敲代码\"); &#125; &#125; &#125; 实现Callable接口 与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装，并且抛出异常。 12345678910111213public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get()); &#125;&#125; 推荐实现接口：避免单继承的局限性，优先使用接口，方便共享资源。 基础线程机制 线程池： 装有线程的池子，我们可以把要执行的多线程交给线程池来处理，和连接池的概念一样。使用实现了Executor接口的ThreadPoolExecutor来创建线程池。通过维护一定数量的线程池来达到多个线程的复用。（为了减少在创建和销毁线程上所花的时间以及系统资源的开销）。 主要有三种 Executor： CachedThreadPool：一个任务创建一个线程； FixedThreadPool：所有任务只能使用固定大小的线程； SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。 守护线程(Daemon)： 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 main() 属于非守护线程。 在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。 sleep(): Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。使线程停止运行一段时间，将处于阻塞状态。 如果调用了sleep方法之后，没有其他等待执行的线程，这个时候当前线程不会马上恢复执行！ sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。 12345try &#123; Thread.sleep(100);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; yield(): yield:礼让线程，暂停线程直接进入就绪状态，不是阻塞状态。 如果调用了yield方法之后，没有其他等待执行的线程，这个时候当前线程就会马上恢复执行！ synchronized和ReentrantLockJava 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。 synchronized： 同步一个代码块：同一个对象 同步一个方法：同一个对象 同步一个类：两个线程调用该类的不同对象上的这种同步语句，也会进行同步 同步一个静态方法：作用于整个类 ReentrantLock： ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁 比较： 锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。 公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象 除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 线程中的相互协作join()： 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，直到目标线程结束。 虽然 b 线程先启动，但是如果在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。 wait()： 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 注意： 使用 wait() 挂起期间，线程会释放锁，而sleep() 不会； wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； 线程状态 Java I/O分类Java 的 I/O 大概可以分成以下几类： 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO 磁盘操作File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。 递归地列出一个目录下的所有 文件 123456789101112public void show(File dir)&#123; if(dir == null &amp;&amp; !dir.exists)&#123; return; &#125; if(dir.isFile())&#123; System.out.println(dir.getName()); return; &#125; for(File f : dir.listFiles())&#123; show(f); &#125;&#125; 字节操作 InputStream Java I/O 使用了装饰者模式来实现。以 InputStream 为例， InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可 字符操作 编码与解码：编码就是把字符转换为字节，而解码是把字节重新组合成字符。 GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节；(Java：Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。) Reader和Writer InputStreamReader 实现从字节流解码成字符流；(转换流) OutputStreamWriter 实现字符流编码成为字节流。(转换流) 从JDK文档中可以知道FileOutputStream是OutputStream的直接子类，FileInputStream也是InputStream的直接子类，但是在字符流文件的两个操作类却有一些特殊，FileWriter并不直接是Writer的子类，而是OutputStreamWriter的子类，而FileReader也不直接是Reader的子类，而是InputStreamReader的子类，那么从这两个类的继承关系就可以清楚的发现，不管是是使用字节流还是字符流实际上最终都是以字节形式操作输出流的。 ### 对象操作序列化： 序列化就是将一个对象转换成字节序列，方便存储和传输。 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() 不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。 Serializable： 序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。 transient： java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 ArrayList 中存储数据的数组 elementData 是用 transient 修饰的 1private transient Object[] elementData; 通过一些重写的方法，只序列化数组中有内容的那部分数据 网络操作Java 中的网络支持： InetAddress：用于表示网络上的硬件资源，即 IP 地址； URL：统一资源定位符； Sockets：使用 TCP 协议实现网络通信； Datagram：使用 UDP 协议实现网络通信。 从URL读取字节数据： 12345678910111213141516171819public static void main(String[] args) throws IOException &#123; URL url = new URL(\"http://www.baidu.com\"); /* 字节流 */ InputStream is = url.openStream(); /* 字符流 */ InputStreamReader isr = new InputStreamReader(is, \"utf-8\"); /* 提供缓存功能 */ BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; br.close();&#125; Sockets： ServerSocket：服务器端类 Socket：客户端类 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。 NIONIO即New IO，这个库是在JDK1.4 中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，NIO主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 流与块： I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。 面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 通道和缓冲区： 通道 Channel： 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。 通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。 缓冲区：发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。 缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。 缓冲区状态变量： 1.capacity：最大容量； 2.position：当前已经读写的字节数； 3.limit：还可以读写的字节数。 选择器与非阻塞I/O： NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。 NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。 NIO 与 IO 主要区别： NIO 面向块，IO 面向流 NIO 非阻塞，IO 阻塞 Java虚拟机参考资料Cyc2018 ：https://cyc2018.github.io/CS-Notes/#/README","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"}]},{"title":"剑指offer-中等篇","slug":"剑指offer/剑指offer-中等篇","date":"2020-06-10T13:03:53.000Z","updated":"2020-06-25T14:15:06.587Z","comments":true,"path":"2020/06/10/剑指offer/剑指offer-中等篇/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/10/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer-%E4%B8%AD%E7%AD%89%E7%AF%87/","excerpt":"剪绳子题目描述：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0] x k[1] x … x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 思路： 5&lt;2x3，6&lt;3x3，比6更大的数字我们就更不用考虑了，肯定要继续分。 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2x2x2 &lt; 3x3，那么题目就简单了。 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。","text":"剪绳子题目描述：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0] x k[1] x … x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 思路： 5&lt;2x3，6&lt;3x3，比6更大的数字我们就更不用考虑了，肯定要继续分。 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2x2x2 &lt; 3x3，那么题目就简单了。 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。 123456789101112131415public int cutRope(int target) &#123; if(target == 2) return 1; if(target == 3) return 2; int x = target % 3; int y = target / 3; if(x == 0)&#123; return (int)Math.pow(3,y); &#125;else if(x == 1)&#123;//7%3=2···1 2*2*3 return 2*2*(int)Math.pow(3,y-1); &#125;else&#123;//8%3=2···2 3*3*2 return 2*(int)Math.pow(3,y); &#125;&#125; 把二叉树打印成多行题目描述：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路：用队列实现二叉树的层次遍历(标准写法) 123456789101112131415161718ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; if(pRoot == null) return new ArrayList(); ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt; &gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); while(!queue.isEmpty())&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int count = queue.size(); for(int i = 0; i&lt;count; i++)&#123; TreeNode node = queue.poll(); list.add(node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); &#125; res.add(list); &#125; return res;&#125; 二叉树的下一个结点题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路：判断当前节点的右子节点是否为空 123456789101112131415161718public TreeLinkNode GetNext(TreeLinkNode pNode)&#123; if(pNode.right != null)&#123;//当前节点右子节点不为空 TreeLinkNode node = pNode.right; while(node.left != null)&#123;//找到右子节点的最底层左子节点 node = node.left; &#125; return node; &#125;else&#123;//当前节点右子节点为空 while(pNode.next != null)&#123; TreeLinkNode parent = pNode.next;//指向当前节点的父节点 if(parent.left == pNode)&#123;//判断当前节点是否为父节点的左子节点 return parent; &#125; pNode = pNode.next; &#125; &#125; return null;&#125; 链表中环的入口结点题目描述：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路： 12345678910111213141516public ListNode EntryNodeOfLoop(ListNode pHead)&#123; if(pHead == null || pHead.next == null) return null; ListNode fast = pHead; ListNode slow = pHead; do&#123; fast = fast.next.next; slow = slow.next; &#125;while(slow != fast); fast = pHead; while(fast != slow)&#123; fast = fast.next; slow = slow.next; &#125; return fast;&#125; 字符流中第一个不重复的字符题目描述：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 如果当前字符流没有存在出现一次的字符，返回 # 字符。 思路：用数组统计字符出现的次数，并将字符按顺序加入队列，如果队列中字符出现的次数大于1，则出队；如果最后队列不为空，则出队的字符就是第一个出现的字符。 123456789101112131415161718public class Solution &#123; //Insert one char from stringstream int[] counts = new int[256]; private Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;(); public void Insert(char ch)&#123; counts[ch]++; queue.add(ch); while(!queue.isEmpty() &amp;&amp; counts[queue.peek()] &gt; 1)&#123; queue.poll(); &#125; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce()&#123; return queue.isEmpty() ? '#' : queue.peek(); &#125;&#125; 数组中重复的数字题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路： 12345678910111213141516171819public boolean duplicate(int numbers[],int length,int [] duplication)&#123; if(numbers == null || numbers.length == 1) return false; for(int i = 0;i&lt;numbers.length; i++)&#123; while(numbers[i] != i)&#123; if(numbers[i] == numbers[numbers[i]])&#123; duplication[0] = numbers[i]; return true; &#125; swap(numbers, i, numbers[i]); &#125; &#125; return false;&#125;public static void swap(int numbers[],int i,int j)&#123; int temp = numbers[i]; numbers[i] = numbers[j]; numbers[j] = temp;&#125; 求1+2+3+…+n题目描述：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 思路：利用逻辑与得短路特性做为递归的终止条件。 12345public int Sum_Solution(int n) &#123; int sum = n; boolean flag = n &gt; 0 &amp;&amp; (sum += Sum_Solution(n-1)) &gt; 0; return sum;&#125; 孩子们的游戏(圆圈中最后剩下的数)题目描述：让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0…m-1 报数 …. 这样下去 …. 直到剩下最后一个小朋友，可以不用表演。 思路：约瑟夫环，用链表来模拟游戏过程； 1234567891011121314public int LastRemaining_Solution(int n, int m) &#123; if(n == 0) return -1; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for(int i = 0; i&lt;n; i++)&#123; list.add(i); &#125; int beginIndex = 0; while(list.size() &gt; 1)&#123; beginIndex = (beginIndex + m-1)%list.size();//循环 list.remove(beginIndex); &#125; return list.get(0);&#125; 扑克牌顺子题目描述：LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 思路：先统计大小王的个数，当成赖子，通过对抽到的牌进行排序，判断是否能 组成顺子。 1234567891011121314151617181920public boolean isContinuous(int [] numbers) &#123; if(numbers.length == 0) return false; int count = 0; Arrays.sort(numbers); //统计大小王个数 while(numbers[count] == 0)&#123; count++; &#125; //判断是否能组成顺子 for(int i = count; i&lt;numbers.length-1; i++)&#123; //如果重复的牌，则一定不能组成顺子 if(numbers[i+1] == numbers[i])&#123; return false; &#125; count = count - (numbers[i+1]-numbers[i]-1); &#125; return count &gt;= 0;&#125; 左旋转字符串题目描述：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路：1.先分别反转字符串；2.再整体反转； 12345678910111213141516171819public String LeftRotateString(String str,int n) &#123; if(str == null || str.length() &lt;= n) return str; char[] chars = str.toCharArray(); swapString(chars, 0, n-1); swapString(chars, n, chars.length-1); swapString(chars, 0, chars.length-1); return new String(chars);&#125;//反转从 i 到 j 的字符串public void swapString(char[] str,int i,int j)&#123; while(i &lt; j)&#123; char temp = str[i]; str[i] = str[j]; str[j] = temp; i++; j--; &#125;&#125; 和为S的两个数字题目描述：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。对应每个测试案例，输出两个数，小的先输出。 思路：利用双指针，从头和尾分别进行遍历判断（和相同时，两数差距越大，乘积越小） 1234567891011121314151617public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int i = 0; int j = array.length-1; while(i &lt; j)&#123; if(array[i] + array[j] == sum)&#123; res.add(array[i]); res.add(array[j]); return res; &#125;else if(array[i] + array[j] &lt; sum)&#123; i++; &#125;else&#123; j--; &#125; &#125; return res;&#125; 和为S的连续正数序列题目描述：小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 思路： 12345678910111213141516171819202122public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt; &gt;(); int L = 1; int R = 2; int curSum = 0; while(L &lt; R)&#123; curSum = (L + R)*(R - L + 1)/2; if(curSum == sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i = L; i&lt;=R; i++)&#123; list.add(i); &#125; res.add(list); L++; &#125;else if(curSum &lt; sum)&#123; R++; &#125;else&#123; L++; &#125; &#125; return res;&#125; 数组中只出现一次的数字题目描述：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路：把所有的数异或，得到的结果即两个不同的数异或的结果，这个结果的二进制中的1，表现的是这两个不同的数的不同位。就按照这个结果中为1的位的位置划分，该位为1划分为一组，为0划分为一组。这样两个不同的数就被划分开了，再分别对这两组做异或操作，就找到了两个不同的数。 1234567891011121314151617181920212223242526272829303132333435public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; int binaryRes = 0; for(int i = 0; i&lt;array.length; i++)&#123; binaryRes = binaryRes ^ array[i]; &#125; int index = getIndex1(binaryRes); for(int num : array)&#123; if(is1Index(num, index))&#123; num1[0] = num1[0] ^ num; &#125;else&#123; num2[0] = num2[0] ^ num; &#125; &#125;&#125;/*** 返回 binaryRes 中第一位为1的位置*/private int getIndex1(int binaryRes)&#123; int index = 0; while(((binaryRes &amp; 1) == 0) &amp;&amp; index &lt; 32)&#123; binaryRes = binaryRes&gt;&gt; 1; index++; &#125; return index; &#125;/*** 判断 num 的 index 位置是否为1*/private boolean is1Index(int num, int index)&#123; //index 位为1，则返回true return ((num &gt;&gt; index) &amp; 1) == 1;&#125; 平衡二叉树题目描述：输入一棵二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 思路:递归得到二叉树的高度，判断左子树与右子树的高度差，如果高度差超过1，则返回false 1234567891011121314151617public class Solution &#123; private boolean isBalanced = true; public boolean IsBalanced_Solution(TreeNode root) &#123; depth(root); return isBalanced; &#125; private int depth(TreeNode root)&#123; if(root == null) return 0; int leftDepth = depth(root.left); int rightDepth = depth(root.right); if(Math.abs(leftDepth - rightDepth) &gt; 1)&#123; isBalanced = false; &#125; return Math.max(leftDepth,rightDepth)+1; &#125;&#125; 数字在排序数组中出现的次数题目描述：统计一个数字在排序数组中出现的次数。 思路：有序数组，可以利用二分法 12345678910111213141516171819202122232425262728293031public int GetNumberOfK(int [] array , int k) &#123; //int res = 0; //for(int num : array)&#123; // if(num == k) res++; // &#125; // return res; if(array.length == 0) return 0; int left = binarySearch(array, k); int right = binarySearch(array, k+1); if(array[array.length-1] == k)&#123; return right-left+1; &#125;else&#123; return right-left; &#125;&#125;//返回数组中target中最左边的位置索引public int binarySearch(int[] nums, int target) &#123; int i = 0; int j = nums.length - 1; int mid = 0; while(i &lt; j)&#123; mid = i + (j-i)/2; if(nums[mid] &lt; target)&#123; i = mid + 1; &#125;else&#123; j = mid; &#125; &#125; return i;&#125; 两个链表的第一个公共结点题目描述：输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 思路：路程相等思想：当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 1234567891011public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode a = pHead1; ListNode b = pHead2; while(a != b)&#123; a = a == null ? pHead2 : a.next; b = b == null ? pHead1 : b.next; &#125; return a;&#125; 数组中出现次数超过一半的数字题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路：法1：对数组进行排序，中间的数一定是出现次数超过数组长度一般的数，否则返回0；法2：用HashMap统计每个数字出现的次数； 123456789101112131415//方法一，时间复杂度nlognpublic int MoreThanHalfNum_Solution(int [] array) &#123; Arrays.sort(array); int mid = array[array.length/2]; int count = 0; for(int i = 0;i&lt;array.length;i++)&#123; if(array[i] == mid)&#123; count++; &#125; &#125; return count&gt;(array.length/2) ? mid : 0;&#125; 1234567891011121314151617181920//方法二，时间复杂度npublic int MoreThanHalfNum_Solution(int [] array) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i&lt;array.length; i++)&#123; if(!map.containsKey(array[i]))&#123; map.put(array[i],1); &#125;else&#123; int count = map.get(array[i]); map.put(array[i],++count); &#125; &#125; for(int key : map.keySet())&#123; int count = map.get(key); if(count &gt; array.length/2)&#123; return key; &#125; &#125; return 0;&#125; 二叉搜索树与双向链表题目描述：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路：中序遍历结果就是排序结果；中序递归； 123456789101112131415161718private TreeNode pre = null;private TreeNode head = null;public TreeNode Convert(TreeNode root) &#123; inOrder(root); return head;&#125;private void inOrder(TreeNode node) &#123; if (node == null) return; inOrder(node.left); node.left = pre; if (pre != null) pre.right = node; pre = node; if (head == null) head = node; inOrder(node.right);&#125; 栈的压入、弹出序列题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路：用栈来模拟题目描述的过程； 1234567891011121314public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length == 0 || popA.length == 0) return false; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int index = 0; for(int i = 0; i &lt; pushA.length; i++ )&#123; stack.push(pushA[i]); while(!stack.isEmpty() &amp;&amp; stack.peek() == popA[index])&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty();&#125; 合并两个排序的链表题目描述：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 123456789101112131415161718192021public ListNode Merge(ListNode list1,ListNode list2) &#123; ListNode newHead = new ListNode(-1); ListNode temp = newHead; while(list1 != null &amp;&amp; list2 != null)&#123; if(list1.val &lt; list2.val)&#123; temp.next = list1; temp = temp.next; list1 = list1.next; &#125;else&#123; temp.next = list2; temp = temp.next; list2 = list2.next; &#125; &#125; //如果 后续还有节点，直接接在新链表的末尾即可 if(list1 != null) temp.next = list1; if(list2 != null) temp.next = list2; return newHead.next;&#125; 反转链表题目描述：输入一个链表，反转链表后，输出新链表的表头。 思路：头插法： 123456789101112public ListNode ReverseList(ListNode head) &#123; //头插法 ListNode newHead = new ListNode(-1); while(head != null)&#123; ListNode next = head.next; head.next = newHead.next; newHead.next = head; head = next; &#125; return newHead.next;&#125; 数值的整数次方题目描述：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0。 思路：法1：暴力法；法2：递归法，时间复杂度logN； 1234567891011121314public double Power(double base, int exponent) &#123; double res = 1; if(exponent&gt;0)&#123; for(double i = 0;i&lt;exponent;i++)&#123; res = res*base; &#125; &#125;else&#123; for(double i = exponent;i&lt;0;i++)&#123; res = res*base; &#125; res = 1/res; &#125; return res;&#125; 123public double Power(double base, int exponent) &#123; &#125; 二进制中1的个数题目描述：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路：n&amp;(n-1)：相当于把n二进制最后的1变为0 123n : 10110100n-1 : 10110011n&amp;(n-1) : 10110000 12345678public int NumberOf1(int n) &#123; int res = 0; while(n != 0)&#123; res++; n = n&amp;(n-1); &#125; return res;&#125; 矩形覆盖题目描述：我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 比如n=3时，2*3的矩形块有3种覆盖方法： 思路：斐波那契数列 1234567891011public int RectCover(int target) &#123; int pre = 0; int cur = 1; int res = 0; for(int i = 1; i&lt;=target; i++)&#123; res = pre + cur; pre = cur; cur = res; &#125; return res;&#125; 跳台阶题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路：斐波那契数列：跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶，故有递推公式f(n) = f(n-1) + f(n-2) 1234567891011public int JumpFloor(int target) &#123; int pre = 0; int cur = 1; int res = 0; for(int i = 1; i&lt;=target; i++)&#123; res = pre + cur; pre = cur; cur = res; &#125; return res;&#125; 斐波那契数列题目描述：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 思路：斐波那契数列：f(n) = f(n-1) + f(n-2) 123456789101112public int Fibonacci(int n) &#123; if(n &lt;= 1) return n; int res = 0; int pre = 0; int cur = 1; for(int i = 2;i&lt;=n;i++)&#123; res = pre + cur; pre = cur; cur = res; &#125; return res;&#125; 旋转数组的最小数字题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路：采用二分法；若中间的元素大于 j 指针的元素，说明旋转点在 mid 和 j 之间；否则在 i 和 mid 之间； 特例：如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。 1234567891011121314151617181920212223public int minNumberInRotateArray(int [] array) &#123; if(array.length == 0) return 0; int i = 0; int j = array.length - 1; while(i &lt; j)&#123; int mid = i + (j - i)/2; if(array[mid] == array[i] &amp;&amp; array[mid] == array[j])&#123; for(int k = 0; k&lt;array.length-1; k++)&#123; if(array[k] &gt; array[k+1] ) &#123; return array[k+1]; &#125; &#125; return array[0]; &#125; if(array[mid] &gt; array[j])&#123; i = mid + 1; &#125;else&#123; j = mid; &#125; &#125; return array[i];&#125; 重建二叉树题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路：","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构和算法","slug":"剑指offer/数据结构和算法","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer-简单篇","slug":"剑指offer/剑指offer-简单篇","date":"2020-06-07T09:02:50.000Z","updated":"2020-06-25T14:15:11.909Z","comments":true,"path":"2020/06/07/剑指offer/剑指offer-简单篇/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/07/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer-%E7%AE%80%E5%8D%95%E7%AF%87/","excerpt":"构建乘积数组题目描述：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）","text":"构建乘积数组题目描述：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];） 思路：1.//从左向右累乘A[0]A[1]…A[i-1]；2.//从右向左累乘A[i+1]…A[n-1] 123456789101112131415161718public int[] multiply(int[] A) &#123; //从左向右累乘A[0]A[1]...A[i-1] int n = A.length; int[] B = new int[n]; int temp = 1; for(int i = 0;i&lt;n;i++)&#123; B[i] = temp; temp = temp*A[i]; &#125; //从右向左累乘A[i+1]...A[n-1] temp = 1; for(int i = n-1;i&gt;=0;i--)&#123; B[i] = B[i]*temp; temp = temp*A[i]; &#125; return B;&#125; 不用加减乘除做加法题目描述：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路：1.不考虑进位：异或操作：^ ；例如：101^111 = 010;​ 2.计算进位值：与操作：&amp;，再左移一位；例如：101&amp;111&lt;&lt;1 = 101&lt;&lt;1 = 1010；​ 3.重复上述两步，直到进位值全为0，返回结果； 123456789public int Add(int num1,int num2) &#123; while(num2 != 0) &#123; int temp = num1 ^ num2; int carry = (num1 &amp; num2) &lt;&lt; 1; num1 = temp; num2 = carry; &#125; return num1;&#125; 二叉树的深度题目描述：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路：递归：结束条件：根节点位空 1234567public int TreeDepth(TreeNode root) &#123; if(root == null) return 0; int left = TreeDepth(root.left); int right = TreeDepth(root.right); return Math.max(left,right)+1;&#125; 二叉树的镜像题目描述：操作给定的二叉树，将其变换为源二叉树的镜像。 思路：递归：结束条件：根节点位空 12345678public void Mirror(TreeNode root) &#123; if(root == null) return; if(root.left != null) Mirror(root.left); if(root.right != null) Mirror(root.right); TreeNode temp = root.left; root.left = root.right; root.right = temp; &#125; 变态跳台阶题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路：推导： 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去…，那么: 1f(n-1) &#x3D; f(n-2) + f(n-3) + ... + f(0) 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去… ，那么: 1f(n) &#x3D; f(n-1) + f(n-2) + ... + f(0) 两式相减得到： 1f(n) &#x3D; 2*f(n-1) &#x3D; 2*2*f(n-2) &#x3D;...&#x3D; 2^(n-1)*f(1) &#x3D; 2^(n-1) 1234567public int JumpFloorII(int target) &#123; if(target == 0)&#123; return -1; &#125;else&#123; return (int)Math.pow(2,target-1); &#125;&#125; 用两个栈实现队列题目描述：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路：注意：stack2中有元素时，不能入栈，直接pop出元素即可； 必须stack2为空时，才能入栈； 12345678910111213141516171819public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; int node = stack1.pop(); stack2.push(node); &#125; &#125; return stack2.pop(); &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构和算法","slug":"剑指offer/数据结构和算法","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"SpringBoot","slug":"SpringBoot","date":"2020-06-02T07:43:35.000Z","updated":"2020-06-02T08:11:21.766Z","comments":true,"path":"2020/06/02/SpringBoot/","link":"","permalink":"https://chrisxb1996.github.io/2020/06/02/SpringBoot/","excerpt":"","text":"日志SLF4J + logback 如何让系统中所有的日志都统一到slf4j； 1、将系统中其他日志框架先排除出去； 2、用中间包来替换原有的日志框架； 3、我们导入slf4j其他的实现；","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://chrisxb1996.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chrisxb1996.github.io/tags/SpringBoot/"}]},{"title":"Leetcode 167.两数之和 II - 输入有序数组","slug":"Leetcode/Leetcode-167-两数之和-II-输入有序数组","date":"2020-05-27T14:52:47.000Z","updated":"2020-05-27T15:01:31.720Z","comments":true,"path":"2020/05/27/Leetcode/Leetcode-167-两数之和-II-输入有序数组/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/27/Leetcode/Leetcode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"167：给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 123456789101112131415161718192021class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; if(numbers.length &lt; 2) return null; int[] res = new int[2]; int i = 0; int j = numbers.length-1; while(i &lt; j)&#123; if(numbers[i] + numbers[j] == target)&#123; res[0] = i+1; res[1] = j+1; i++; j--; &#125;else if(numbers[i] + numbers[j] &lt; target)&#123; i++; &#125;else&#123; j--; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chrisxb1996.github.io/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chrisxb1996.github.io/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"设计模式-观察者模式","slug":"设计模式/设计模式-观察者模式","date":"2020-05-21T07:37:11.000Z","updated":"2020-05-21T16:00:22.230Z","comments":true,"path":"2020/05/21/设计模式/设计模式-观察者模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"适用于广播场景机制 ：• 聊天室程序的创建。服务器创建好后，A,B,C三个客户端连上来公开聊天。A向服务器发送数据，服务器端聊天数据改变。我们希望将这些聊天数据分别发给其他在线的客户。也就是说，每个客户端需要更新服务器端得数据。• 网站上，很多人订阅了”java主题”的新闻。当有这个主题新闻时，就会将这些新闻发给所有订阅的人。• 玩CS游戏时，服务器需要将每个人的方位变化发给所有的客户。","text":"适用于广播场景机制 ：• 聊天室程序的创建。服务器创建好后，A,B,C三个客户端连上来公开聊天。A向服务器发送数据，服务器端聊天数据改变。我们希望将这些聊天数据分别发给其他在线的客户。也就是说，每个客户端需要更新服务器端得数据。• 网站上，很多人订阅了”java主题”的新闻。当有这个主题新闻时，就会将这些新闻发给所有订阅的人。• 玩CS游戏时，服务器需要将每个人的方位变化发给所有的客户。 我们可以把多个订阅者、客户称之为观察者； 需要同步给多个订阅者的数据封装到对象中，称之为目标。 核心：观察者模式主要用于1：N的通知。当一个对象(目标对象Subject，消息发布)的状态变化时，他需要及时告知一系列对象(观察者对象Observer，消息订阅)，令他们做出响，通知观察者的方式主要是推和拉：• 推：每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接收。• 拉：观察者只要直到有情况即可。至于什么时候获取内容，获取什么内容，都可以自主决定。 代码实现： 1234567891011121314151617181920public interface Observer &#123; void update(Subject subject);&#125;public class ObserverA implements Observer&#123; private int myState; @Override public void update(Subject subject) &#123; myState = ((ConcreteSubject)subject).getState(); &#125; public void setMyState(int myState) &#123; this.myState = myState; &#125; public int getMyState() &#123; return myState; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class Subject &#123; protected List&lt;Observer&gt; list = new ArrayList&lt;&gt;(); public void registerObserver(Observer observer)&#123; list.add(observer); &#125; public void deletObserver(Observer observer)&#123; list.remove(observer); &#125; //通知 所有观察者更新状态 public void notifyAllObservers()&#123; for (Observer o : list) &#123; o.update(this); &#125; &#125;&#125;/***具体目标类*/public class ConcreteSubject extends Subject&#123; private int state; public void setState(int state) &#123; this.state = state; //目标值发生变换，通知所有的观察者 this.notifyAllObservers(); &#125; public int getState() &#123; return state; &#125;&#125; 123456789101112131415161718192021public class test &#123; public static void main(String[] args) &#123; ConcreteSubject concreteSubject = new ConcreteSubject(); //创建多个观察者 ObserverA o1 = new ObserverA(); ObserverA o2 = new ObserverA(); ObserverA o3 = new ObserverA(); //添加到subject的观察者队伍中 concreteSubject.registerObserver(o1); concreteSubject.registerObserver(o2); concreteSubject.registerObserver(o3); //一次更新，所有观察者都改变状态！！！ concreteSubject.setState(300); System.out.println(o1.getMyState()); System.out.println(o2.getMyState()); System.out.println(o3.getMyState()); &#125;&#125; • 开发中常见的场景： 聊天室程序的，服务器转发给所有客户端 网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发 邮件订阅 Servlet中，监听器的实现 Android中，广播机制 JDK的AWT中事件处理模型,基于观察者模式的委派事件模型(Delegation Event Model) 事件源—————-目标对象 事件监听器————观察者 京东商城中，群发某商品打折信息","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://chrisxb1996.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-模版方法模式","slug":"设计模式/设计模式-模版方法模式","date":"2020-05-20T14:22:50.000Z","updated":"2020-05-20T14:46:48.091Z","comments":true,"path":"2020/05/20/设计模式/设计模式-模版方法模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"模板方法模式也叫方法回调或钩子方法，是编程中经常用得到模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。 核心：处理步骤父类中定义好，具体实现延迟到子类中定义。","text":"模板方法模式也叫方法回调或钩子方法，是编程中经常用得到模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。 核心：处理步骤父类中定义好，具体实现延迟到子类中定义。 1234567891011121314151617181920public abstract class BankTemplateMethod &#123; //具体方法 public void takeNumber()&#123; System.out.println(\"取号排队\"); &#125; public abstract void transact(); //办理具体的业务 //钩子方法 public void evaluate()&#123; System.out.println(\"反馈评分\"); &#125; public final void process()&#123; this.takeNumber(); this.transact(); this.evaluate(); &#125;&#125; 1234567891011121314151617181920public class test &#123; public static void main(String[] args) &#123; //采用匿名内部类 BankTemplateMethod btm = new BankTemplateMethod()&#123; @Override public void transact() &#123; System.out.println(\"取钱：2000！！！\"); &#125; &#125;; btm.process(); BankTemplateMethod btm2 = new BankTemplateMethod()&#123; @Override public void transact() &#123; System.out.println(\"我要存钱：2000000！！！\"); &#125; &#125;; btm2.process(); &#125;&#125; • 什么时候用到模板方法模式：实现一个算法时，整体步骤很固定。但是，某些部分易变。易变部分可以抽象成出来，供子类实现。 • 开发中常见的场景：非常频繁。各个框架、类库中都有他的影子。比如常见的有：1.数据库访问的封装；2.Junit单元测试；3.servlet中关于doGet/doPost方法调用；4.Hibernate中模板程序；5.spring中JDBCTemplate、HibernateTemplate等；","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"模版方法模式","slug":"模版方法模式","permalink":"https://chrisxb1996.github.io/tags/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-策略模式","slug":"设计模式/设计模式-策略模式","date":"2020-05-20T06:56:40.000Z","updated":"2020-05-20T07:46:44.167Z","comments":true,"path":"2020/05/20/设计模式/设计模式-策略模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"某个市场人员接到单后的报价策略(CRM系统中常见问题)。报价策略很复杂，可以简单作如下分类：• 普通客户小批量报价• 普通客户大批量报价• 老客户小批量报价• 老客户大批量报价具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。","text":"某个市场人员接到单后的报价策略(CRM系统中常见问题)。报价策略很复杂，可以简单作如下分类：• 普通客户小批量报价• 普通客户大批量报价• 老客户小批量报价• 老客户大批量报价具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。 我们先可以采用条件语句处理： 12345678910111213141516public double getPrice(String type, double price)&#123; if(type.equals(\"普通客户小批量\"))&#123; System.out.println(\"不打折,原价\"); return price; &#125;else if(type.equals(\"普通客户大批量\"))&#123; System.out.println(\"打九折\"); return price*0.9; &#125;else if(type.equals(\"老客户小批量\"))&#123; System.out.println(\"打八五折\"); return price*0.85; &#125;else if(type.equals(\"老客户大批量\"))&#123; System.out.println(\"打八折\"); return price*0.8; &#125; return price; &#125; 但类型特别多，算法比较复杂时，整个条件控制代码会变得很长，难于维护。 策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//策略接口public interface Strategy &#123; double getPrice(double standardPrice);&#125;//新客户小批量public class NewCustomerFew implements Strategy&#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(\"不打折原价\"); return standardPrice; &#125;&#125;//新客户大批量public class NewCustomerLarge implements Strategy&#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(\"打九折！\"); return standardPrice*0.9; &#125;&#125;//老客户小批量public class OldCustomerFew implements Strategy&#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(\"打85折\"); return standardPrice*0.85; &#125;&#125;//老客户大批量public class OldCustomLarge implements Strategy&#123; @Override public double getPrice(double standardPrice) &#123; System.out.println(\"打8折\"); return standardPrice*0.8; &#125;&#125;//上下文类//负责和具体的策略类交互，是的客户端和算法独立public class Context &#123; private Strategy strategy; //当前采用的算法对象 //通过构造器注入 public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; //通过set方法注入 public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public void printPrice(double s)&#123; System.out.println(\"价格：\"+strategy.getPrice(s)); &#125;&#125;//测试public class test &#123; public static void main(String[] args) &#123; Strategy s1 = new OldCustomerFew(); Strategy s2 = new OldCustomLarge(); Context ctx = new Context(s1); Context ctx2 = new Context(s2); int standardPrice = 1000; ctx.printPrice(standardPrice); ctx2.printPrice(standardPrice); &#125;&#125; • 本质：分离算法，选择实现。• 开发中常见的场景：JAVASE中GUI编程中，布局管理；Spring框架中，Resource接口，资源访问策略；javax.servlet.http.HttpServlet#service()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"https://chrisxb1996.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"应用层","slug":"计算机网络/应用层","date":"2020-05-18T09:33:32.000Z","updated":"2020-05-20T09:10:26.085Z","comments":true,"path":"2020/05/18/计算机网络/应用层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"概述• 每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。 • 应用层的许多协议都是基于客户服务器方式。客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。","text":"概述• 每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。 • 应用层的许多协议都是基于客户服务器方式。客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。 • 常用端口： 域名系统 DNSDNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名… 动态主机配置协议DHCPDHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址(DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址)等信息。 DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。 • DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。• DHCP 客户从 UDP 端口 68发送 DHCP发现报文(DHCPDISCOVER)。该报文被放入 UDP 中，广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。• 凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文(DHCPOFFER)，因此 DHCP 客户可能收到多个 DHCP 提供报文。• DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文(DHCPREQUEST)。• 被选择的 DHCP 服务器发送确认报文DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了。 文件传送协议 FTP文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议， FTP使用两个TCP连接：TCP控制链接、TCP数据连接： 控制连接：标准端口为21，在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。 数据连接：标准端口为20，实际用于传输文件。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务端从20端口主动向客户端发起连接。 被动模式：服务端在指定范围内的某个端口被动等待客户端发起连接 注意：主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙(需要在防火墙上开放20和21端口)。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 按远程终端协议 TELNETTELNET 是一个简单的远程终端协议，也是因特网的正式标准。 • TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。• TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议(SMTP, POP3, IMAP) 发送邮件的协议：SMTP使用TCP 25端口。 读取邮件的协议：POP3 使用110端口和 IMAP使用的端口是143。 • SMTP：SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 • POP3：POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。 • IMAP：IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 超文本传送协议 HTTP在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。 HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 URL使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。URL有如下一般形式： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; • &lt;协议&gt; ftp、http、News…• &lt;主机&gt; 是存放资源的主机在因特网中的域名;• &lt;端口&gt;/&lt;路径&gt; 有时可省略； 请求web服务的过程： HTTP的报文结构：HTTP 有两类报文： • 请求报文——从客户向服务器发送请求报文。• 响应报文——从服务器到客户的回答。• 由于 HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。 报文由三个部分组成，即开始行、首部行和实体主体。在请求报文中，开始行就是请求行。包含了方法字段。 响应报文的开始行是状态行。状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。 • 1xx ：Informational（信息性状态码），表示通知信息的，如请求收到了或正在进行处理。 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 • 2xx ：Success（成功状态码），表示成功，如接受或知道了。 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 • 3xx ：Redirection（重定向状态码），表示重定向，表示要完成请求还必须采取进一步的行动。 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 • 4xx ：Client Error（客户端错误状态码），表示客户的差错，如请求中有错误的语法或不能完成。 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found • 5xx ：Server Error（服务器错误状态码），表示服务器的差错，如服务器失效无法完成请求。 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 Cookie","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"应用层","slug":"应用层","permalink":"https://chrisxb1996.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"传输层","slug":"计算机网络/传输层","date":"2020-05-17T08:06:11.000Z","updated":"2020-05-18T09:30:30.678Z","comments":true,"path":"2020/05/17/计算机网络/传输层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"概述进程之间的通信: 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。","text":"概述进程之间的通信: 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 TCP和UDP:运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。 用户数据报协议 UDP (User Datagram Protocol)：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP (Transmission Control Protocol)：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 传输层的端口:运行在计算机中的进程是用进程标识符来标志的，为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。解决这个问题的方法就是在运输层使用协议端口号(protocol port number)，或通常简称为端口(port)。 端口用一个 16 位端口号进行标志。 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。 三类端口 ：1.熟知端口，数值一般为 0-1023；2.登记端口号，数值为1024-49151，为没有熟知端口号的应用程序使用的；3.客户端口号，数值为49152-65535，留给客户进程选择暂时使用； 常用应用层协议与传输层端口：http = TCP + 80；https = TCP + 443；ftp = TCP + 21；SMTP = TCP + 25；POP3 = TCP + 101；RDP = TCP + 3389；SQL = TCP + 1433；DNS = UDP + 53 or TCP + 53(极少情况) 计算机服务(对外的服务)运行后在TCP或UDP的某个端口侦听客户端请求。 UDPUDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。 UDP 是无连接的，即发送数据之前不需要建立连接(主要针对短包，实时性要求不高的数据)。 UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。 UDP 支持一对一、一对多、多对一和多对多的交互通信。 UDP 的首部开销小，只有 8 个字节。 面向报文：送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。应用程序必须选择合适大小的报文。 UDP首部格式：首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCPTCP 概述：主要特点:1.TCP是面向连接的运输层协议；2.每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的(一对一)；3.TCP 提供可靠交付的服务；4.TCP 提供全双工通信；5.面向字节流； 面向字节流的传输过程： 注意：1.TCP 连接是一条虚连接而不是一条真正的物理连接。2.TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字(socket)，端口号拼接到 IP 地址即构成了套接字。套接字 socket = (IP地址: 端口号)；3.每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}； TCP 报文首部格式： 源端口和目的端口字段——各占 2 字节，端口传输层与应用层的服务接口。传输层的复用和分用功能都要通过端口才能实现。 序号字段——占 4 字节，TCP 连接中传送的字节流中的每一个数据段都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 数据偏移(即首部长度)——占 4 位，它表示首部长度，最长60个字节，故可变长度最长40个字节。 保留字段——占 6 位，保留为今后使用，但目前应置为 0。 紧急 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。 确认 ACK —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 推送 PSH —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 复位 RST —— 当 RST = 1 时，表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。 同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。 终止 FIN —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。 检验和 —— 占 2 字节，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 选项字段 —— 长度可变，TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” TCP 可靠传输：停止等待协议： 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信，这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest) 。 TCP 滑动窗口： 停止等待协议的优点是简单，但缺点是信道利用率太低。 针对这一缺点，一般采用滑动窗口(流水线传输)和累积确认(接收窗口)的方法提高信道利用率。滑动窗口：发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。1.如下图所示，根据 B 给出的窗口值A构造出自己的发送窗口；2.A 发送了 11 个字节的数据；3.A 收到新的确认号后，发送窗口向前滑动；4.若A 的发送窗口内的序号都已用完，但还没有再收到确认，必须停止发送；累积确认：接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。 TCP 流量控制：一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制：拥塞控制：所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 流量控制：往往指在给定的发送端和接收端之间的点对点通信量的控制。主要是抑制发送端发送数据的速率，以便使接收端来得及接收。 几种拥塞控制方法：慢开始、拥塞避免、快重传、快恢复 慢开始和拥塞避免算法： 1.发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 2.注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 3.如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 注意：发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 快重传和快恢复： 快重传：在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 快恢复：在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 注意：慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 TCP 链接管理：运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。 TCP建立连接的三次握手：TCP 连接的建立都是采用客户服务器方式：• 主动发起连接建立的应用进程叫做客户(client)• 被动等待连接建立的应用进程叫做服务器(server) 三次握手： A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。 B 的 TCP 收到连接请求报文段后，如同意，则发回确认. B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。 A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。 A 的 TCP 通知上层应用进程，连接已经建立。 注意：三次握手的原因：第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果不进行三次握手，那么服务器就会打开两个连接。导致连接失败，如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认。 TCP连接释放的四次挥手： 四次挥手： A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。 B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 TCP 连接必须经过时间 2MSL(最大报文存活时间)后才真正释放掉。 注意：客户端A的TIME-WAIT状态必须等待2MSL的原因：第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"传输层","slug":"传输层","permalink":"https://chrisxb1996.github.io/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"}]},{"title":"网络层","slug":"计算机网络/网络层","date":"2020-05-15T13:55:05.000Z","updated":"2020-05-18T04:47:39.741Z","comments":true,"path":"2020/05/15/计算机网络/网络层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"概述 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。","text":"概述 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 TCP/IP协议栈 IP地址编址点分十进制记法： 分类： 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 1-126：A类地址，127是本机地址；128-191：B类地址；192-223：C类地址；224-240：D类地址； 特殊的几个地址：127.0.0.1 本地环回地址；169.254.0.0 windows链接失败自动分配的地址；10.0.0.0 保留的私网地址；172.16.0.0 — 172.31.0.0 保留的私网地址；192.168.0.0 — 192.168.255.0 保留的私网地址； 划分子网： 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。例如：一个 C 类地址的默认子网掩码为 255.255.255.0，如果 B 类地址的子网占两个比特，那么子网掩码为11111111 11111111 11111111 11000000，也就是 255.255.255.192。 注意：外部网络看不到子网的存在。 构造超网(无分类CIDR)： CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。 CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。从三级编址（使用子网掩码）又回到了两级编址。 IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;} 一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。路由聚合也称为构成超网(supernetting)。 CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 计算机A到B的通信过程： ARP协议 不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 注意：ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 IP数据包 一个 IP 数据包由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本——占 4 位：指 IP 协议的版本：4（IPv4）和 6（IPv6） 首部长度——占 4 位：可表示的最大数值，是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。 区分服务——占 8 位：用来获得更好的服务，在一般的情况下都不使用这个字段 。 总长度——占 16 位：指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。 标识——占 16 位：它是一个计数器，用来产生数据报的标识。 标志——占 3 位：目前只有前两位有意义。 生存时间——占 8 位：记为 TTL (Time To Live)，数据报在网络中可通过的路由器个数的最大值。 协议——占 8 位：该字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程。 首部检验和——占 16 位：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量(简单计算)。 源地址和目的地址——占 32 位：都各占 4 字节。 片偏移——占 312位：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。 注意：IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。 IP转发分组 路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。 网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。(有去有回) 这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。 注意：IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。 网际控制报文协议 ICMP ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 不是高层协议，而是 IP 层的协议。 ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 几种常见的ICMP报文类型： Ping：用来测试两个主机之间的连通性；是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP； Traceroute： 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径，发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文； 路由选择协议基本概念：从路由算法的自适应性考虑可分为：静态路由选择策略和动态路由选择策略： 静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。 路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF； 自治系统间的路由选择：BGP 内部网关协议 RIP： RIP是一种分布式的基于距离向量的路由选择协议，RIP 协议中的距离即为跳数，RIP允许一条路径最多只能包含 15 个路由器。跳数的最大值为16 时相当于不可达。可见RIP只适用于小型互联网。 RIP协议的三个要点：1.仅和相邻路由器交换信息；2.交换的信息是当前本路由器所知道的全部信息，即自己的路由表；3.按固定的时间间隔(30秒)交换路由信息； 优缺点：优点：RIP 协议实现简单，开销小。缺点：但是 RIP 能使用的最大距离为 15，限制了网络的规模；并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器；同时仅基于跳数选择最佳路由也不够合理； 内部网关协议 OSPF(Open Shortest Path First) 基本特点：1.“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的;2.“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF; 三个要点 :1.向本自治系统中所有路由器发送信息，使用的方法是洪泛法。2.发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。3.只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 OSPF 能够用于规模很大的网，的更新过程收敛得快; 外部网关协议 BGP BGP 是不同自治系统的路由器之间交换路由信息的协议。 因特网的规模太大，使得自治系统之间路由选择非常困难； 边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由； 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 虚拟专用网VPN专用网段：10.0.0.0 到 10.255.255.255172.16.0.0 到 172.31.255.255192.168.0.0 到 192.168.255.255 这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换NAT需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP。 所有使用本地地址的主机在和外界通信时都要在 NAT 路由器上将其本地地址转换成 IP才能和因特网连。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 Internet组播管理协议 IGMP 当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。 因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络层","slug":"网络层","permalink":"https://chrisxb1996.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"}]},{"title":"数据链路层","slug":"计算机网络/数据链路层","date":"2020-05-15T07:05:33.000Z","updated":"2020-05-18T04:47:50.792Z","comments":true,"path":"2020/05/15/计算机网络/数据链路层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"基本问题基本概念：1.主机H1向H2发送数据：层次上来看：仅从数据链路层观察帧的流动： 注意：可以看到路由器只到网络层(三层协议)，没有应用层，和传输层；","text":"基本问题基本概念：1.主机H1向H2发送数据：层次上来看：仅从数据链路层观察帧的流动： 注意：可以看到路由器只到网络层(三层协议)，没有应用层，和传输层； 2.数据链路层传输的是帧： 数据链路层的三个基本点：1.封装成帧2.透明传输3.差错控制 封装成帧：封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。 透明传输：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 差错控制：在数据链路层传送的帧中，广泛使用了循环冗余检验 (CRC) 的检错技术：CRC是一种无比特差错，而不是无传输差错的检测机制。将得到的FCS(帧检验序列 )添加在原序列后面，在接收端检验：若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)；若余数 R != 0，则判定这个帧有差错，就丢弃，在高层进行重传指令。 数据链路层的信道类型点对点信道：使用一对一的点对点通信方式，不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议，支持身份验证，支持多个网络层协议。PPP协议帧格式：1.A、C：在点到点信道没有实际意义，固定为：FF、03；2.协议字段(2字节)：用于标识信息部分是什么内容；3.FCS(2字节)：表示CRC得到的帧检验序列； 广播信道：这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送(随机接入)：CSMA/CD(载波监听多点接入/碰撞检测) 协议：多点接入：表示许多计算机以多点接入的方式连接在一根总线上。载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。以太网中经过计算，最短有效帧长为512bit，也就是64个字节，规定凡是长度小于64字节的帧都是无效帧。当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。注意：该协议只能(只能进行半双工通信)。 以太局域网概述：以太网是一种星型拓扑结构局域网。早期使用集线器(hub)进行连接，集线器是一种物理层设备， 作用于比特而不是帧。目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。以太网提供的服务是不可靠的交付，即尽最大努力的交付。当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 信道利用率：一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲时为止，是发送一帧所需的平均时间。 信道利用率可以表示为：T0/发送一帧所需的平均时间。 MAC层(数据链路层的子层)：在局域网中，硬件地址又称为物理地址，或 MAC 地址。MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。以太网MAC帧格式： 扩展以太网网桥(淘汰)：在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。 交换机：交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。1.端口独享带宽；2.比集线器安全，可以设置固定MAC地址；3.接口到计算机全双工；4.全双工模式不再使用CSMA/CD协议；5.接口可以工作在不同的速率；6.广播帧会转发到全部端口； 虚拟局域网(VLAN):虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。例如：在研发部某台主机广播的消息只能住研发部收到，销售部和人力资源部则收不到消息。使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据链路层","slug":"数据链路层","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"}]},{"title":"计算机网络概述","slug":"计算机网络/计算机网络概述","date":"2020-05-15T06:26:57.000Z","updated":"2020-05-16T09:21:03.551Z","comments":true,"path":"2020/05/15/计算机网络/计算机网络概述/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","excerpt":"OSI七层参考模型:1.应用层：能够产生网络流量能够和用户交互的应用程序；2.表示层：加密，压缩，开发人员；3.会话层：服务和客户建立的会话：netstat -n；4.传输层：可靠传输建立会话，不可靠传输，流量控制；5.网络层：IP地址编址，选择最佳路径；","text":"OSI七层参考模型:1.应用层：能够产生网络流量能够和用户交互的应用程序；2.表示层：加密，压缩，开发人员；3.会话层：服务和客户建立的会话：netstat -n；4.传输层：可靠传输建立会话，不可靠传输，流量控制；5.网络层：IP地址编址，选择最佳路径；6.数据链路层：数据如何封装，添加物理层地址(MAC)；7.物理层：电压，借口标准； 网络排错：从底层到高层 五层参考模型:传输的过程：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"设计模式-工厂模式","slug":"设计模式/设计模式-工厂模式","date":"2020-05-14T07:56:13.000Z","updated":"2020-05-15T06:47:57.322Z","comments":true,"path":"2020/05/14/设计模式/设计模式-工厂模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"核心：实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。三种类型的工厂模式：1.简单工厂（使用较多）：又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；2.工厂方法：为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，但实际上，我们一般都用简单工厂模式；","text":"核心：实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。三种类型的工厂模式：1.简单工厂（使用较多）：又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；2.工厂方法：为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，但实际上，我们一般都用简单工厂模式；3.抽象工厂：用来生产不同产品族的全部产品：在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式； 不使用工厂模式的情况： 123456public class Audi implements Car&#123; @Override public void run() &#123; System.out.println(\"Audi跑！！！\"); &#125;&#125; 123456public class Byd implements Car&#123; @Override public void run() &#123; System.out.println(\"Byd跑！！！\"); &#125;&#125; 12345678public class test01 &#123; //调用者 public static void main(String[] args) &#123; Car c1 = new Audi(); Car c2 = new Byd(); c1.run(); c2.run(); &#125;&#125; 简单工厂： 12345678public class CarFactory &#123; public static Car createAudi()&#123; return new Audi(); &#125; public static Car createByd()&#123; return new Byd(); &#125;&#125; 12345678public class test01 &#123;//调用者 public static void main(String[] args) &#123; Car car1 = CarFactory.createAudi(); Car car2 = CarFactory.createByd(); car1.run(); car2.run(); &#125;&#125; 工厂方法：增加两个实现类： 1234567891011121314151617public interface CarFactory &#123; Car createCar();&#125;public class AudiFactory implements CarFactory&#123; @Override public Car createCar() &#123; return new Audi(); &#125;&#125;public class BydFactory implements CarFactory&#123; @Override public Car createCar() &#123; return new Byd(); &#125;&#125; 12345678public class test01 &#123;//调用者 public static void main(String[] args) &#123; Car car1 = new AudiFactory().createCar(); Car car2 = new BydFactory().createCar(); car1.run(); car2.run(); &#125;&#125; 抽象工厂：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-单例模式","slug":"设计模式/设计模式-单例模式","date":"2020-05-13T09:12:28.000Z","updated":"2020-05-14T13:07:29.495Z","comments":true,"path":"2020/05/13/设计模式/设计模式-单例模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。常见应用场景：Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…常见的五种单例模式实现方式： 1.饿汉式：线程安全，调用效率高。 但是，不能延时加载； 2.懒汉式：线程安全，调用效率不高，可以延时加载； 3.静态内部类式：线程安全，调用效率高，可以延时加载；","text":"核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。常见应用场景：Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…常见的五种单例模式实现方式： 1.饿汉式：线程安全，调用效率高。 但是，不能延时加载； 2.懒汉式：线程安全，调用效率不高，可以延时加载； 3.静态内部类式：线程安全，调用效率高，可以延时加载； 4.枚举式：线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化创建对象的漏洞！ 5.双重检测锁式：JVM底层内部模型原因，偶尔会出问题。不建议使用； 饿汉式： 1234567891011//饿汉式：public class SingletonDemo01 &#123; //类初始化时，上来先创建对象（没有延时加载的优势），加载类时，天然线程安全 private static SingletonDemo01 instance = new SingletonDemo01(); //构造器私有 private SingletonDemo01()&#123;&#125; //优点：方法没有同步调用效率高 public static SingletonDemo01 getInstance()&#123; return instance; &#125;&#125; 懒汉式： 123456789101112//懒汉式：public class SingletonDemo02 &#123; //类初始化时，不创建对象（延时加载，真正用的时候再创建） private static SingletonDemo02 instance; //构造器私有 private SingletonDemo02()&#123;&#125; //需要加同步，保证单例模式，效率较低 public static synchronized SingletonDemo02 getInstance()&#123; if(instance == null) instance = new SingletonDemo02(); return instance; &#125;&#125; 静态内部类式: 123456789101112//静态内部类方式：线程安全，调用效率高，实现延时加载public class SingletonDemo03 &#123; private static class SingletonInnerClass&#123; private static final SingletonDemo03 instance = new SingletonDemo03(); &#125; //构造器私有 private SingletonDemo03()&#123;&#125; //优点：方法没有同步调用效率高 public static SingletonDemo03 getInstance()&#123; return SingletonInnerClass.instance; &#125;&#125; 枚举式: 1234567//枚举类方式：线程安全，但没有延时加载；同时能够避免反射和反序列的漏洞public enum SingletonDemo04 &#123; INSTANCE; //可以自己添加一些操作方法 public static void instanceOper()&#123; &#125;&#125; 如何选用合适的单例模式：单例对象占用资源少，不需要延时加载：枚举式 &gt; 饿汉式;单例对象占用资源大，需要 延时加载：静态内部类式 &gt; 懒汉式;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"JVM核心机制-类加载过程","slug":"Java/JVM核心机制-类加载过程","date":"2020-05-13T06:38:30.000Z","updated":"2020-05-18T04:49:14.599Z","comments":true,"path":"2020/05/13/Java/JVM核心机制-类加载过程/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/13/Java/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口： 类加载器的层次结构(树状结构): 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader；","text":"类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口： 类加载器的层次结构(树状结构): 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader； 扩展类加载器（extensions class loader）：用来加载 Java 的扩展库，Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类，由ExtClassLoader实现； 应用程序类加载器（application class loader）：它根据 Java 应用的类路径来加载 Java 类，一般来说，Java 应用的类都是由它来完成加载的，由AppClassLoader实现； 自定义类加载器： 开发人员可以通过继承 java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。 注意：类加载器加载类的时候是线程安全的 双亲委托机制： 就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 双亲委托机制是为了保证 Java 核心库的类型安全，这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。 类加载器除了用于加载类，也是安全的最基本的屏障。 双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制：tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://chrisxb1996.github.io/tags/JVM/"}]},{"title":"Java 动态编译","slug":"Java/Java-动态编译","date":"2020-05-12T07:20:23.000Z","updated":"2020-05-14T03:19:01.203Z","comments":true,"path":"2020/05/12/Java/Java-动态编译/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/12/Java/Java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/","excerpt":"Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：通过JavaCompiler动态编译： 1234567public static int compileFile(String sourceFile)&#123; //动态编译 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null,sourceFile); System.out.println(result==0?\"编译成功\":\"编译失败\"); return result;&#125; • 第一个参数：为java编译器提供参数• 第二个参数：得到 Java 编译器的输出信息","text":"Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：通过JavaCompiler动态编译： 1234567public static int compileFile(String sourceFile)&#123; //动态编译 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null,sourceFile); System.out.println(result==0?\"编译成功\":\"编译失败\"); return result;&#125; • 第一个参数：为java编译器提供参数• 第二个参数：得到 Java 编译器的输出信息• 第三个参数：接收编译器的 错误信息• 第四个参数：可变参数（是一个String数组）能传入一个或多个 Java 源文件• 返回值：0表示编译成功，非0表示编译失败 动态运行编译好的类： 通过Runtime.getRuntime()运行启动新的进程运行12Runtime run = Runtime.getRuntime();Process process = run.exec(\"java -cp path HelloWorld\"); 通过反射运行编译好的类12345678910111213//通过反射运行程序public static void runJavaClassByReflect(String dir,String classFile) throws Exception&#123; try &#123; URL[] urls = new URL[] &#123;new URL(\"file:/\"+dir)&#125;; URLClassLoader loader = new URLClassLoader(urls); Class c = loader.loadClass(classFile); //调用加载类的main方法 Method m = c.getMethod(\"main\",String[].class) m.invoke(null, (Object)new String[]&#123;&#125;);//反射调用main方法加(object)强制转型 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"}]},{"title":"Java 反射","slug":"Java/Java-反射","date":"2020-05-11T13:35:34.000Z","updated":"2020-05-13T06:36:53.159Z","comments":true,"path":"2020/05/11/Java/Java-反射/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/11/Java/Java-%E5%8F%8D%E5%B0%84/","excerpt":"虽然Java不是动态语言1，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。反射：指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。反射机制的作用：重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。","text":"虽然Java不是动态语言1，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。反射：指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。反射机制的作用：重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。获取Class对象：1.Class.forName();(常用)2.getClass();3..class;代码： javaBean:1234567891011121314151617181920212223242526272829303132public class User &#123; private int id; private int age; private String name; //javabean一定要有无参构造器 public User() &#123; &#125; public User(int id, int age, String name) &#123; super(); this.id = id; this.age = age; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 获得User类的反射对象：1234567String path = \"com.sxt.test.bean.User\";Class clazz = Class.forName(path);//方法一User u = new User();Class clazz2 = u.getClass();//方法二Class clazz3 = com.sxt.test.bean.User.class;//方法三 获得User类的属性：1Field f = clazz.getDeclaredField(\"name\"); 获得User类的方法：123Method m01 = clazz.getDeclaredMethod(\"getName\", null);//如果方法有参数，则必须传递参数类型对应的Class对象Method m02 = clazz.getDeclaredMethod(\"setName\", String.class); 获得User类指定的构造器：1Constructor constructor = clazz.getDeclaredConstructor(int.class,int.class,String.class); 通过反射API动态的操作：构造器，方法，属性：123456789101112131415//通过反射API调用构造方法，构造对象User u1 = (User) clazz.getConstructor().newInstance();//调用了User的无参构造器User u2 = (User)clazz.getConstructor(int.class,int.class,String.class).newInstance(1001,18,\"席博\");//调用了User带参构造器//通过反射API调用普通方法 invoke(对象，参数)方法User u3 = (User) clazz.getConstructor().newInstance();Method method = clazz.getDeclaredMethod(\"setName\", String.class);method.invoke(u3, \"aaa\");//u3.setName(\"aaa\");//通过反射API操作属性User u4 = (User) clazz.getConstructor().newInstance();Field f = clazz.getDeclaredField(\"name\");//通过反射获得属性f.setAccessible(true); //这个属性不需要做安全检查，可以直接访问f.set(u4, \"bbb\"); //通过反射直接写u4属性f.get(u4);//通过反射读取u4属性 通过反射读取泛型的信息：ParameterizedType: 表示一种参数化的类型，比如Collection； 通过反射读取注解的信息，模拟处理注解信息的流程，具体参见：Java 注解 反射的性能问题：使用反射性能会降低(约30倍)，setAccessible：启用和禁用访问安全检查的开关，设为 true 则表示反射的对象在使用时禁止 Java 语言访问检查。禁止安全检查，可以提高反射的运行速度(大约提高四倍)。 1.动态语言：程序运行时，可以改变程序结构或变量类型。常见的动态语言：Python、ruby、javascript ↩","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"reflection","slug":"reflection","permalink":"https://chrisxb1996.github.io/tags/reflection/"},{"name":"反射","slug":"反射","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java 注解","slug":"Java/Java-注解","date":"2020-05-10T03:56:57.000Z","updated":"2020-05-14T03:16:59.928Z","comments":true,"path":"2020/05/10/Java/Java-注解/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/10/Java/Java-%E6%B3%A8%E8%A7%A3/","excerpt":"Annotation的作用：1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)Annotation的格式：注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value=”unchecked”)。(抑制警告)Annotation在哪里使用：可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。","text":"Annotation的作用：1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)Annotation的格式：注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value=”unchecked”)。(抑制警告)Annotation在哪里使用：可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。自定义注解：格式：public @interface 注解名 {定义体}1.方法的名称就是参数的名称;2.返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）;3.可以通过default来声明参数的默认值1;4.如果只有一个参数成员，一般参数名为value;元注解：元注解的作用就是负责注解其他注解。 Java定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。1.@Target：用于描述注解的使用范围（即:被描述的注解可以用在什么地方）ElementType.TYPE；ElementType.FIELD…2.@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期SOURCE；CLASS；RUNTIME(可被反射机制读取)3.@Documented4.@Inherited通过反射读取注解的流程： 自定义类注解： 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface test01Table &#123; String value();&#125; 自定义属性注解： 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface test01Field &#123; String columnName(); String type(); int length();&#125; 在test01中加入注解： 123456789@test01Table(\"tb_member\")public class test01 &#123; @test01Field(columnName = \"id\", type = \"int\", length = 10) private int id; @test01Field(columnName = \"sname\", type = \"varchar\", length = 10) private String name; @test01Field(columnName = \"age\", type = \"int\", length = 3) private int age;&#125; 读取test01中的注解： 12345678910111213141516171819202122232425262728/** * 通过反射读取自定义注解 */public class ReadAnnotation &#123; public static void main(String[] args) &#123; try &#123; Class clazz = Class.forName(\"com.sgg.annotation.test01\"); //获得类的有效注解 Annotation[] annotations = clazz.getAnnotations(); for(Annotation a : annotations)&#123; System.out.println(a); &#125; //获得类的制定注解 test01Table tt = (test01Table)clazz.getAnnotation(test01Table.class); System.out.println(tt.value()); //获得类的属性的对应注解 Field f = clazz.getDeclaredField(\"id\"); test01Field tf = (test01Field)f.getAnnotation(test01Field.class); System.out.println(tf.columnName() +\"--\"+ tf.type() +\"--\"+ tf.length()); //接下来可以利用注解信息写出DDL语句，完成相应的数据库操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义 ↩","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"annotation","slug":"annotation","permalink":"https://chrisxb1996.github.io/tags/annotation/"}]},{"title":"用hexo搭建个人博客","slug":"用hexo搭建个人博客","date":"2020-05-09T08:50:49.000Z","updated":"2020-06-10T12:35:19.710Z","comments":true,"path":"2020/05/09/用hexo搭建个人博客/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"准备工作安装git：https://git-scm.com安装nodejs：https://nodejs.org/en/安装hexo1.以管理员身份运行：sudo su2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。","text":"准备工作安装git：https://git-scm.com安装nodejs：https://nodejs.org/en/安装hexo1.以管理员身份运行：sudo su2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。3.在国内建议先安装淘宝镜像源 cnpm再进行安装hexo：输入：npm install -g cnpm –registry=https://registry.npm.taobao.org; 安装完后查 看是否安装成功： cnpm -v： 利用cnpm安装hexo博客 ：cnpm install -g hexo-cli 安装成功可查看hexo信息：hexo -v: 4.可以新建一个 文件夹作为存放目录：mkdir blog，进到目录中：cd blog/ (注意操作都在当前文件夹下进行操作)5.至此，hexo已经为你生成了基础博客框架，启动hexo输入 :hexo s6.在浏览器输入地址http://localhost:4000 可以看到基本框架已经生成。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/categories/hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chrisxb1996.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chrisxb1996.github.io/tags/nodejs/"}]}],"categories":[{"name":"mysql","slug":"mysql","permalink":"https://chrisxb1996.github.io/categories/mysql/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构和算法","slug":"剑指offer/数据结构和算法","permalink":"https://chrisxb1996.github.io/categories/%E5%89%91%E6%8C%87offer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://chrisxb1996.github.io/categories/Leetcode/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/categories/hexo/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://chrisxb1996.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://chrisxb1996.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://chrisxb1996.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chrisxb1996.github.io/tags/SpringBoot/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://chrisxb1996.github.io/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://chrisxb1996.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"模版方法模式","slug":"模版方法模式","permalink":"https://chrisxb1996.github.io/tags/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"https://chrisxb1996.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"应用层","slug":"应用层","permalink":"https://chrisxb1996.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"传输层","slug":"传输层","permalink":"https://chrisxb1996.github.io/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"网络层","slug":"网络层","permalink":"https://chrisxb1996.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"数据链路层","slug":"数据链路层","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"JVM","slug":"JVM","permalink":"https://chrisxb1996.github.io/tags/JVM/"},{"name":"reflection","slug":"reflection","permalink":"https://chrisxb1996.github.io/tags/reflection/"},{"name":"反射","slug":"反射","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"annotation","slug":"annotation","permalink":"https://chrisxb1996.github.io/tags/annotation/"},{"name":"git","slug":"git","permalink":"https://chrisxb1996.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chrisxb1996.github.io/tags/nodejs/"}]}