{"meta":{"title":"xbsNotes","subtitle":"","description":"🍃","author":"xNotes","url":"https://chrisxb1996.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-10T14:10:33.000Z","updated":"2020-05-11T04:38:23.316Z","comments":false,"path":"categories/index.html","permalink":"https://chrisxb1996.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-11T03:34:53.000Z","updated":"2020-05-18T09:35:36.626Z","comments":false,"path":"Coding/index.html","permalink":"https://chrisxb1996.github.io/Coding/index.html","excerpt":"","text":"Java基础Java 注解(Annotation)Java 反射(reflection)Java 动态编译JVM核心机制-类加载过程 设计模式设计模式-单例模式设计模式-工厂模式 LeetCode刷题计算机网络计算机网络概述数据链路层网络层传输层应用层"},{"title":"","date":"2020-05-10T14:25:26.000Z","updated":"2020-05-11T04:42:00.966Z","comments":false,"path":"tags/index.html","permalink":"https://chrisxb1996.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-11T03:26:51.000Z","updated":"2020-05-12T08:27:56.305Z","comments":false,"path":"scientific/index.html","permalink":"https://chrisxb1996.github.io/scientific/index.html","excerpt":"","text":"天线阵列:论文笔记：Statistical Analysis of Array Gain for Cooperative MISO Transmitters without CSI"},{"title":"","date":"2020-05-12T08:35:33.000Z","updated":"2020-05-12T08:38:56.959Z","comments":false,"path":"about/index.html","permalink":"https://chrisxb1996.github.io/about/index.html","excerpt":"","text":"“ ”"}],"posts":[{"title":"应用层","slug":"计算机网络/应用层","date":"2020-05-18T09:33:32.000Z","updated":"2020-05-18T13:55:35.459Z","comments":true,"path":"2020/05/18/计算机网络/应用层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"","text":"域名系统 DNSDNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名…","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"应用层","slug":"应用层","permalink":"https://chrisxb1996.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"传输层","slug":"计算机网络/传输层","date":"2020-05-17T08:06:11.000Z","updated":"2020-05-18T09:30:30.678Z","comments":true,"path":"2020/05/17/计算机网络/传输层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"概述进程之间的通信: 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。","text":"概述进程之间的通信: 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 TCP和UDP:运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。 用户数据报协议 UDP (User Datagram Protocol)：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP (Transmission Control Protocol)：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 传输层的端口:运行在计算机中的进程是用进程标识符来标志的，为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。解决这个问题的方法就是在运输层使用协议端口号(protocol port number)，或通常简称为端口(port)。 端口用一个 16 位端口号进行标志。 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。 三类端口 ：1.熟知端口，数值一般为 0-1023；2.登记端口号，数值为1024-49151，为没有熟知端口号的应用程序使用的；3.客户端口号，数值为49152-65535，留给客户进程选择暂时使用； 常用应用层协议与传输层端口：http = TCP + 80；https = TCP + 443；ftp = TCP + 21；SMTP = TCP + 25；POP3 = TCP + 101；RDP = TCP + 3389；SQL = TCP + 1433；DNS = UDP + 53 or TCP + 53(极少情况) 计算机服务(对外的服务)运行后在TCP或UDP的某个端口侦听客户端请求。 UDPUDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。 UDP 是无连接的，即发送数据之前不需要建立连接(主要针对短包，实时性要求不高的数据)。 UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。 UDP 支持一对一、一对多、多对一和多对多的交互通信。 UDP 的首部开销小，只有 8 个字节。 面向报文：送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。应用程序必须选择合适大小的报文。 UDP首部格式：首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCPTCP 概述：主要特点:1.TCP是面向连接的运输层协议；2.每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的(一对一)；3.TCP 提供可靠交付的服务；4.TCP 提供全双工通信；5.面向字节流； 面向字节流的传输过程： 注意：1.TCP 连接是一条虚连接而不是一条真正的物理连接。2.TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字(socket)，端口号拼接到 IP 地址即构成了套接字。套接字 socket = (IP地址: 端口号)；3.每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}； TCP 报文首部格式： 源端口和目的端口字段——各占 2 字节，端口传输层与应用层的服务接口。传输层的复用和分用功能都要通过端口才能实现。 序号字段——占 4 字节，TCP 连接中传送的字节流中的每一个数据段都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 数据偏移(即首部长度)——占 4 位，它表示首部长度，最长60个字节，故可变长度最长40个字节。 保留字段——占 6 位，保留为今后使用，但目前应置为 0。 紧急 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。 确认 ACK —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 推送 PSH —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 复位 RST —— 当 RST = 1 时，表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。 同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。 终止 FIN —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。 检验和 —— 占 2 字节，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 选项字段 —— 长度可变，TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” TCP 可靠传输：停止等待协议： 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信，这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest) 。 TCP 滑动窗口： 停止等待协议的优点是简单，但缺点是信道利用率太低。 针对这一缺点，一般采用滑动窗口(流水线传输)和累积确认(接收窗口)的方法提高信道利用率。滑动窗口：发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。1.如下图所示，根据 B 给出的窗口值A构造出自己的发送窗口；2.A 发送了 11 个字节的数据；3.A 收到新的确认号后，发送窗口向前滑动；4.若A 的发送窗口内的序号都已用完，但还没有再收到确认，必须停止发送；累积确认：接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。 TCP 流量控制：一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制：拥塞控制：所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 流量控制：往往指在给定的发送端和接收端之间的点对点通信量的控制。主要是抑制发送端发送数据的速率，以便使接收端来得及接收。 几种拥塞控制方法：慢开始、拥塞避免、快重传、快恢复 慢开始和拥塞避免算法： 1.发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 2.注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 3.如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 注意：发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 快重传和快恢复： 快重传：在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 快恢复：在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 注意：慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 TCP 链接管理：运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。 TCP建立连接的三次握手：TCP 连接的建立都是采用客户服务器方式：• 主动发起连接建立的应用进程叫做客户(client)• 被动等待连接建立的应用进程叫做服务器(server) 三次握手： A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。 B 的 TCP 收到连接请求报文段后，如同意，则发回确认. B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。 A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。 A 的 TCP 通知上层应用进程，连接已经建立。 注意：三次握手的原因：第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果不进行三次握手，那么服务器就会打开两个连接。导致连接失败，如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认。 TCP连接释放的四次挥手： 四次挥手： A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。 B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 TCP 连接必须经过时间 2MSL(最大报文存活时间)后才真正释放掉。 注意：客户端A的TIME-WAIT状态必须等待2MSL的原因：第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"传输层","slug":"传输层","permalink":"https://chrisxb1996.github.io/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"}]},{"title":"网络层","slug":"计算机网络/网络层","date":"2020-05-15T13:55:05.000Z","updated":"2020-05-18T04:47:39.741Z","comments":true,"path":"2020/05/15/计算机网络/网络层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"概述 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。","text":"概述 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 TCP/IP协议栈 IP地址编址点分十进制记法： 分类： 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 1-126：A类地址，127是本机地址；128-191：B类地址；192-223：C类地址；224-240：D类地址； 特殊的几个地址：127.0.0.1 本地环回地址；169.254.0.0 windows链接失败自动分配的地址；10.0.0.0 保留的私网地址；172.16.0.0 — 172.31.0.0 保留的私网地址；192.168.0.0 — 192.168.255.0 保留的私网地址； 划分子网： 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。例如：一个 C 类地址的默认子网掩码为 255.255.255.0，如果 B 类地址的子网占两个比特，那么子网掩码为11111111 11111111 11111111 11000000，也就是 255.255.255.192。 注意：外部网络看不到子网的存在。 构造超网(无分类CIDR)： CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。 CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。从三级编址（使用子网掩码）又回到了两级编址。 IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;} 一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。路由聚合也称为构成超网(supernetting)。 CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 计算机A到B的通信过程： ARP协议 不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 注意：ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 IP数据包 一个 IP 数据包由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本——占 4 位：指 IP 协议的版本：4（IPv4）和 6（IPv6） 首部长度——占 4 位：可表示的最大数值，是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。 区分服务——占 8 位：用来获得更好的服务，在一般的情况下都不使用这个字段 。 总长度——占 16 位：指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。 标识——占 16 位：它是一个计数器，用来产生数据报的标识。 标志——占 3 位：目前只有前两位有意义。 生存时间——占 8 位：记为 TTL (Time To Live)，数据报在网络中可通过的路由器个数的最大值。 协议——占 8 位：该字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程。 首部检验和——占 16 位：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量(简单计算)。 源地址和目的地址——占 32 位：都各占 4 字节。 片偏移——占 312位：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。 注意：IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。 IP转发分组 路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。 网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。(有去有回) 这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。 注意：IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。 网际控制报文协议 ICMP ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 不是高层协议，而是 IP 层的协议。 ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 几种常见的ICMP报文类型： Ping：用来测试两个主机之间的连通性；是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP； Traceroute： 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径，发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文； 路由选择协议基本概念：从路由算法的自适应性考虑可分为：静态路由选择策略和动态路由选择策略： 静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。 路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF； 自治系统间的路由选择：BGP 内部网关协议 RIP： RIP是一种分布式的基于距离向量的路由选择协议，RIP 协议中的距离即为跳数，RIP允许一条路径最多只能包含 15 个路由器。跳数的最大值为16 时相当于不可达。可见RIP只适用于小型互联网。 RIP协议的三个要点：1.仅和相邻路由器交换信息；2.交换的信息是当前本路由器所知道的全部信息，即自己的路由表；3.按固定的时间间隔(30秒)交换路由信息； 优缺点：优点：RIP 协议实现简单，开销小。缺点：但是 RIP 能使用的最大距离为 15，限制了网络的规模；并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器；同时仅基于跳数选择最佳路由也不够合理； 内部网关协议 OSPF(Open Shortest Path First) 基本特点：1.“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的;2.“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF; 三个要点 :1.向本自治系统中所有路由器发送信息，使用的方法是洪泛法。2.发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。3.只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 OSPF 能够用于规模很大的网，的更新过程收敛得快; 外部网关协议 BGP BGP 是不同自治系统的路由器之间交换路由信息的协议。 因特网的规模太大，使得自治系统之间路由选择非常困难； 边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由； 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 虚拟专用网VPN专用网段：10.0.0.0 到 10.255.255.255172.16.0.0 到 172.31.255.255192.168.0.0 到 192.168.255.255 这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换NAT需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP。 所有使用本地地址的主机在和外界通信时都要在 NAT 路由器上将其本地地址转换成 IP才能和因特网连。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 Internet组播管理协议 IGMP 当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。 因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络层","slug":"网络层","permalink":"https://chrisxb1996.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"}]},{"title":"数据链路层","slug":"计算机网络/数据链路层","date":"2020-05-15T07:05:33.000Z","updated":"2020-05-18T04:47:50.792Z","comments":true,"path":"2020/05/15/计算机网络/数据链路层/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"基本问题基本概念：1.主机H1向H2发送数据：层次上来看：仅从数据链路层观察帧的流动： 注意：可以看到路由器只到网络层(三层协议)，没有应用层，和传输层；","text":"基本问题基本概念：1.主机H1向H2发送数据：层次上来看：仅从数据链路层观察帧的流动： 注意：可以看到路由器只到网络层(三层协议)，没有应用层，和传输层； 2.数据链路层传输的是帧： 数据链路层的三个基本点：1.封装成帧2.透明传输3.差错控制 封装成帧：封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。 透明传输：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 差错控制：在数据链路层传送的帧中，广泛使用了循环冗余检验 (CRC) 的检错技术：CRC是一种无比特差错，而不是无传输差错的检测机制。将得到的FCS(帧检验序列 )添加在原序列后面，在接收端检验：若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)；若余数 R != 0，则判定这个帧有差错，就丢弃，在高层进行重传指令。 数据链路层的信道类型点对点信道：使用一对一的点对点通信方式，不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议，支持身份验证，支持多个网络层协议。PPP协议帧格式：1.A、C：在点到点信道没有实际意义，固定为：FF、03；2.协议字段(2字节)：用于标识信息部分是什么内容；3.FCS(2字节)：表示CRC得到的帧检验序列； 广播信道：这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送(随机接入)：CSMA/CD(载波监听多点接入/碰撞检测) 协议：多点接入：表示许多计算机以多点接入的方式连接在一根总线上。载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。以太网中经过计算，最短有效帧长为512bit，也就是64个字节，规定凡是长度小于64字节的帧都是无效帧。当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。注意：该协议只能(只能进行半双工通信)。 以太局域网概述：以太网是一种星型拓扑结构局域网。早期使用集线器(hub)进行连接，集线器是一种物理层设备， 作用于比特而不是帧。目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。以太网提供的服务是不可靠的交付，即尽最大努力的交付。当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 信道利用率：一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲时为止，是发送一帧所需的平均时间。 信道利用率可以表示为：T0/发送一帧所需的平均时间。 MAC层(数据链路层的子层)：在局域网中，硬件地址又称为物理地址，或 MAC 地址。MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。以太网MAC帧格式： 扩展以太网网桥(淘汰)：在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。 交换机：交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。1.端口独享带宽；2.比集线器安全，可以设置固定MAC地址；3.接口到计算机全双工；4.全双工模式不再使用CSMA/CD协议；5.接口可以工作在不同的速率；6.广播帧会转发到全部端口； 虚拟局域网(VLAN):虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。例如：在研发部某台主机广播的消息只能住研发部收到，销售部和人力资源部则收不到消息。使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据链路层","slug":"数据链路层","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"}]},{"title":"计算机网络概述","slug":"计算机网络/计算机网络概述","date":"2020-05-15T06:26:57.000Z","updated":"2020-05-16T09:21:03.551Z","comments":true,"path":"2020/05/15/计算机网络/计算机网络概述/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","excerpt":"OSI七层参考模型:1.应用层：能够产生网络流量能够和用户交互的应用程序；2.表示层：加密，压缩，开发人员；3.会话层：服务和客户建立的会话：netstat -n；4.传输层：可靠传输建立会话，不可靠传输，流量控制；5.网络层：IP地址编址，选择最佳路径；","text":"OSI七层参考模型:1.应用层：能够产生网络流量能够和用户交互的应用程序；2.表示层：加密，压缩，开发人员；3.会话层：服务和客户建立的会话：netstat -n；4.传输层：可靠传输建立会话，不可靠传输，流量控制；5.网络层：IP地址编址，选择最佳路径；6.数据链路层：数据如何封装，添加物理层地址(MAC)；7.物理层：电压，借口标准； 网络排错：从底层到高层 五层参考模型:传输的过程：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2020-05-14T07:56:13.000Z","updated":"2020-05-15T06:47:57.322Z","comments":true,"path":"2020/05/14/设计模式-工厂模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"核心：实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。三种类型的工厂模式：1.简单工厂（使用较多）：又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；2.工厂方法：为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，但实际上，我们一般都用简单工厂模式；","text":"核心：实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。三种类型的工厂模式：1.简单工厂（使用较多）：又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；2.工厂方法：为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，但实际上，我们一般都用简单工厂模式；3.抽象工厂：用来生产不同产品族的全部产品：在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式； 不使用工厂模式的情况： 123456public class Audi implements Car&#123; @Override public void run() &#123; System.out.println(\"Audi跑！！！\"); &#125;&#125; 123456public class Byd implements Car&#123; @Override public void run() &#123; System.out.println(\"Byd跑！！！\"); &#125;&#125; 12345678public class test01 &#123; //调用者 public static void main(String[] args) &#123; Car c1 = new Audi(); Car c2 = new Byd(); c1.run(); c2.run(); &#125;&#125; 简单工厂： 12345678public class CarFactory &#123; public static Car createAudi()&#123; return new Audi(); &#125; public static Car createByd()&#123; return new Byd(); &#125;&#125; 12345678public class test01 &#123;//调用者 public static void main(String[] args) &#123; Car car1 = CarFactory.createAudi(); Car car2 = CarFactory.createByd(); car1.run(); car2.run(); &#125;&#125; 工厂方法：增加两个实现类： 1234567891011121314151617public interface CarFactory &#123; Car createCar();&#125;public class AudiFactory implements CarFactory&#123; @Override public Car createCar() &#123; return new Audi(); &#125;&#125;public class BydFactory implements CarFactory&#123; @Override public Car createCar() &#123; return new Byd(); &#125;&#125; 12345678public class test01 &#123;//调用者 public static void main(String[] args) &#123; Car car1 = new AudiFactory().createCar(); Car car2 = new BydFactory().createCar(); car1.run(); car2.run(); &#125;&#125; 抽象工厂：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2020-05-13T09:12:28.000Z","updated":"2020-05-14T13:07:29.495Z","comments":true,"path":"2020/05/13/设计模式-单例模式/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。常见应用场景：Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…常见的五种单例模式实现方式： 1.饿汉式：线程安全，调用效率高。 但是，不能延时加载； 2.懒汉式：线程安全，调用效率不高，可以延时加载； 3.静态内部类式：线程安全，调用效率高，可以延时加载；","text":"核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。常见应用场景：Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…常见的五种单例模式实现方式： 1.饿汉式：线程安全，调用效率高。 但是，不能延时加载； 2.懒汉式：线程安全，调用效率不高，可以延时加载； 3.静态内部类式：线程安全，调用效率高，可以延时加载； 4.枚举式：线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化创建对象的漏洞！ 5.双重检测锁式：JVM底层内部模型原因，偶尔会出问题。不建议使用； 饿汉式： 1234567891011//饿汉式：public class SingletonDemo01 &#123; //类初始化时，上来先创建对象（没有延时加载的优势），加载类时，天然线程安全 private static SingletonDemo01 instance = new SingletonDemo01(); //构造器私有 private SingletonDemo01()&#123;&#125; //优点：方法没有同步调用效率高 public static SingletonDemo01 getInstance()&#123; return instance; &#125;&#125; 懒汉式： 123456789101112//懒汉式：public class SingletonDemo02 &#123; //类初始化时，不创建对象（延时加载，真正用的时候再创建） private static SingletonDemo02 instance; //构造器私有 private SingletonDemo02()&#123;&#125; //需要加同步，保证单例模式，效率较低 public static synchronized SingletonDemo02 getInstance()&#123; if(instance == null) instance = new SingletonDemo02(); return instance; &#125;&#125; 静态内部类式: 123456789101112//静态内部类方式：线程安全，调用效率高，实现延时加载public class SingletonDemo03 &#123; private static class SingletonInnerClass&#123; private static final SingletonDemo03 instance = new SingletonDemo03(); &#125; //构造器私有 private SingletonDemo03()&#123;&#125; //优点：方法没有同步调用效率高 public static SingletonDemo03 getInstance()&#123; return SingletonInnerClass.instance; &#125;&#125; 枚举式: 1234567//枚举类方式：线程安全，但没有延时加载；同时能够避免反射和反序列的漏洞public enum SingletonDemo04 &#123; INSTANCE; //可以自己添加一些操作方法 public static void instanceOper()&#123; &#125;&#125; 如何选用合适的单例模式：单例对象占用资源少，不需要延时加载：枚举式 &gt; 饿汉式;单例对象占用资源大，需要 延时加载：静态内部类式 &gt; 懒汉式;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"JVM核心机制-类加载过程","slug":"JVM核心机制-类加载过程","date":"2020-05-13T06:38:30.000Z","updated":"2020-05-18T04:49:14.599Z","comments":true,"path":"2020/05/13/JVM核心机制-类加载过程/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口： 类加载器的层次结构(树状结构): 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader；","text":"类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口： 类加载器的层次结构(树状结构): 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader； 扩展类加载器（extensions class loader）：用来加载 Java 的扩展库，Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类，由ExtClassLoader实现； 应用程序类加载器（application class loader）：它根据 Java 应用的类路径来加载 Java 类，一般来说，Java 应用的类都是由它来完成加载的，由AppClassLoader实现； 自定义类加载器： 开发人员可以通过继承 java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。 注意：类加载器加载类的时候是线程安全的 双亲委托机制： 就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 双亲委托机制是为了保证 Java 核心库的类型安全，这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。 类加载器除了用于加载类，也是安全的最基本的屏障。 双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制：tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://chrisxb1996.github.io/tags/JVM/"}]},{"title":"Java 动态编译","slug":"Java-动态编译","date":"2020-05-12T07:20:23.000Z","updated":"2020-05-14T03:19:01.203Z","comments":true,"path":"2020/05/12/Java-动态编译/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/12/Java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/","excerpt":"Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：通过JavaCompiler动态编译： 1234567public static int compileFile(String sourceFile)&#123; //动态编译 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null,sourceFile); System.out.println(result==0?\"编译成功\":\"编译失败\"); return result;&#125; • 第一个参数：为java编译器提供参数• 第二个参数：得到 Java 编译器的输出信息","text":"Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：通过JavaCompiler动态编译： 1234567public static int compileFile(String sourceFile)&#123; //动态编译 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null,sourceFile); System.out.println(result==0?\"编译成功\":\"编译失败\"); return result;&#125; • 第一个参数：为java编译器提供参数• 第二个参数：得到 Java 编译器的输出信息• 第三个参数：接收编译器的 错误信息• 第四个参数：可变参数（是一个String数组）能传入一个或多个 Java 源文件• 返回值：0表示编译成功，非0表示编译失败 动态运行编译好的类： 通过Runtime.getRuntime()运行启动新的进程运行12Runtime run = Runtime.getRuntime();Process process = run.exec(\"java -cp path HelloWorld\"); 通过反射运行编译好的类12345678910111213//通过反射运行程序public static void runJavaClassByReflect(String dir,String classFile) throws Exception&#123; try &#123; URL[] urls = new URL[] &#123;new URL(\"file:/\"+dir)&#125;; URLClassLoader loader = new URLClassLoader(urls); Class c = loader.loadClass(classFile); //调用加载类的main方法 Method m = c.getMethod(\"main\",String[].class) m.invoke(null, (Object)new String[]&#123;&#125;);//反射调用main方法加(object)强制转型 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"}]},{"title":"Java 反射","slug":"Java-反射","date":"2020-05-11T13:35:34.000Z","updated":"2020-05-13T06:36:53.159Z","comments":true,"path":"2020/05/11/Java-反射/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/11/Java-%E5%8F%8D%E5%B0%84/","excerpt":"虽然Java不是动态语言1，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。反射：指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。反射机制的作用：重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。","text":"虽然Java不是动态语言1，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。反射：指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。反射机制的作用：重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。获取Class对象：1.Class.forName();(常用)2.getClass();3..class;代码： javaBean:1234567891011121314151617181920212223242526272829303132public class User &#123; private int id; private int age; private String name; //javabean一定要有无参构造器 public User() &#123; &#125; public User(int id, int age, String name) &#123; super(); this.id = id; this.age = age; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 获得User类的反射对象：1234567String path = \"com.sxt.test.bean.User\";Class clazz = Class.forName(path);//方法一User u = new User();Class clazz2 = u.getClass();//方法二Class clazz3 = com.sxt.test.bean.User.class;//方法三 获得User类的属性：1Field f = clazz.getDeclaredField(\"name\"); 获得User类的方法：123Method m01 = clazz.getDeclaredMethod(\"getName\", null);//如果方法有参数，则必须传递参数类型对应的Class对象Method m02 = clazz.getDeclaredMethod(\"setName\", String.class); 获得User类指定的构造器：1Constructor constructor = clazz.getDeclaredConstructor(int.class,int.class,String.class); 通过反射API动态的操作：构造器，方法，属性：123456789101112131415//通过反射API调用构造方法，构造对象User u1 = (User) clazz.getConstructor().newInstance();//调用了User的无参构造器User u2 = (User)clazz.getConstructor(int.class,int.class,String.class).newInstance(1001,18,\"席博\");//调用了User带参构造器//通过反射API调用普通方法 invoke(对象，参数)方法User u3 = (User) clazz.getConstructor().newInstance();Method method = clazz.getDeclaredMethod(\"setName\", String.class);method.invoke(u3, \"aaa\");//u3.setName(\"aaa\");//通过反射API操作属性User u4 = (User) clazz.getConstructor().newInstance();Field f = clazz.getDeclaredField(\"name\");//通过反射获得属性f.setAccessible(true); //这个属性不需要做安全检查，可以直接访问f.set(u4, \"bbb\"); //通过反射直接写u4属性f.get(u4);//通过反射读取u4属性 通过反射读取泛型的信息：ParameterizedType: 表示一种参数化的类型，比如Collection； 通过反射读取注解的信息，模拟处理注解信息的流程，具体参见：Java 注解 反射的性能问题：使用反射性能会降低(约30倍)，setAccessible：启用和禁用访问安全检查的开关，设为 true 则表示反射的对象在使用时禁止 Java 语言访问检查。禁止安全检查，可以提高反射的运行速度(大约提高四倍)。 1.动态语言：程序运行时，可以改变程序结构或变量类型。常见的动态语言：Python、ruby、javascript ↩","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"reflection","slug":"reflection","permalink":"https://chrisxb1996.github.io/tags/reflection/"},{"name":"反射","slug":"反射","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java 注解","slug":"Java-注解","date":"2020-05-10T03:56:57.000Z","updated":"2020-05-14T03:16:59.928Z","comments":true,"path":"2020/05/10/Java-注解/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/10/Java-%E6%B3%A8%E8%A7%A3/","excerpt":"Annotation的作用：1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)Annotation的格式：注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value=”unchecked”)。(抑制警告)Annotation在哪里使用：可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。","text":"Annotation的作用：1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)Annotation的格式：注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value=”unchecked”)。(抑制警告)Annotation在哪里使用：可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。自定义注解：格式：public @interface 注解名 {定义体}1.方法的名称就是参数的名称;2.返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）;3.可以通过default来声明参数的默认值1;4.如果只有一个参数成员，一般参数名为value;元注解：元注解的作用就是负责注解其他注解。 Java定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。1.@Target：用于描述注解的使用范围（即:被描述的注解可以用在什么地方）ElementType.TYPE；ElementType.FIELD…2.@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期SOURCE；CLASS；RUNTIME(可被反射机制读取)3.@Documented4.@Inherited通过反射读取注解的流程： 自定义类注解： 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface test01Table &#123; String value();&#125; 自定义属性注解： 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface test01Field &#123; String columnName(); String type(); int length();&#125; 在test01中加入注解： 123456789@test01Table(\"tb_member\")public class test01 &#123; @test01Field(columnName = \"id\", type = \"int\", length = 10) private int id; @test01Field(columnName = \"sname\", type = \"varchar\", length = 10) private String name; @test01Field(columnName = \"age\", type = \"int\", length = 3) private int age;&#125; 读取test01中的注解： 12345678910111213141516171819202122232425262728/** * 通过反射读取自定义注解 */public class ReadAnnotation &#123; public static void main(String[] args) &#123; try &#123; Class clazz = Class.forName(\"com.sgg.annotation.test01\"); //获得类的有效注解 Annotation[] annotations = clazz.getAnnotations(); for(Annotation a : annotations)&#123; System.out.println(a); &#125; //获得类的制定注解 test01Table tt = (test01Table)clazz.getAnnotation(test01Table.class); System.out.println(tt.value()); //获得类的属性的对应注解 Field f = clazz.getDeclaredField(\"id\"); test01Field tf = (test01Field)f.getAnnotation(test01Field.class); System.out.println(tf.columnName() +\"--\"+ tf.type() +\"--\"+ tf.length()); //接下来可以利用注解信息写出DDL语句，完成相应的数据库操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义 ↩","categories":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"annotation","slug":"annotation","permalink":"https://chrisxb1996.github.io/tags/annotation/"}]},{"title":"用hexo搭建个人博客","slug":"用hexo搭建个人博客","date":"2020-05-09T08:50:49.000Z","updated":"2020-05-13T04:46:33.638Z","comments":true,"path":"2020/05/09/用hexo搭建个人博客/","link":"","permalink":"https://chrisxb1996.github.io/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"准备工作安装git：https://git-scm.com安装nodejs：https://nodejs.org/en/安装hexo1.以管理员身份运行：sudo su2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。","text":"准备工作安装git：https://git-scm.com安装nodejs：https://nodejs.org/en/安装hexo1.以管理员身份运行：sudo su2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。3.在国内建议先安装淘宝镜像源 cnpm再进行安装hexo：输入：npm install -g cnpm –registry=https://registry.npm.taobao.org; 安装完后查 看是否安装成功： cnpm -v： 利用cnpm安装hexo博客 ：cnpm install -g hexo-cli 安装成功可查看hexo信息：hexo -v: 4.可以新建一个 文件夹作为存放目录：mkdir blog，进到目录中：cd blog/ (注意操作都在当前文件夹下进行操作)5.至此，hexo已经为你生成了基础博客框架，启动hexo输入 :hexo s6.在浏览器输入地址http://localhost:4000 可以看到基本框架已经生成。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/categories/hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chrisxb1996.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chrisxb1996.github.io/tags/nodejs/"}]}],"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/categories/Java/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/categories/hexo/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"应用层","slug":"应用层","permalink":"https://chrisxb1996.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"传输层","slug":"传输层","permalink":"https://chrisxb1996.github.io/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"网络层","slug":"网络层","permalink":"https://chrisxb1996.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"数据链路层","slug":"数据链路层","permalink":"https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"name":"Java","slug":"Java","permalink":"https://chrisxb1996.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"JVM","slug":"JVM","permalink":"https://chrisxb1996.github.io/tags/JVM/"},{"name":"reflection","slug":"reflection","permalink":"https://chrisxb1996.github.io/tags/reflection/"},{"name":"反射","slug":"反射","permalink":"https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"annotation","slug":"annotation","permalink":"https://chrisxb1996.github.io/tags/annotation/"},{"name":"git","slug":"git","permalink":"https://chrisxb1996.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://chrisxb1996.github.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chrisxb1996.github.io/tags/nodejs/"}]}