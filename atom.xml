<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xNotes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chrisxb1996.github.io/"/>
  <updated>2020-05-17T14:37:51.198Z</updated>
  <id>https://chrisxb1996.github.io/</id>
  
  <author>
    <name>xNotes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>传输层</title>
    <link href="https://chrisxb1996.github.io/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://chrisxb1996.github.io/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2020-05-17T08:06:11.000Z</published>
    <updated>2020-05-17T14:37:51.198Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#概述">概述</a><ul><li><a href="#进程之间的通信">进程之间的通信:</a></li><li><a href="#tcp和udp">TCP和UDP:</a></li><li><a href="#传输层的端口">传输层的端口:</a></li></ul></li><li><a href="#udp">UDP</a></li><li><a href="#tcp">TCP</a><ul><li><a href="#tcp概述">TCP概述：</a></li><li><a href="#tcp报文首部格式">TCP报文首部格式：</a></li><li><a href="#tcp可靠传输原理">TCP可靠传输原理：</a></li><li><a href="#tcp滑动窗口">TCP滑动窗口：</a></li><li><a href="#tcp流量控制">TCP流量控制</a></li><li><a href="#tcp拥塞控制">TCP拥塞控制</a></li><li><a href="#tcp链接管理">TCP链接管理</a></li></ul></li></ul><!-- tocstop --><a id="more"></a> <h3><span id="概述">概述</span></h3><h4><span id="进程之间的通信">进程之间的通信:</span></h4><ul><li>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</li><li><strong>传输层向它上面的应用层提供通信服务</strong>，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</li></ul><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/传输层协议概述.png" width="100%" height="100%"><h4><span id="tcp和udp">TCP和UDP:</span></h4><p>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。</p><ul><li>用户数据报协议 UDP (User Datagram Protocol)：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP (Transmission Control Protocol)：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h4><span id="传输层的端口">传输层的端口:</span></h4><p>运行在计算机中的进程是用<strong>进程标识符</strong>来标志的，为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。解决这个问题的方法就是在运输层使用协议端口号(protocol port number)，或通常简称为<strong>端口</strong>(port)。</p><ul><li>端口用一个 16 位端口号进行标志。</li><li>端口号只具有<strong>本地意义</strong>，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。</li><li>三类端口 ：<br>1.熟知端口，数值一般为 0-1023；<br>2.登记端口号，数值为1024-49151，为没有熟知端口号的应用程序使用的；<br>3.客户端口号，数值为49152-65535，留给客户进程选择暂时使用；</li><li>常用应用层协议与传输层端口：<br>http = TCP + 80；<br>https = TCP + 443；<br>ftp = TCP + 21；<br>SMTP = TCP + 25；<br>POP3 = TCP + 101；<br>RDP = TCP + 3389；<br>SQL = TCP + 1433；<br>DNS = UDP + 53  or  TCP + 53(极少情况)</li><li><strong>计算机服务(对外的服务)运行后在TCP或UDP的某个端口侦听客户端请求。</strong></li></ul><h3><span id="udp">UDP</span></h3><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p><ul><li>UDP 是<u><strong>无连接的</strong></u>，即发送数据之前不需要建立连接<u>(主要针对短包，实时性要求不高的数据)</u>。</li><li>UDP 使用尽最大努力交付，即<u><strong>不保证可靠交付</strong></u>，同时也<u><strong>不使用拥塞控制</strong></u>。</li><li>UDP 是<u><strong>面向报文</strong>的</u>。UDP 没有拥塞控制，很适合多媒体通信的要求。</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信。 </li><li>UDP 的首部开销小，只有 8 个字节。</li></ul><p><strong>面向报文：</strong>送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。应用程序必须选择合适大小的报文。</p><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP面向报文.png" width="100%" height="100%"><p><strong>UDP首部格式：</strong>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP首部.png" width="100%" height="100%"><h3><span id="tcp">TCP</span></h3><h4><span id="tcp概述">TCP概述：</span></h4><p>主要特点:<br>1.TCP是<strong>面向连接</strong>的运输层协议；<br>2.每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是<strong>点对点</strong>的(一对一)；<br>3.TCP 提供<strong>可靠交付</strong>的服务；<br>4.TCP 提供<strong>全双工通信</strong>；<br>5.<strong>面向字节流</strong>；</p><p><strong>面向字节流的传输过程：</strong></p><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP面向字节流的传输过程.png" width="100%" height="100%"><p><strong>注意：</strong><br>1.TCP 连接是一条虚连接而不是一条真正的物理连接。<br>2.TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong><u>套接字(socket)</u></strong>，端口号拼接到 IP 地址即构成了套接字。<br>套接字 socket = (IP地址: 端口号)；<br>3.每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：<br>TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}；</p><h4><span id="tcp报文首部格式">TCP报文首部格式：</span></h4><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP首部格式.png" width="100%" height="100%"><ul><li><strong>源端口和目的端口字段——各占 2 字节</strong>，端口传输层与应用层的服务接口。传输层的复用和分用功能都要通过端口才能实现。 </li><li><strong>序号字段——占 4 字节</strong>，TCP 连接中传送的字节流中的每一个数据段都编上一个序号。序号字段的值则指的是<strong>本报文段</strong>所发送的数据的<strong>第一个字节的序号</strong>。</li><li><strong>确认号字段——占 4 字节</strong>，是期望收到对方的<strong>下一个报文段</strong>的数据的第<strong>一个字节的序号</strong>。</li><li><strong>数据偏移(即首部长度)——占 4 位</strong>，它表示首部长度，最长60个字节，故可变长度最长40个字节。</li><li><strong>保留字段——占 6 位</strong>，保留为今后使用，但目前应置为 0。 </li><li><strong>紧急 URG</strong> —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。</li><li><strong>确认 ACK</strong> —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 </li><li><strong>推送 PSH</strong> —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </li><li><strong>复位 RST</strong>  —— 当 RST = 1 时，表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。</li><li><strong>同步 SYN</strong> —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。</li><li><strong>终止 FIN</strong> —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li><li><strong>窗口字段 —— 占 2 字节</strong>，用来让对方设置发送窗口的依据，单位为字节。 </li><li><strong>检验和 —— 占 2 字节</strong>，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li><strong>紧急指针字段 —— 占 16 位</strong>，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。  </li></ul><h4><span id="tcp可靠传输原理">TCP可靠传输原理：</span></h4><p><strong>停止等待协议：</strong></p><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP可靠传输.png" width="100%" height="100%"><p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信，这种可靠传输协议常称为<strong>自动重传请求ARQ(Automatic Repeat reQuest)</strong> 。</p><h4><span id="tcp滑动窗口">TCP滑动窗口：</span></h4><ul><li>停止等待协议的优点是简单，但缺点是信道利用率太低。</li></ul><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/停止等待协议缺点.png" width="100%" height="100%"><ul><li><p>针对这一缺点，一般采用<strong>滑动窗口(流水线传输)</strong>和<strong>累积确认(接收窗口)</strong>的方法提高信道利用率。</p><p><strong>1.滑动窗口：</strong>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。<br><strong>2.累积确认：</strong>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：<strong>到这个分组为止的所有分组都已正确收到了</strong>。</p></li></ul><img src="/2020/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/流水线传输和滑动窗口.png" width="100%" height="100%"><h4><span id="tcp流量控制">TCP流量控制</span></h4><h4><span id="tcp拥塞控制">TCP拥塞控制</span></h4><h4><span id="tcp链接管理">TCP链接管理</span></h4>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概述&quot;&gt;概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#进程之间的通信&quot;&gt;进程之间的通信:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp和udp&quot;&gt;TCP和UDP:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#传输层的端口&quot;&gt;传输层的端口:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#udp&quot;&gt;UDP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp&quot;&gt;TCP&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#tcp概述&quot;&gt;TCP概述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp报文首部格式&quot;&gt;TCP报文首部格式：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp可靠传输原理&quot;&gt;TCP可靠传输原理：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp滑动窗口&quot;&gt;TCP滑动窗口：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp流量控制&quot;&gt;TCP流量控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp拥塞控制&quot;&gt;TCP拥塞控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp链接管理&quot;&gt;TCP链接管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="传输层" scheme="https://chrisxb1996.github.io/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2020-05-15T13:55:05.000Z</published>
    <updated>2020-05-17T08:00:48.262Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#概述">概述</a></li><li><a href="#tcpip协议栈">TCP/IP协议栈</a></li><li><a href="#ip地址编址">IP地址编址</a><ul><li><a href="#点分十进制记法">点分十进制记法：</a></li><li><a href="#分类">分类：</a></li><li><a href="#划分子网">划分子网：</a></li><li><a href="#构造超网无分类cidr">构造超网(无分类CIDR)：</a></li><li><a href="#计算机a到b的通信过程">计算机A到B的通信过程：</a></li></ul></li><li><a href="#arp协议">ARP协议</a></li><li><a href="#ip数据包">IP数据包</a></li><li><a href="#ip转发分组">IP转发分组</a></li><li><a href="#网际控制报文协议-icmp">网际控制报文协议 ICMP</a></li><li><a href="#路由选择协议">路由选择协议</a><ul><li><a href="#基本概念">基本概念：</a></li><li><a href="#内部网关协议-rip">内部网关协议 RIP：</a></li><li><a href="#内部网关协议-ospfopen-shortest-path-first">内部网关协议 OSPF(Open Shortest Path First)</a></li><li><a href="#外部网关协议-bgp">外部网关协议 BGP</a></li></ul></li><li><a href="#虚拟专用网vpn">虚拟专用网VPN</a></li><li><a href="#网络地址转换nat">网络地址转换NAT</a></li><li><a href="#internet组播管理协议-igmp">Internet组播管理协议 IGMP</a></li></ul><!-- tocstop --><a id="more"></a> <h3><span id="概述">概述</span></h3><ul><li>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</li></ul><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/虚拟互联网络.png" width="100%" height="100%"><h3><span id="tcpip协议栈">TCP/IP协议栈</span></h3><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/协议栈.png" width="80%" height="80%"><h3><span id="ip地址编址">IP地址编址</span></h3><h4><span id="点分十进制记法">点分十进制记法：</span></h4><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/点分十进制记法.png" width="100%" height="100%"><h4><span id="分类">分类：</span></h4><ul><li><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。<br>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p></li><li><p>1-126：A类地址，127是本机地址；<br>128-191：B类地址；<br>192-223：C类地址；<br>224-240：D类地址；</p></li></ul><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/IP地址分类.png" width="100%" height="100%"><ul><li><strong>特殊的几个地址：</strong><br>127.0.0.1   本地环回地址；<br>169.254.0.0   windows链接失败自动分配的地址；<br>10.0.0.0   保留的私网地址；<br>172.16.0.0   —   172.31.0.0   保留的私网地址；<br>192.168.0.0  —   192.168.255.0   保留的私网地址；</li></ul><h4><span id="划分子网">划分子网：</span></h4><ul><li><p>通过在<strong>主机号字段中拿一部分作为子网号</strong>，把两级 IP 地址划分为三级 IP 地址。划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</p></li><li><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p></li><li><p>要使用子网，必须配置子网掩码。例如：一个 C 类地址的默认子网掩码为 255.255.255.0，如果 B 类地址的子网占两个比特，那么子网掩码为11111111 11111111 11111111 11000000，也就是 255.255.255.192。</p></li></ul><p><strong>注意：</strong>外部网络看不到子网的存在。</p><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/子网划分.png" width="100%" height="100%"><h4><span id="构造超网无分类cidr">构造超网(无分类CIDR)：</span></h4><ul><li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li><li>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。从三级编址（使用子网掩码）又回到了两级编址。</li><li>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}      </li><li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。路由聚合也称为构成超网(supernetting)。</li><li>CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。</li><li>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</li></ul><h4><span id="计算机a到b的通信过程">计算机A到B的通信过程：</span></h4><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/数据通信过程.png" width="100%" height="100%"><h3><span id="arp协议">ARP协议</span></h3><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/ARP.png" width="100%" height="100%"><ul><li><p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 </p></li><li><p>每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p></li><li><p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 </p></li></ul><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/ARP请求过程.png" width="100%" height="100%"><p><strong>注意：</strong>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p><h3><span id="ip数据包">IP数据包</span></h3><ul><li>一个 IP 数据包由首部和数据两部分组成。</li><li>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/IP数据包.png" width="100%" height="100%"><ul><li><strong>版本——占 4 位：</strong>指 IP 协议的版本：4（IPv4）和 6（IPv6）</li><li><strong>首部长度——占 4 位：</strong>可表示的最大数值，是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。</li><li><strong>区分服务——占 8 位：</strong>用来获得更好的服务，在一般的情况下都不使用这个字段 。</li><li><strong>总长度——占 16 位：</strong>指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li><li><strong>标识——占 16 位：</strong>它是一个计数器，用来产生数据报的标识。 </li><li><strong>标志——占 3 位：</strong>目前只有前两位有意义。</li><li><strong>生存时间——占 8 位：</strong>记为 TTL (Time To Live)，数据报在网络中可通过的路由器个数的最大值。</li><li><strong>协议——占 8 位：</strong>该字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程。</li><li><strong>首部检验和——占 16 位：</strong>因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量(简单计算)。</li><li><strong>源地址和目的地址——占 32 位：</strong>都各占 4 字节。</li><li><strong>片偏移——占 312位：</strong>较长的分组在分片后某片在原分组中的相对位置。片偏移以 <strong>8 个字节为偏移单位</strong>。</li></ul><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/IP数据报分片.png" width="100%" height="100%"><p><strong>注意：</strong>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。 </p><h3><span id="ip转发分组">IP转发分组</span></h3><ul><li>路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。</li><li>网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。(有去有回)</li><li>这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。</li></ul><p><strong>注意：IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</strong> </p><h3><span id="网际控制报文协议-icmp">网际控制报文协议 ICMP</span></h3><ul><li>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 不是高层协议，而是 IP 层的协议。</li><li>ICMP 报文的种类有两种，即 ICMP <strong>差错报告报文</strong>和 ICMP <strong>询问报文</strong>。</li><li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即<strong>类型</strong>、<strong>代码</strong>和<strong>检验和</strong>。接着的 4 个字节的内容与 ICMP 的类型有关。 </li></ul><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP报文格式.png" width="100%" height="100%"><ul><li>几种常见的ICMP报文类型：</li></ul><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP报文类型.png" width="100%" height="100%"><ul><li><strong>Ping：</strong>用来测试两个主机之间的连通性；是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP；</li><li><strong>Traceroute：</strong> 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径，发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文；</li></ul><h3><span id="路由选择协议">路由选择协议</span></h3><h4><span id="基本概念">基本概念：</span></h4><p>从路由算法的自适应性考虑可分为：静态路由选择策略和动态路由选择策略：</p><ul><li>静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 </li><li>动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。 </li></ul><p><strong>路由选择协议都是自适应的</strong>，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类：</p><ul><li><strong>自治系统内部的路由选择</strong>：RIP 和 OSPF；</li><li><strong>自治系统间的路由选择</strong>：BGP</li></ul><h4><span id="内部网关协议-rip">内部网关协议 RIP：</span></h4><ul><li><p>RIP是一种分布式的基于<strong>距离</strong>向量的路由选择协议，RIP 协议中的<strong>距离</strong>即为<strong>跳数</strong>，RIP允许一条路径最多只能包含 15 个路由器。跳数的最大值为16 时相当于不可达。可见RIP只适用于小型互联网。</p></li><li><p>RIP协议的三个要点：<br>1.仅和相邻路由器交换信息；<br>2.交换的信息是当前本路由器所知道的全部信息，即自己的路由表；<br>3.按固定的时间间隔(30秒)交换路由信息；</p></li><li><p>优缺点：<br><strong>优点：</strong>RIP 协议实现简单，开销小。<br><strong>缺点：</strong>但是 RIP 能使用的最大距离为 15，限制了网络的规模；并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器；同时仅基于跳数选择最佳路由也不够合理；</p></li></ul><h4><span id="内部网关协议-ospfopen-shortest-path-first">内部网关协议 OSPF(Open Shortest Path First)</span></h4><ul><li><p>基本特点：<br>1.“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的;<br>2.“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF;</p></li><li><p>三个要点 :<br>1.向本自治系统中所有路由器发送信息，使用的方法是洪泛法。<br>2.发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<br>3.只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p></li><li><p>OSPF 能够用于规模很大的网，的更新过程收敛得快;</p></li></ul><h4><span id="外部网关协议-bgp">外部网关协议 BGP</span></h4><p> BGP 是不同自治系统的路由器之间交换路由信息的协议。 </p><ul><li>因特网的规模太大，使得自治系统之间路由选择非常困难；</li><li>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由；</li></ul><p><strong>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</strong></p><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/BGP协议.png" width="100%" height="100%"><h3><span id="虚拟专用网vpn">虚拟专用网VPN</span></h3><p>专用网段：<br>10.0.0.0 到 10.255.255.255<br>172.16.0.0 到 172.31.255.255<br>192.168.0.0 到 192.168.255.255</p><p>这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/VPN.png" width="100%" height="100%"><h3><span id="网络地址转换nat">网络地址转换NAT</span></h3><p>需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP。</p><p>所有使用本地地址的主机在和外界通信时都要在 NAT 路由器上将其本地地址转换成 IP才能和因特网连。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，<strong>使得多个专用网内部的主机共用一个全球 IP 地址</strong>。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><h3><span id="internet组播管理协议-igmp">Internet组播管理协议 IGMP</span></h3><ul><li>当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。</li><li>因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概述&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcpip协议栈&quot;&gt;TCP/IP协议栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ip地址编址&quot;&gt;IP地址编址&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#点分十进制记法&quot;&gt;点分十进制记法：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#分类&quot;&gt;分类：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#划分子网&quot;&gt;划分子网：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#构造超网无分类cidr&quot;&gt;构造超网(无分类CIDR)：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#计算机a到b的通信过程&quot;&gt;计算机A到B的通信过程：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#arp协议&quot;&gt;ARP协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ip数据包&quot;&gt;IP数据包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ip转发分组&quot;&gt;IP转发分组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#网际控制报文协议-icmp&quot;&gt;网际控制报文协议 ICMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#路由选择协议&quot;&gt;路由选择协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基本概念&quot;&gt;基本概念：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内部网关协议-rip&quot;&gt;内部网关协议 RIP：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内部网关协议-ospfopen-shortest-path-first&quot;&gt;内部网关协议 OSPF(Open Shortest Path First)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#外部网关协议-bgp&quot;&gt;外部网关协议 BGP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#虚拟专用网vpn&quot;&gt;虚拟专用网VPN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#网络地址转换nat&quot;&gt;网络地址转换NAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#internet组播管理协议-igmp&quot;&gt;Internet组播管理协议 IGMP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络层" scheme="https://chrisxb1996.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-05-15T07:05:33.000Z</published>
    <updated>2020-05-17T08:07:28.742Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#基本问题">基本问题</a><ul><li><a href="#基本概念">基本概念：</a></li><li><a href="#数据链路层的三个基本点">数据链路层的三个基本点：</a></li></ul></li><li><a href="#数据链路层的信道类型">数据链路层的信道类型</a><ul><li><a href="#点对点信道">点对点信道：</a></li><li><a href="#广播信道">广播信道：</a></li></ul></li><li><a href="#以太局域网">以太局域网</a><ul><li><a href="#概述">概述：</a></li><li><a href="#信道利用率">信道利用率：</a></li><li><a href="#mac层数据链路层的子层">MAC层(数据链路层的子层)：</a></li></ul></li><li><a href="#扩展以太网">扩展以太网</a><ul><li><a href="#网桥淘汰">网桥(淘汰)：</a></li><li><a href="#交换机">交换机：</a></li><li><a href="#虚拟局域网vlan">虚拟局域网(VLAN):</a></li></ul></li></ul><!-- tocstop --><a id="more"></a> <h3><span id="基本问题">基本问题</span></h3><h4><span id="基本概念">基本概念：</span></h4><p>1.主机H1向H2发送数据：<br>层次上来看：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/图片 1.png" width="100%" height="100%"><br>仅从数据链路层观察帧的流动：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/图片 2.png" width="100%" height="100%"></p><p><strong>注意：</strong>可以看到路由器只到网络层(三层协议)，没有应用层，和传输层；</p><p>2.数据链路层传输的是帧：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/数据链路层传送帧.png" width="100%" height="100%"></p><h4><span id="数据链路层的三个基本点">数据链路层的三个基本点：</span></h4><p>1.封装成帧<br>2.透明传输<br>3.差错控制</p><p><strong>封装成帧：</strong>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/封装成帧.png" width="100%" height="100%"></p><p><strong>透明传输：</strong>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/透明传输.png" width="100%" height="100%"></p><p><strong>差错控制：</strong>在数据链路层传送的帧中，广泛使用了循环冗余检验 (CRC) 的检错技术：<strong>CRC是一种无比特差错，而不是无传输差错的检测机制</strong>。将得到的FCS(帧检验序列 )添加在原序列后面，在接收端检验：若得出的余数 <em>R</em> = 0，则判定这个帧没有差错，就接受(accept)；若余数 <em>R</em> != 0，则判定这个帧有差错，就丢弃，在高层进行重传指令。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/CRC.png" width="100%" height="100%"></p><h3><span id="数据链路层的信道类型">数据链路层的信道类型</span></h3><h4><span id="点对点信道">点对点信道：</span></h4><p>使用一对一的点对点通信方式，不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议，支持身份验证，支持多个网络层协议。<br>PPP协议帧格式：<br>1.A、C：在点到点信道没有实际意义，固定为：FF、03；<br>2.协议字段(2字节)：用于标识信息部分是什么内容；<br>3.FCS(2字节)：表示CRC得到的帧检验序列；<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP协议.png" width="100%" height="100%"></p><h4><span id="广播信道">广播信道：</span></h4><p>这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送<strong>(随机接入)</strong>：CSMA/CD(载波监听多点接入/碰撞检测) 协议：<br><strong>多点接入：</strong>表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听：</strong>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br><strong>碰撞检测</strong>：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于传播时延的存在，还是有可能会发生碰撞。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/随机接入碰撞.png" width="100%" height="100%"></p><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，<strong>称 2τ 为 争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。以太网中经过计算，最短有效帧长为512bit，也就是64个字节，规定凡是长度小于64字节的帧都是无效帧。<br>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。<br><strong>注意：</strong>该协议只能(只能进行半双工通信)。</p><h3><span id="以太局域网">以太局域网</span></h3><h4><span id="概述">概述：</span></h4><p><strong>以太网是一种星型拓扑结构局域网。</strong>早期使用集线器(hub)进行连接，<strong>集线器是一种物理层设备</strong>， 作用于比特而不是帧。目前以太网使用交换机替代了集线器，<strong>交换机是一种链路层设备</strong>，它不会发生碰撞，能根据 MAC 地址进行存储转发。<br>以太网提供的服务是不可靠的交付，即尽最大努力的交付。当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p><h4><span id="信道利用率">信道利用率：</span></h4><p>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲时为止，是发送一帧所需的平均时间。 信道利用率可以表示为：T0/发送一帧所需的平均时间。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网信道利用率.png" width="100%" height="100%"> </p><h4><span id="mac层数据链路层的子层">MAC层(数据链路层的子层)：</span></h4><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。<br>以太网MAC帧格式：<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网帧格式.png" width="100%" height="100%"> </p><h3><span id="扩展以太网">扩展以太网</span></h3><h4><span id="网桥淘汰">网桥(淘汰)：</span></h4><p>在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/网桥扩展以太网.png" width="100%" height="100%"> </p><h4><span id="交换机">交换机：</span></h4><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。<br>1.端口独享带宽；<br>2.比集线器安全，可以设置固定MAC地址；<br>3.接口到计算机全双工；<br>4.全双工模式不再使用CSMA/CD协议；<br>5.接口可以工作在不同的速率；<br>6.广播帧会转发到全部端口；<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/交换机.png" width="100%" height="100%"> </p><h4><span id="虚拟局域网vlan">虚拟局域网(VLAN):</span></h4><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。例如：在研发部某台主机广播的消息只能住研发部收到，销售部和人力资源部则收不到消息。<br>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。<br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/VLAN.png" width="100%" height="100%"></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基本问题&quot;&gt;基本问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基本概念&quot;&gt;基本概念：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#数据链路层的三个基本点&quot;&gt;数据链路层的三个基本点：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#数据链路层的信道类型&quot;&gt;数据链路层的信道类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#点对点信道&quot;&gt;点对点信道：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#广播信道&quot;&gt;广播信道：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#以太局域网&quot;&gt;以太局域网&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概述&quot;&gt;概述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#信道利用率&quot;&gt;信道利用率：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#mac层数据链路层的子层&quot;&gt;MAC层(数据链路层的子层)：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#扩展以太网&quot;&gt;扩展以太网&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#网桥淘汰&quot;&gt;网桥(淘汰)：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#交换机&quot;&gt;交换机：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#虚拟局域网vlan&quot;&gt;虚拟局域网(VLAN):&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="数据链路层" scheme="https://chrisxb1996.github.io/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://chrisxb1996.github.io/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2020-05-15T06:26:57.000Z</published>
    <updated>2020-05-16T09:21:03.551Z</updated>
    
    <content type="html"><![CDATA[<p><strong>OSI七层参考模型:</strong><br>1.应用层：能够产生网络流量能够和用户交互的应用程序；<br>2.表示层：加密，压缩，开发人员；<br>3.会话层：服务和客户建立的会话：netstat -n；<br>4.传输层：可靠传输建立会话，不可靠传输，流量控制；<br>5.网络层：IP地址编址，选择最佳路径；<a id="more"></a><br>6.数据链路层：数据如何封装，添加物理层地址(MAC)；<br>7.物理层：电压，借口标准；</p><p><strong>网络排错：</strong>从底层到高层</p><p><strong>五层参考模型:</strong><br><strong>传输的过程：</strong><br><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/001.png" width="100%" height="100%"></p><img src="/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/002.png" width="100%" height="100%">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;OSI七层参考模型:&lt;/strong&gt;&lt;br&gt;1.应用层：能够产生网络流量能够和用户交互的应用程序；&lt;br&gt;2.表示层：加密，压缩，开发人员；&lt;br&gt;3.会话层：服务和客户建立的会话：netstat -n；&lt;br&gt;4.传输层：可靠传输建立会话，不可靠传输，流量控制；&lt;br&gt;5.网络层：IP地址编址，选择最佳路径；&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chrisxb1996.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://chrisxb1996.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="https://chrisxb1996.github.io/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://chrisxb1996.github.io/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-05-14T07:56:13.000Z</published>
    <updated>2020-05-15T06:47:57.322Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心：</strong>实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。<br><strong>三种类型的工厂模式：</strong><br><strong>1.简单工厂（使用较多）：</strong>又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；<br><strong>2.工厂方法：</strong>为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，<strong>但实际上，我们一般都用简单工厂模式</strong>；<a id="more"></a><br><strong>3.抽象工厂：</strong>用来生产不同产品族的全部产品：在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式；</p><p><strong>不使用工厂模式的情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Audi跑！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Byd</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Byd跑！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123; <span class="comment">//调用者</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Car c1 = <span class="keyword">new</span> Audi();</span><br><span class="line">    Car c2 = <span class="keyword">new</span> Byd();</span><br><span class="line">    c1.run();</span><br><span class="line">    c2.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createAudi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createByd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Byd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;<span class="comment">//调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = CarFactory.createAudi();</span><br><span class="line">        Car car2 = CarFactory.createByd();</span><br><span class="line">        car1.run();</span><br><span class="line">        car2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/simplefactory.png" width="32%" height="32%"><p><strong>工厂方法：</strong><br>增加两个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BydFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Byd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;<span class="comment">//调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = <span class="keyword">new</span> AudiFactory().createCar();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> BydFactory().createCar();</span><br><span class="line">        car1.run();</span><br><span class="line">        car2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/factorymethod.png" width="48%" height="48%"><p><strong>抽象工厂：</strong><br><img src="/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abstractfactory.png" width="100%" height="100%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;核心：&lt;/strong&gt;实现了创建者和调用者的分离，用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。&lt;br&gt;&lt;strong&gt;三种类型的工厂模式：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;1.简单工厂（使用较多）：&lt;/strong&gt;又叫静态工厂模式，就是工厂类一般是使用静态方法，通过不同的方法(或是通过传递不同的参数)来返回不同的对象实例；&lt;br&gt;&lt;strong&gt;2.工厂方法：&lt;/strong&gt;为了避免简单工厂模式的缺点，不完全满足OCP（开闭原则）。工厂方法模式和简单工厂模式最大的不同：简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。根据设计理论建议：工厂方法模式，&lt;strong&gt;但实际上，我们一般都用简单工厂模式&lt;/strong&gt;；&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="https://chrisxb1996.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://chrisxb1996.github.io/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://chrisxb1996.github.io/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-05-13T09:12:28.000Z</published>
    <updated>2020-05-14T13:07:29.495Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心作用：</strong>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。<br><strong>常见应用场景：</strong>Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…<br><strong>常见的五种单例模式实现方式：</strong><br>  1.饿汉式：线程安全，调用效率高。 但是，不能延时加载；<br>  2.懒汉式：线程安全，调用效率不高，可以延时加载；<br>  3.静态内部类式：线程安全，调用效率高，可以延时加载；<a id="more"></a><br>  4.枚举式：线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化创建对象的漏洞！<br>  5.<del>双重检测锁式</del>：JVM底层内部模型原因，偶尔会出问题。<strong>不建议使用；</strong></p><p>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时，上来先创建对象（没有延时加载的优势），加载类时，天然线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo01 instance = <span class="keyword">new</span> SingletonDemo01();</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">SingletonDemo01</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//优点：方法没有同步调用效率高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时，不创建对象（延时加载，真正用的时候再创建）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo02 instance;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo02</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//需要加同步，保证单例模式，效率较低</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo02 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> SingletonDemo02();</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类方式：线程安全，调用效率高，实现延时加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo03 instance = <span class="keyword">new</span> SingletonDemo03();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo03</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//优点：方法没有同步调用效率高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  SingletonInnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类方式：线程安全，但没有延时加载；同时能够避免反射和反序列的漏洞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo04 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">//可以自己添加一些操作方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instanceOper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何选用合适的单例模式：</strong><br>单例对象占用资源少，不需要延时加载：枚举式 &gt; 饿汉式;<br>单例对象占用资源大，需要 延时加载：静态内部类式 &gt; 懒汉式;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;核心作用：&lt;/strong&gt;保证一个类只有一个实例，并且提供一个访问该实例的全局访问点,减少了系统性能开销。&lt;br&gt;&lt;strong&gt;常见应用场景：&lt;/strong&gt;Windows的任务管理器就是很典型的单例模式；数据库连接池的设计一般也是采用单例模式…&lt;br&gt;&lt;strong&gt;常见的五种单例模式实现方式：&lt;/strong&gt;&lt;br&gt;  1.饿汉式：线程安全，调用效率高。 但是，不能延时加载；&lt;br&gt;  2.懒汉式：线程安全，调用效率不高，可以延时加载；&lt;br&gt;  3.静态内部类式：线程安全，调用效率高，可以延时加载；&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://chrisxb1996.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://chrisxb1996.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="https://chrisxb1996.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM核心机制-类加载过程</title>
    <link href="https://chrisxb1996.github.io/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://chrisxb1996.github.io/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-05-13T06:38:30.000Z</published>
    <updated>2020-05-13T09:13:29.369Z</updated>
    
    <content type="html"><![CDATA[<p><strong>类加载的作用：</strong>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口：<br><img src="/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/JVM01.png" width="80%" height="80%"></p><p><strong>类加载器的层次结构(树状结构):</strong></p><ul><li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader；<a id="more"></a></li><li>扩展类加载器（extensions class loader）：用来加载 Java 的扩展库，Java 虚拟机的实现会提供一个<strong>扩展库</strong>目录。该类加载器在此目录里面查找并加载 Java类，由ExtClassLoader实现；</li><li>应用程序类加载器（application class loader）：它根据 Java 应用的类路径来加载 Java 类，一般来说，Java 应用的类都是由它来完成加载的，由AppClassLoader实现；</li><li>自定义类加载器： 开发人员可以通过继承 java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。</li></ul><p>注意：<u>类加载器加载类的时候是线程安全的</u></p><img src="/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/JVM02.png" width="80%" height="80%"><p><strong>双亲委托机制：</strong></p><ul><li>就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</li><li>双亲委托机制是为了保证 Java 核心库的类型安全，这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。</li><li>类加载器除了用于加载类，也是安全的最基本的屏障。</li><li>双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制：tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;类加载的作用：&lt;/strong&gt;将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口：&lt;br&gt;&lt;img src=&quot;/2020/05/13/JVM%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/JVM01.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类加载器的层次结构(树状结构):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库)，是用C来实现的，并不继承自 java.lang.ClassLoader；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://chrisxb1996.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 动态编译</title>
    <link href="https://chrisxb1996.github.io/2020/05/12/Java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/"/>
    <id>https://chrisxb1996.github.io/2020/05/12/Java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/</id>
    <published>2020-05-12T07:20:23.000Z</published>
    <updated>2020-05-14T03:19:01.203Z</updated>
    
    <content type="html"><![CDATA[<p>Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测<br>系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：<br><strong>通过JavaCompiler动态编译：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compileFile</span><span class="params">(String sourceFile)</span></span>&#123;</span><br><span class="line">  <span class="comment">//动态编译</span></span><br><span class="line">  JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">  <span class="keyword">int</span> result = compiler.run(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,sourceFile);</span><br><span class="line">  System.out.println(result==<span class="number">0</span>?<span class="string">"编译成功"</span>:<span class="string">"编译失败"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 第一个参数：为java编译器提供参数<br>• 第二个参数：得到 Java 编译器的输出信息<a id="more"></a><br>• 第三个参数：接收编译器的 错误信息<br>• 第四个参数：可变参数（是一个String数组）能传入一个或多个 Java 源文件<br>• 返回值：0表示编译成功，非0表示编译失败</p><p><strong>动态运行编译好的类：</strong></p><ul><li>通过Runtime.getRuntime()运行启动新的进程运行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime run = Runtime.getRuntime();</span><br><span class="line">Process process = run.exec(<span class="string">"java -cp path HelloWorld"</span>);</span><br></pre></td></tr></table></figure></li><li>通过反射运行编译好的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射运行程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runJavaClassByReflect</span><span class="params">(String dir,String classFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:/"</span>+dir)&#125;;</span><br><span class="line">    URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">    Class c = loader.loadClass(classFile);</span><br><span class="line">    <span class="comment">//调用加载类的main方法</span></span><br><span class="line">    Method m = c.getMethod(<span class="string">"main"</span>,String[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">m.invoke(null, (Object)new String[]&#123;&#125;);//反射调用main方法加(object)强制转型</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java1.6以后引入动态编译，在做一个浏览器端编写java代码，上传服务器编译和运行的在线评测&lt;br&gt;系统或是服务器动态加载某些类文件进行编译的时候就用到了动态编译：&lt;br&gt;&lt;strong&gt;通过JavaCompiler动态编译：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compileFile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String sourceFile)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//动态编译&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; result = compiler.run(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;,sourceFile);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.out.println(result==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;?&lt;span class=&quot;string&quot;&gt;&quot;编译成功&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;编译失败&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;• 第一个参数：为java编译器提供参数&lt;br&gt;• 第二个参数：得到 Java 编译器的输出信息&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="https://chrisxb1996.github.io/2020/05/11/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>https://chrisxb1996.github.io/2020/05/11/Java-%E5%8F%8D%E5%B0%84/</id>
    <published>2020-05-11T13:35:34.000Z</published>
    <updated>2020-05-13T06:36:53.159Z</updated>
    
    <content type="html"><![CDATA[<p>虽然Java不是动态语言<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。<br><strong>反射：</strong>指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象<strong>(一个类只有一个 Class 对象)</strong>，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。<br><strong>反射机制的作用：</strong>重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。<a id="more"></a><br><strong>获取Class对象：</strong><br>1.Class.forName();(常用)<br>2.getClass();<br>3..class;<br><strong>代码：</strong></p><ul><li>javaBean:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//javabean一定要有无参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获得User类的反射对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"com.sxt.test.bean.User"</span>;</span><br><span class="line">Class clazz = Class.forName(path);<span class="comment">//方法一</span></span><br><span class="line"></span><br><span class="line">User u = <span class="keyword">new</span> User();</span><br><span class="line">Class clazz2 = u.getClass();<span class="comment">//方法二</span></span><br><span class="line"></span><br><span class="line">Class clazz3 = com.sxt.test.bean.User<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//方法三</span></span><br></pre></td></tr></table></figure></li><li>获得User类的属性：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field f = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure></li><li>获得User类的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method m01 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果方法有参数，则必须传递参数类型对应的Class对象</span></span><br><span class="line">Method m02 = clazz.getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获得User类指定的构造器：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>通过反射API动态的操作：构造器，方法，属性：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射API调用构造方法，构造对象</span></span><br><span class="line">User u1 = (User) clazz.getConstructor().newInstance();<span class="comment">//调用了User的无参构造器</span></span><br><span class="line">User u2 =  (User)clazz.getConstructor(int.class,int.class,String.class).newInstance(1001,18,"席博");//调用了User带参构造器</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射API调用普通方法 invoke(对象，参数)方法</span></span><br><span class="line">User u3 = (User) clazz.getConstructor().newInstance();</span><br><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">method.invoke(u3, <span class="string">"aaa"</span>);<span class="comment">//u3.setName("aaa");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射API操作属性</span></span><br><span class="line">User u4 = (User) clazz.getConstructor().newInstance();</span><br><span class="line">Field f = clazz.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//通过反射获得属性</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//这个属性不需要做安全检查，可以直接访问</span></span><br><span class="line">f.set(u4, <span class="string">"bbb"</span>); <span class="comment">//通过反射直接写u4属性</span></span><br><span class="line">f.get(u4);<span class="comment">//通过反射读取u4属性</span></span><br></pre></td></tr></table></figure></li><li>通过反射读取泛型的信息：ParameterizedType: 表示一种参数化的类型，比如Collection<string>；</string></li><li>通过反射读取注解的信息，模拟处理注解信息的流程，具体参见：<a href="https://chrisxb1996.github.io/2020/05/10/Java-注解/">Java 注解</a></li></ul><p><strong>反射的性能问题：</strong>使用反射性能会降低(约30倍)，setAccessible：启用和禁用访问安全检查的开关，设为 true 则表示反射的对象在使用时禁止 Java 语言访问检查。禁止安全检查，可以提高反射的运行速度(大约提高四倍)。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">动态语言：程序运行时，可以改变程序结构或变量类型。常见的动态语言：Python、ruby、javascript</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然Java不是动态语言&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，但Java语言具有一定的动态性，可以利用反射机制，字节码操作获得类似动态语言的特性，Java的动态性让编程更加灵活。&lt;br&gt;&lt;strong&gt;反射：&lt;/strong&gt;指的是可以在程序运行时加载、探知、使用编译期间完全未知的类。加载完类之后，在堆内存中，就产生了一个 Class 类型的对象&lt;strong&gt;(一个类只有一个 Class 对象)&lt;/strong&gt;，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，形象的称为反射。&lt;br&gt;&lt;strong&gt;反射机制的作用：&lt;/strong&gt;重点在于动态性：动态加载类、动态获取类的信息（属性、方法、构造器）；动态创建对象；动态调用方法、构造器；动态处理属性；此外还能处理泛型、注解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/tags/Java/"/>
    
      <category term="reflection" scheme="https://chrisxb1996.github.io/tags/reflection/"/>
    
      <category term="反射" scheme="https://chrisxb1996.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 注解</title>
    <link href="https://chrisxb1996.github.io/2020/05/10/Java-%E6%B3%A8%E8%A7%A3/"/>
    <id>https://chrisxb1996.github.io/2020/05/10/Java-%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-05-10T03:56:57.000Z</published>
    <updated>2020-05-14T03:16:59.928Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Annotation的作用：</strong><br>1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)<br>2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)<br><strong>Annotation的格式：</strong><br>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:<br>@SuppressWarnings(value=”unchecked”)。(抑制警告)<br><strong>Annotation在哪里使用：</strong><br>可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。<a id="more"></a><br><strong>自定义注解：</strong><br>格式：public @interface 注解名 {定义体}<br>1.方法的名称就是参数的名称;<br>2.返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）;<br>3.可以通过default来声明参数的默认值<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>;<br>4.如果只有一个参数成员，一般参数名为value;<br><strong>元注解：</strong><br>元注解的作用就是负责注解其他注解。 Java定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。<br>1.@Target：用于描述注解的使用范围（即:被描述的注解可以用在什么地方）<br>ElementType.TYPE；ElementType.FIELD…<br>2.@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期<br>SOURCE；CLASS；RUNTIME(可被反射机制读取)<br>3.@Documented<br>4.@Inherited<br><strong>通过反射读取注解的流程：</strong></p><ul><li>自定义类注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> test01Table &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义属性注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> test01Field &#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在test01中加入注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@test</span>01Table(<span class="string">"tb_member"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"id"</span>, type = <span class="string">"int"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"sname"</span>, type = <span class="string">"varchar"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@test</span>01Field(columnName = <span class="string">"age"</span>, type = <span class="string">"int"</span>, length = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读取test01中的注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射读取自定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.sgg.annotation.test01"</span>);</span><br><span class="line">            <span class="comment">//获得类的有效注解</span></span><br><span class="line">            Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span>(Annotation a : annotations)&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得类的制定注解</span></span><br><span class="line">            test01Table tt = (test01Table)clazz.getAnnotation(test01Table<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(tt.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得类的属性的对应注解</span></span><br><span class="line">            Field f = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">            test01Field tf = (test01Field)f.getAnnotation(test01Field<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(tf.columnName() +<span class="string">"--"</span>+ tf.type() +<span class="string">"--"</span>+ tf.length());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来可以利用注解信息写出DDL语句，完成相应的数据库操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Annotation的作用：&lt;/strong&gt;&lt;br&gt;1.不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别)&lt;br&gt;2.可以被其他程序(比如：编译器，其他类(通过反射))读取。(注解信息处理流程，是注解和注释的重大区别如果没有注解信息处理流程，则注解毫无意义)&lt;br&gt;&lt;strong&gt;Annotation的格式：&lt;/strong&gt;&lt;br&gt;注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如:&lt;br&gt;@SuppressWarnings(value=”unchecked”)。(抑制警告)&lt;br&gt;&lt;strong&gt;Annotation在哪里使用：&lt;/strong&gt;&lt;br&gt;可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://chrisxb1996.github.io/tags/Java/"/>
    
      <category term="annotation" scheme="https://chrisxb1996.github.io/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>用hexo搭建个人博客</title>
    <link href="https://chrisxb1996.github.io/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://chrisxb1996.github.io/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-09T08:50:49.000Z</published>
    <updated>2020-05-13T04:46:33.638Z</updated>
    
    <content type="html"><![CDATA[<p><strong>准备工作</strong><br>安装git：<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a><br>安装nodejs：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br><strong>安装hexo</strong><br>1.以管理员身份运行：sudo su<br>2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。<a id="more"></a><br>3.在国内建议先安装淘宝镜像源 cnpm再进行安装hexo：<br>输入：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>; 安装完后查    看是否安装成功： cnpm -v：<br><img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/001.png" alt="001"><br>    利用cnpm安装hexo博客 ：cnpm install -g hexo-cli<br>    安装成功可查看hexo信息：hexo -v:<br>    <img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/002.png" width="33%" height="33%"><br>4.可以新建一个 文件夹作为存放目录：mkdir blog，进到目录中：cd blog/ (注意操作都在当前文件夹下进行操作)<br>5.至此，hexo已经为你生成了基础博客框架，启动hexo输入 :hexo s<br><img src="/2020/05/09/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/003.png" width="80%" height="80%"><br>6.在浏览器输入地址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 可以看到基本框架已经生成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;br&gt;安装git：&lt;a href=&quot;https://git-scm.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git-scm.com&lt;/a&gt;&lt;br&gt;安装nodejs：&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;br&gt;&lt;strong&gt;安装hexo&lt;/strong&gt;&lt;br&gt;1.以管理员身份运行：sudo su&lt;br&gt;2.可以验证是否装好git和nodejs输入：git -version；node -v；npm -v；查看对应的版本是否一致。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://chrisxb1996.github.io/categories/hexo/"/>
    
    
      <category term="git" scheme="https://chrisxb1996.github.io/tags/git/"/>
    
      <category term="hexo" scheme="https://chrisxb1996.github.io/tags/hexo/"/>
    
      <category term="nodejs" scheme="https://chrisxb1996.github.io/tags/nodejs/"/>
    
  </entry>
  
</feed>
